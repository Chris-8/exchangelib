<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>exchangelib.autodiscover.discovery.pox API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>exchangelib.autodiscover.discovery.pox</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import logging
import time

from ...configuration import Configuration
from ...errors import AutoDiscoverFailed, RedirectError, TransportError, UnauthorizedError
from ...protocol import Protocol
from ...transport import AUTH_TYPE_MAP, DEFAULT_HEADERS, GSSAPI, NOAUTH, get_auth_method_from_response
from ...util import (
    CONNECTION_ERRORS,
    TLS_ERRORS,
    DummyResponse,
    ParseError,
    _back_off_if_needed,
    get_redirect_url,
    post_ratelimited,
)
from ..cache import autodiscover_cache
from ..properties import Autodiscover
from ..protocol import AutodiscoverProtocol
from .base import BaseAutodiscovery

log = logging.getLogger(__name__)


def discover(email, credentials=None, auth_type=None, retry_policy=None):
    ad_response, protocol = PoxAutodiscovery(email=email, credentials=credentials).discover()
    protocol.config.auth_typ = auth_type
    protocol.config.retry_policy = retry_policy
    return ad_response, protocol


class PoxAutodiscovery(BaseAutodiscovery):
    URL_PATH = &#34;Autodiscover/Autodiscover.xml&#34;

    def _build_response(self, ad_response):
        if not ad_response.autodiscover_smtp_address:
            # Autodiscover does not always return an email address. In that case, the requesting email should be used
            ad_response.user.autodiscover_smtp_address = self.email

        protocol = Protocol(
            config=Configuration(
                service_endpoint=ad_response.protocol.ews_url,
                credentials=self.credentials,
                version=ad_response.version,
                auth_type=ad_response.protocol.auth_type,
            )
        )
        return ad_response, protocol

    def _quick(self, protocol):
        try:
            r = self._get_authenticated_response(protocol=protocol)
        except TransportError as e:
            raise AutoDiscoverFailed(f&#34;Response error: {e}&#34;)
        if r.status_code == 200:
            try:
                ad = Autodiscover.from_bytes(bytes_content=r.content)
            except ParseError as e:
                raise AutoDiscoverFailed(f&#34;Invalid response: {e}&#34;)
            else:
                return self._step_5(ad=ad)
        raise AutoDiscoverFailed(f&#34;Invalid response code: {r.status_code}&#34;)

    def _get_unauthenticated_response(self, url, method=&#34;post&#34;):
        &#34;&#34;&#34;Get auth type by tasting headers from the server. Do POST requests be default. HEAD is too error-prone, and
        some servers are set up to redirect to OWA on all requests except POST to the autodiscover endpoint.

        :param url:
        :param method:  (Default value = &#39;post&#39;)
        :return:
        &#34;&#34;&#34;
        # We are connecting to untrusted servers here, so take necessary precautions.
        self._ensure_valid_hostname(url)

        kwargs = dict(
            url=url, headers=DEFAULT_HEADERS.copy(), allow_redirects=False, timeout=AutodiscoverProtocol.TIMEOUT
        )
        if method == &#34;post&#34;:
            kwargs[&#34;data&#34;] = Autodiscover.payload(email=self.email)
        retry = 0
        t_start = time.monotonic()
        while True:
            _back_off_if_needed(self.INITIAL_RETRY_POLICY.back_off_until)
            log.debug(&#34;Trying to get response from %s&#34;, url)
            with AutodiscoverProtocol.raw_session(url) as s:
                try:
                    r = getattr(s, method)(**kwargs)
                    r.close()  # Release memory
                    break
                except TLS_ERRORS as e:
                    # Don&#39;t retry on TLS errors. They will most likely be persistent.
                    raise TransportError(str(e))
                except CONNECTION_ERRORS as e:
                    r = DummyResponse(url=url, request_headers=kwargs[&#34;headers&#34;])
                    total_wait = time.monotonic() - t_start
                    if self.INITIAL_RETRY_POLICY.may_retry_on_error(response=r, wait=total_wait):
                        log.debug(&#34;Connection error on URL %s (retry %s, error: %s). Cool down&#34;, url, retry, e)
                        # Don&#39;t respect the &#39;Retry-After&#39; header. We don&#39;t know if this is a useful endpoint, and we
                        # want autodiscover to be reasonably fast.
                        self.INITIAL_RETRY_POLICY.back_off(self.RETRY_WAIT)
                        retry += 1
                        continue
                    log.debug(&#34;Connection error on URL %s: %s&#34;, url, e)
                    raise TransportError(str(e))
        try:
            auth_type = get_auth_method_from_response(response=r)
        except UnauthorizedError:
            # Failed to guess the auth type
            auth_type = NOAUTH
        if r.status_code in (301, 302) and &#34;location&#34; in r.headers:
            # Make the redirect URL absolute
            try:
                r.headers[&#34;location&#34;] = get_redirect_url(r)
            except TransportError:
                del r.headers[&#34;location&#34;]
        return auth_type, r

    def _get_authenticated_response(self, protocol):
        &#34;&#34;&#34;Get a response by using the credentials provided. We guess the auth type along the way.

        :param protocol:
        :return:
        &#34;&#34;&#34;
        # Redo the request with the correct auth
        data = Autodiscover.payload(email=self.email)
        headers = DEFAULT_HEADERS.copy()
        session = protocol.get_session()
        if GSSAPI in AUTH_TYPE_MAP and isinstance(session.auth, AUTH_TYPE_MAP[GSSAPI]):
            # https://docs.microsoft.com/en-us/exchange/client-developer/web-service-reference/pox-autodiscover-request-for-exchange
            headers[&#34;X-ClientCanHandle&#34;] = &#34;Negotiate&#34;
        try:
            r, session = post_ratelimited(
                protocol=protocol,
                session=session,
                url=protocol.service_endpoint,
                headers=headers,
                data=data,
            )
            protocol.release_session(session)
        except UnauthorizedError as e:
            # It&#39;s entirely possible for the endpoint to ask for login. We should continue if login fails because this
            # isn&#39;t necessarily the right endpoint to use.
            raise TransportError(str(e))
        except RedirectError as e:
            r = DummyResponse(url=protocol.service_endpoint, headers={&#34;location&#34;: e.url}, status_code=302)
        return r

    def _attempt_response(self, url):
        &#34;&#34;&#34;Return an (is_valid_response, response) tuple.

        :param url:
        :return:
        &#34;&#34;&#34;
        self._urls_visited.append(url.lower())
        log.debug(&#34;Attempting to get a valid response from %s&#34;, url)
        try:
            auth_type, r = self._get_unauthenticated_response(url=url)
            ad_protocol = AutodiscoverProtocol(
                config=Configuration(
                    service_endpoint=url,
                    credentials=self.credentials,
                    auth_type=auth_type,
                    retry_policy=self.INITIAL_RETRY_POLICY,
                )
            )
            if auth_type != NOAUTH:
                r = self._get_authenticated_response(protocol=ad_protocol)
        except TransportError as e:
            log.debug(&#34;Failed to get a response: %s&#34;, e)
            return False, None
        if r.status_code in (301, 302) and &#34;location&#34; in r.headers:
            redirect_url = get_redirect_url(r)
            if self._redirect_url_is_valid(url=redirect_url):
                # The protocol does not specify this explicitly, but by looking at how testconnectivity.microsoft.com
                # works, it seems that we should follow this URL now and try to get a valid response.
                return self._attempt_response(url=redirect_url)
        if r.status_code == 200:
            try:
                ad = Autodiscover.from_bytes(bytes_content=r.content)
            except ParseError as e:
                log.debug(&#34;Invalid response: %s&#34;, e)
            else:
                # We got a valid response. Unless this is a URL redirect response, we cache the result
                if ad.response is None or not ad.response.redirect_url:
                    cache_key = self._cache_key
                    log.debug(&#34;Adding cache entry for key %s: %s&#34;, cache_key, ad_protocol.service_endpoint)
                    autodiscover_cache[cache_key] = ad_protocol
                return True, ad
        return False, None</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="exchangelib.autodiscover.discovery.pox.discover"><code class="name flex">
<span>def <span class="ident">discover</span></span>(<span>email, credentials=None, auth_type=None, retry_policy=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def discover(email, credentials=None, auth_type=None, retry_policy=None):
    ad_response, protocol = PoxAutodiscovery(email=email, credentials=credentials).discover()
    protocol.config.auth_typ = auth_type
    protocol.config.retry_policy = retry_policy
    return ad_response, protocol</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="exchangelib.autodiscover.discovery.pox.PoxAutodiscovery"><code class="flex name class">
<span>class <span class="ident">PoxAutodiscovery</span></span>
<span>(</span><span>email, credentials=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Autodiscover is a Microsoft protocol for automatically getting the endpoint of the Exchange server and other
connection-related settings holding the email address using only the email address, and username and password of the
user.</p>
<p>For a description of the protocol implemented, see "Autodiscover for Exchange ActiveSync developers":</p>
<p><a href="https://docs.microsoft.com/en-us/previous-versions/office/developer/exchange-server-interoperability-guidance/hh352638%28v%3dexchg.140%29">https://docs.microsoft.com/en-us/previous-versions/office/developer/exchange-server-interoperability-guidance/hh352638%28v%3dexchg.140%29</a></p>
<p>Descriptions of the steps from the article are provided in their respective methods in this class.</p>
<p>For a description of how to handle autodiscover error messages, see:</p>
<p><a href="https://docs.microsoft.com/en-us/exchange/client-developer/exchange-web-services/handling-autodiscover-error-messages">https://docs.microsoft.com/en-us/exchange/client-developer/exchange-web-services/handling-autodiscover-error-messages</a></p>
<p>A tip from the article:
The client can perform steps 1 through 4 in any order or in parallel to expedite the process, but it must wait for
responses to finish at each step before proceeding. Given that many organizations prefer to use the URL in step 2 to
set up the Autodiscover service, the client might try this step first.</p>
<p>Another possibly newer resource which has not yet been attempted is "Outlook 2016 Implementation of Autodiscover":
<a href="https://support.microsoft.com/en-us/help/3211279/outlook-2016-implementation-of-autodiscover">https://support.microsoft.com/en-us/help/3211279/outlook-2016-implementation-of-autodiscover</a></p>
<p>WARNING: The autodiscover protocol is very complicated. If you have problems autodiscovering using this
implementation, start by doing an official test at <a href="https://testconnectivity.microsoft.com">https://testconnectivity.microsoft.com</a></p>
<p>:param email: The email address to autodiscover
:param credentials: Credentials with authorization to make autodiscover lookups for this Account
(Default value = None)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class PoxAutodiscovery(BaseAutodiscovery):
    URL_PATH = &#34;Autodiscover/Autodiscover.xml&#34;

    def _build_response(self, ad_response):
        if not ad_response.autodiscover_smtp_address:
            # Autodiscover does not always return an email address. In that case, the requesting email should be used
            ad_response.user.autodiscover_smtp_address = self.email

        protocol = Protocol(
            config=Configuration(
                service_endpoint=ad_response.protocol.ews_url,
                credentials=self.credentials,
                version=ad_response.version,
                auth_type=ad_response.protocol.auth_type,
            )
        )
        return ad_response, protocol

    def _quick(self, protocol):
        try:
            r = self._get_authenticated_response(protocol=protocol)
        except TransportError as e:
            raise AutoDiscoverFailed(f&#34;Response error: {e}&#34;)
        if r.status_code == 200:
            try:
                ad = Autodiscover.from_bytes(bytes_content=r.content)
            except ParseError as e:
                raise AutoDiscoverFailed(f&#34;Invalid response: {e}&#34;)
            else:
                return self._step_5(ad=ad)
        raise AutoDiscoverFailed(f&#34;Invalid response code: {r.status_code}&#34;)

    def _get_unauthenticated_response(self, url, method=&#34;post&#34;):
        &#34;&#34;&#34;Get auth type by tasting headers from the server. Do POST requests be default. HEAD is too error-prone, and
        some servers are set up to redirect to OWA on all requests except POST to the autodiscover endpoint.

        :param url:
        :param method:  (Default value = &#39;post&#39;)
        :return:
        &#34;&#34;&#34;
        # We are connecting to untrusted servers here, so take necessary precautions.
        self._ensure_valid_hostname(url)

        kwargs = dict(
            url=url, headers=DEFAULT_HEADERS.copy(), allow_redirects=False, timeout=AutodiscoverProtocol.TIMEOUT
        )
        if method == &#34;post&#34;:
            kwargs[&#34;data&#34;] = Autodiscover.payload(email=self.email)
        retry = 0
        t_start = time.monotonic()
        while True:
            _back_off_if_needed(self.INITIAL_RETRY_POLICY.back_off_until)
            log.debug(&#34;Trying to get response from %s&#34;, url)
            with AutodiscoverProtocol.raw_session(url) as s:
                try:
                    r = getattr(s, method)(**kwargs)
                    r.close()  # Release memory
                    break
                except TLS_ERRORS as e:
                    # Don&#39;t retry on TLS errors. They will most likely be persistent.
                    raise TransportError(str(e))
                except CONNECTION_ERRORS as e:
                    r = DummyResponse(url=url, request_headers=kwargs[&#34;headers&#34;])
                    total_wait = time.monotonic() - t_start
                    if self.INITIAL_RETRY_POLICY.may_retry_on_error(response=r, wait=total_wait):
                        log.debug(&#34;Connection error on URL %s (retry %s, error: %s). Cool down&#34;, url, retry, e)
                        # Don&#39;t respect the &#39;Retry-After&#39; header. We don&#39;t know if this is a useful endpoint, and we
                        # want autodiscover to be reasonably fast.
                        self.INITIAL_RETRY_POLICY.back_off(self.RETRY_WAIT)
                        retry += 1
                        continue
                    log.debug(&#34;Connection error on URL %s: %s&#34;, url, e)
                    raise TransportError(str(e))
        try:
            auth_type = get_auth_method_from_response(response=r)
        except UnauthorizedError:
            # Failed to guess the auth type
            auth_type = NOAUTH
        if r.status_code in (301, 302) and &#34;location&#34; in r.headers:
            # Make the redirect URL absolute
            try:
                r.headers[&#34;location&#34;] = get_redirect_url(r)
            except TransportError:
                del r.headers[&#34;location&#34;]
        return auth_type, r

    def _get_authenticated_response(self, protocol):
        &#34;&#34;&#34;Get a response by using the credentials provided. We guess the auth type along the way.

        :param protocol:
        :return:
        &#34;&#34;&#34;
        # Redo the request with the correct auth
        data = Autodiscover.payload(email=self.email)
        headers = DEFAULT_HEADERS.copy()
        session = protocol.get_session()
        if GSSAPI in AUTH_TYPE_MAP and isinstance(session.auth, AUTH_TYPE_MAP[GSSAPI]):
            # https://docs.microsoft.com/en-us/exchange/client-developer/web-service-reference/pox-autodiscover-request-for-exchange
            headers[&#34;X-ClientCanHandle&#34;] = &#34;Negotiate&#34;
        try:
            r, session = post_ratelimited(
                protocol=protocol,
                session=session,
                url=protocol.service_endpoint,
                headers=headers,
                data=data,
            )
            protocol.release_session(session)
        except UnauthorizedError as e:
            # It&#39;s entirely possible for the endpoint to ask for login. We should continue if login fails because this
            # isn&#39;t necessarily the right endpoint to use.
            raise TransportError(str(e))
        except RedirectError as e:
            r = DummyResponse(url=protocol.service_endpoint, headers={&#34;location&#34;: e.url}, status_code=302)
        return r

    def _attempt_response(self, url):
        &#34;&#34;&#34;Return an (is_valid_response, response) tuple.

        :param url:
        :return:
        &#34;&#34;&#34;
        self._urls_visited.append(url.lower())
        log.debug(&#34;Attempting to get a valid response from %s&#34;, url)
        try:
            auth_type, r = self._get_unauthenticated_response(url=url)
            ad_protocol = AutodiscoverProtocol(
                config=Configuration(
                    service_endpoint=url,
                    credentials=self.credentials,
                    auth_type=auth_type,
                    retry_policy=self.INITIAL_RETRY_POLICY,
                )
            )
            if auth_type != NOAUTH:
                r = self._get_authenticated_response(protocol=ad_protocol)
        except TransportError as e:
            log.debug(&#34;Failed to get a response: %s&#34;, e)
            return False, None
        if r.status_code in (301, 302) and &#34;location&#34; in r.headers:
            redirect_url = get_redirect_url(r)
            if self._redirect_url_is_valid(url=redirect_url):
                # The protocol does not specify this explicitly, but by looking at how testconnectivity.microsoft.com
                # works, it seems that we should follow this URL now and try to get a valid response.
                return self._attempt_response(url=redirect_url)
        if r.status_code == 200:
            try:
                ad = Autodiscover.from_bytes(bytes_content=r.content)
            except ParseError as e:
                log.debug(&#34;Invalid response: %s&#34;, e)
            else:
                # We got a valid response. Unless this is a URL redirect response, we cache the result
                if ad.response is None or not ad.response.redirect_url:
                    cache_key = self._cache_key
                    log.debug(&#34;Adding cache entry for key %s: %s&#34;, cache_key, ad_protocol.service_endpoint)
                    autodiscover_cache[cache_key] = ad_protocol
                return True, ad
        return False, None</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="exchangelib.autodiscover.discovery.base.BaseAutodiscovery" href="base.html#exchangelib.autodiscover.discovery.base.BaseAutodiscovery">BaseAutodiscovery</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="exchangelib.autodiscover.discovery.pox.PoxAutodiscovery.URL_PATH"><code class="name">var <span class="ident">URL_PATH</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="exchangelib.autodiscover.discovery" href="index.html">exchangelib.autodiscover.discovery</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="exchangelib.autodiscover.discovery.pox.discover" href="#exchangelib.autodiscover.discovery.pox.discover">discover</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="exchangelib.autodiscover.discovery.pox.PoxAutodiscovery" href="#exchangelib.autodiscover.discovery.pox.PoxAutodiscovery">PoxAutodiscovery</a></code></h4>
<ul class="">
<li><code><a title="exchangelib.autodiscover.discovery.pox.PoxAutodiscovery.URL_PATH" href="#exchangelib.autodiscover.discovery.pox.PoxAutodiscovery.URL_PATH">URL_PATH</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>
