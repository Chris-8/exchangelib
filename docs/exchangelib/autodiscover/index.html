<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>exchangelib.autodiscover API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>exchangelib.autodiscover</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">from .cache import AutodiscoverCache, autodiscover_cache
from .discovery.pox import PoxAutodiscovery as Autodiscovery
from .discovery.pox import discover
from .protocol import AutodiscoverProtocol


def close_connections():
    with autodiscover_cache:
        autodiscover_cache.close()


def clear_cache():
    with autodiscover_cache:
        autodiscover_cache.clear()


__all__ = [
    &#34;AutodiscoverCache&#34;,
    &#34;AutodiscoverProtocol&#34;,
    &#34;Autodiscovery&#34;,
    &#34;discover&#34;,
    &#34;autodiscover_cache&#34;,
    &#34;close_connections&#34;,
    &#34;clear_cache&#34;,
]</code></pre>
</details>
</section>
<section>
<h2 class="section-title" id="header-submodules">Sub-modules</h2>
<dl>
<dt><code class="name"><a title="exchangelib.autodiscover.cache" href="cache.html">exchangelib.autodiscover.cache</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="exchangelib.autodiscover.discovery" href="discovery/index.html">exchangelib.autodiscover.discovery</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="exchangelib.autodiscover.properties" href="properties.html">exchangelib.autodiscover.properties</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="exchangelib.autodiscover.protocol" href="protocol.html">exchangelib.autodiscover.protocol</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="exchangelib.autodiscover.clear_cache"><code class="name flex">
<span>def <span class="ident">clear_cache</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def clear_cache():
    with autodiscover_cache:
        autodiscover_cache.clear()</code></pre>
</details>
</dd>
<dt id="exchangelib.autodiscover.close_connections"><code class="name flex">
<span>def <span class="ident">close_connections</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def close_connections():
    with autodiscover_cache:
        autodiscover_cache.close()</code></pre>
</details>
</dd>
<dt id="exchangelib.autodiscover.discover"><code class="name flex">
<span>def <span class="ident">discover</span></span>(<span>email, credentials=None, auth_type=None, retry_policy=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def discover(email, credentials=None, auth_type=None, retry_policy=None):
    ad_response, protocol = PoxAutodiscovery(email=email, credentials=credentials).discover()
    protocol.config.auth_typ = auth_type
    protocol.config.retry_policy = retry_policy
    return ad_response, protocol</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="exchangelib.autodiscover.AutodiscoverCache"><code class="flex name class">
<span>class <span class="ident">AutodiscoverCache</span></span>
</code></dt>
<dd>
<div class="desc"><p>Stores the translation from (email domain, credentials) -&gt; AutodiscoverProtocol object, so we can re-use TCP
connections to an autodiscover server within the same process. Also persists the email domain -&gt; (autodiscover
endpoint URL, auth_type) translation to the filesystem so the cache can be shared between multiple processes.</p>
<p>According to Microsoft, we may forever cache the (email domain -&gt; autodiscover endpoint URL) mapping, or until
it stops responding. My previous experience with Exchange products in mind, I'm not sure if I should trust that
advice. But it could save some valuable seconds every time we start a new connection to a known server. In any
case, the persistent storage must not contain any sensitive information since the cache could be readable by
unprivileged users. Domain, endpoint and auth_type are OK to cache since this info is make publicly available on
HTTP and DNS servers via the autodiscover protocol. Just don't persist any credential info.</p>
<p>If an autodiscover lookup fails for any reason, the corresponding cache entry must be purged.</p>
<p>'shelve' is supposedly thread-safe and process-safe, which suits our needs.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class AutodiscoverCache:
    &#34;&#34;&#34;Stores the translation from (email domain, credentials) -&gt; AutodiscoverProtocol object, so we can re-use TCP
    connections to an autodiscover server within the same process. Also persists the email domain -&gt; (autodiscover
    endpoint URL, auth_type) translation to the filesystem so the cache can be shared between multiple processes.

    According to Microsoft, we may forever cache the (email domain -&gt; autodiscover endpoint URL) mapping, or until
    it stops responding. My previous experience with Exchange products in mind, I&#39;m not sure if I should trust that
    advice. But it could save some valuable seconds every time we start a new connection to a known server. In any
    case, the persistent storage must not contain any sensitive information since the cache could be readable by
    unprivileged users. Domain, endpoint and auth_type are OK to cache since this info is make publicly available on
    HTTP and DNS servers via the autodiscover protocol. Just don&#39;t persist any credential info.

    If an autodiscover lookup fails for any reason, the corresponding cache entry must be purged.

    &#39;shelve&#39; is supposedly thread-safe and process-safe, which suits our needs.
    &#34;&#34;&#34;

    def __init__(self):
        self._protocols = {}  # Mapping from (domain, credentials) to AutodiscoverProtocol
        self._lock = RLock()

    @property
    def _storage_file(self):
        return AUTODISCOVER_PERSISTENT_STORAGE

    def clear(self):
        # Wipe the entire cache
        with shelve_open_with_failover(self._storage_file) as db:
            db.clear()
        self._protocols.clear()

    def __len__(self):
        return len(self._protocols)

    def __contains__(self, key):
        domain = key[0]
        with shelve_open_with_failover(self._storage_file) as db:
            return str(domain) in db

    def __getitem__(self, key):
        protocol = self._protocols.get(key)
        if protocol:
            return protocol
        domain, credentials = key
        with shelve_open_with_failover(self._storage_file) as db:
            endpoint, auth_type, retry_policy = db[str(domain)]  # It&#39;s OK to fail with KeyError here
        protocol = AutodiscoverProtocol(
            config=Configuration(
                service_endpoint=endpoint, credentials=credentials, auth_type=auth_type, retry_policy=retry_policy
            )
        )
        self._protocols[key] = protocol
        return protocol

    def __setitem__(self, key, protocol):
        # Populate both local and persistent cache
        domain = key[0]
        with shelve_open_with_failover(self._storage_file) as db:
            # Don&#39;t change this payload without bumping the cache file version in shelve_filename()
            db[str(domain)] = (protocol.service_endpoint, protocol.auth_type, protocol.retry_policy)
        self._protocols[key] = protocol

    def __delitem__(self, key):
        # Empty both local and persistent cache. Don&#39;t fail on non-existing entries because we could end here
        # multiple times due to race conditions.
        domain = key[0]
        with shelve_open_with_failover(self._storage_file) as db:
            with suppress(KeyError):
                del db[str(domain)]
        with suppress(KeyError):
            del self._protocols[key]

    def close(self):
        # Close all open connections
        for (domain, _), protocol in self._protocols.items():
            log.debug(&#34;Domain %s: Closing sessions&#34;, domain)
            protocol.close()
            del protocol
        self._protocols.clear()

    def __enter__(self):
        self._lock.__enter__()

    def __exit__(self, *args, **kwargs):
        self._lock.__exit__(*args, **kwargs)

    def __del__(self):
        # pylint: disable=bare-except
        try:
            self.close()
        except Exception:  # nosec
            # __del__ should never fail
            pass

    def __str__(self):
        return str(self._protocols)</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="exchangelib.autodiscover.AutodiscoverCache.clear"><code class="name flex">
<span>def <span class="ident">clear</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def clear(self):
    # Wipe the entire cache
    with shelve_open_with_failover(self._storage_file) as db:
        db.clear()
    self._protocols.clear()</code></pre>
</details>
</dd>
<dt id="exchangelib.autodiscover.AutodiscoverCache.close"><code class="name flex">
<span>def <span class="ident">close</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def close(self):
    # Close all open connections
    for (domain, _), protocol in self._protocols.items():
        log.debug(&#34;Domain %s: Closing sessions&#34;, domain)
        protocol.close()
        del protocol
    self._protocols.clear()</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="exchangelib.autodiscover.AutodiscoverProtocol"><code class="flex name class">
<span>class <span class="ident">AutodiscoverProtocol</span></span>
<span>(</span><span>config)</span>
</code></dt>
<dd>
<div class="desc"><p>Protocol which implements the bare essentials for autodiscover.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class AutodiscoverProtocol(BaseProtocol):
    &#34;&#34;&#34;Protocol which implements the bare essentials for autodiscover.&#34;&#34;&#34;

    TIMEOUT = 10  # Seconds

    def __init__(self, config):
        if not config.version:
            # Default to the latest supported version
            config.version = Version.all_versions()[0]
        super().__init__(config=config)

    def __str__(self):
        return f&#34;&#34;&#34;\
Autodiscover endpoint: {self.service_endpoint}
Auth type: {self.auth_type}&#34;&#34;&#34;

    @property
    def version(self):
        return self.config.version

    @property
    def auth_type(self):
        # Autodetect authentication type if necessary
        if self.config.auth_type is None:
            self.config.auth_type = self.get_auth_type()
        return self.config.auth_type

    def get_auth_type(self):
        # Autodetect authentication type.
        return get_autodiscover_authtype(protocol=self)

    def get_user_settings(self, user):
        return GetUserSettings(protocol=self).get(
            users=[user],
            settings=[
                &#34;user_dn&#34;,
                &#34;mailbox_dn&#34;,
                &#34;user_display_name&#34;,
                &#34;auto_discover_smtp_address&#34;,
                &#34;external_ews_url&#34;,
                &#34;ews_supported_schemas&#34;,
            ],
        )

    def dummy_xml(self):
        # Generate a valid EWS request for SOAP autodiscovery
        svc = GetUserSettings(protocol=self)
        return svc.wrap(
            content=svc.get_payload(
                users=[&#34;DUMMY@example.com&#34;],
                settings=[&#34;auto_discover_smtp_address&#34;],
            ),
            api_version=self.config.version.api_version,
        )</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="exchangelib.protocol.BaseProtocol" href="../protocol.html#exchangelib.protocol.BaseProtocol">BaseProtocol</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="exchangelib.autodiscover.AutodiscoverProtocol.TIMEOUT"><code class="name">var <span class="ident">TIMEOUT</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="exchangelib.autodiscover.AutodiscoverProtocol.auth_type"><code class="name">var <span class="ident">auth_type</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def auth_type(self):
    # Autodetect authentication type if necessary
    if self.config.auth_type is None:
        self.config.auth_type = self.get_auth_type()
    return self.config.auth_type</code></pre>
</details>
</dd>
<dt id="exchangelib.autodiscover.AutodiscoverProtocol.version"><code class="name">var <span class="ident">version</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def version(self):
    return self.config.version</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="exchangelib.autodiscover.AutodiscoverProtocol.dummy_xml"><code class="name flex">
<span>def <span class="ident">dummy_xml</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def dummy_xml(self):
    # Generate a valid EWS request for SOAP autodiscovery
    svc = GetUserSettings(protocol=self)
    return svc.wrap(
        content=svc.get_payload(
            users=[&#34;DUMMY@example.com&#34;],
            settings=[&#34;auto_discover_smtp_address&#34;],
        ),
        api_version=self.config.version.api_version,
    )</code></pre>
</details>
</dd>
<dt id="exchangelib.autodiscover.AutodiscoverProtocol.get_user_settings"><code class="name flex">
<span>def <span class="ident">get_user_settings</span></span>(<span>self, user)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_user_settings(self, user):
    return GetUserSettings(protocol=self).get(
        users=[user],
        settings=[
            &#34;user_dn&#34;,
            &#34;mailbox_dn&#34;,
            &#34;user_display_name&#34;,
            &#34;auto_discover_smtp_address&#34;,
            &#34;external_ews_url&#34;,
            &#34;ews_supported_schemas&#34;,
        ],
    )</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="exchangelib.protocol.BaseProtocol" href="../protocol.html#exchangelib.protocol.BaseProtocol">BaseProtocol</a></b></code>:
<ul class="hlist">
<li><code><a title="exchangelib.protocol.BaseProtocol.HTTP_ADAPTER_CLS" href="../protocol.html#exchangelib.protocol.BaseProtocol.HTTP_ADAPTER_CLS">HTTP_ADAPTER_CLS</a></code></li>
<li><code><a title="exchangelib.protocol.BaseProtocol.decrease_poolsize" href="../protocol.html#exchangelib.protocol.BaseProtocol.decrease_poolsize">decrease_poolsize</a></code></li>
<li><code><a title="exchangelib.protocol.BaseProtocol.get_auth_type" href="../protocol.html#exchangelib.protocol.BaseProtocol.get_auth_type">get_auth_type</a></code></li>
<li><code><a title="exchangelib.protocol.BaseProtocol.increase_poolsize" href="../protocol.html#exchangelib.protocol.BaseProtocol.increase_poolsize">increase_poolsize</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="exchangelib.autodiscover.PoxAutodiscovery"><code class="flex name class">
<span>class <span class="ident">Autodiscovery</span></span>
<span>(</span><span>email, credentials=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Autodiscover is a Microsoft protocol for automatically getting the endpoint of the Exchange server and other
connection-related settings holding the email address using only the email address, and username and password of the
user.</p>
<p>For a description of the protocol implemented, see "Autodiscover for Exchange ActiveSync developers":</p>
<p><a href="https://docs.microsoft.com/en-us/previous-versions/office/developer/exchange-server-interoperability-guidance/hh352638%28v%3dexchg.140%29">https://docs.microsoft.com/en-us/previous-versions/office/developer/exchange-server-interoperability-guidance/hh352638%28v%3dexchg.140%29</a></p>
<p>Descriptions of the steps from the article are provided in their respective methods in this class.</p>
<p>For a description of how to handle autodiscover error messages, see:</p>
<p><a href="https://docs.microsoft.com/en-us/exchange/client-developer/exchange-web-services/handling-autodiscover-error-messages">https://docs.microsoft.com/en-us/exchange/client-developer/exchange-web-services/handling-autodiscover-error-messages</a></p>
<p>A tip from the article:
The client can perform steps 1 through 4 in any order or in parallel to expedite the process, but it must wait for
responses to finish at each step before proceeding. Given that many organizations prefer to use the URL in step 2 to
set up the Autodiscover service, the client might try this step first.</p>
<p>Another possibly newer resource which has not yet been attempted is "Outlook 2016 Implementation of Autodiscover":
<a href="https://support.microsoft.com/en-us/help/3211279/outlook-2016-implementation-of-autodiscover">https://support.microsoft.com/en-us/help/3211279/outlook-2016-implementation-of-autodiscover</a></p>
<p>WARNING: The autodiscover protocol is very complicated. If you have problems autodiscovering using this
implementation, start by doing an official test at <a href="https://testconnectivity.microsoft.com">https://testconnectivity.microsoft.com</a></p>
<p>:param email: The email address to autodiscover
:param credentials: Credentials with authorization to make autodiscover lookups for this Account
(Default value = None)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class PoxAutodiscovery(BaseAutodiscovery):
    URL_PATH = &#34;Autodiscover/Autodiscover.xml&#34;

    def _build_response(self, ad_response):
        if not ad_response.autodiscover_smtp_address:
            # Autodiscover does not always return an email address. In that case, the requesting email should be used
            ad_response.user.autodiscover_smtp_address = self.email

        protocol = Protocol(
            config=Configuration(
                service_endpoint=ad_response.protocol.ews_url,
                credentials=self.credentials,
                version=ad_response.version,
                auth_type=ad_response.protocol.auth_type,
            )
        )
        return ad_response, protocol

    def _quick(self, protocol):
        try:
            r = self._get_authenticated_response(protocol=protocol)
        except TransportError as e:
            raise AutoDiscoverFailed(f&#34;Response error: {e}&#34;)
        if r.status_code == 200:
            try:
                ad = Autodiscover.from_bytes(bytes_content=r.content)
            except ParseError as e:
                raise AutoDiscoverFailed(f&#34;Invalid response: {e}&#34;)
            else:
                return self._step_5(ad=ad)
        raise AutoDiscoverFailed(f&#34;Invalid response code: {r.status_code}&#34;)

    def _get_unauthenticated_response(self, url, method=&#34;post&#34;):
        &#34;&#34;&#34;Get auth type by tasting headers from the server. Do POST requests be default. HEAD is too error-prone, and
        some servers are set up to redirect to OWA on all requests except POST to the autodiscover endpoint.

        :param url:
        :param method:  (Default value = &#39;post&#39;)
        :return:
        &#34;&#34;&#34;
        # We are connecting to untrusted servers here, so take necessary precautions.
        self._ensure_valid_hostname(url)

        kwargs = dict(
            url=url, headers=DEFAULT_HEADERS.copy(), allow_redirects=False, timeout=AutodiscoverProtocol.TIMEOUT
        )
        if method == &#34;post&#34;:
            kwargs[&#34;data&#34;] = Autodiscover.payload(email=self.email)
        retry = 0
        t_start = time.monotonic()
        while True:
            _back_off_if_needed(self.INITIAL_RETRY_POLICY.back_off_until)
            log.debug(&#34;Trying to get response from %s&#34;, url)
            with AutodiscoverProtocol.raw_session(url) as s:
                try:
                    r = getattr(s, method)(**kwargs)
                    r.close()  # Release memory
                    break
                except TLS_ERRORS as e:
                    # Don&#39;t retry on TLS errors. They will most likely be persistent.
                    raise TransportError(str(e))
                except CONNECTION_ERRORS as e:
                    r = DummyResponse(url=url, request_headers=kwargs[&#34;headers&#34;])
                    total_wait = time.monotonic() - t_start
                    if self.INITIAL_RETRY_POLICY.may_retry_on_error(response=r, wait=total_wait):
                        log.debug(&#34;Connection error on URL %s (retry %s, error: %s). Cool down&#34;, url, retry, e)
                        # Don&#39;t respect the &#39;Retry-After&#39; header. We don&#39;t know if this is a useful endpoint, and we
                        # want autodiscover to be reasonably fast.
                        self.INITIAL_RETRY_POLICY.back_off(self.RETRY_WAIT)
                        retry += 1
                        continue
                    log.debug(&#34;Connection error on URL %s: %s&#34;, url, e)
                    raise TransportError(str(e))
        try:
            auth_type = get_auth_method_from_response(response=r)
        except UnauthorizedError:
            # Failed to guess the auth type
            auth_type = NOAUTH
        if r.status_code in (301, 302) and &#34;location&#34; in r.headers:
            # Make the redirect URL absolute
            try:
                r.headers[&#34;location&#34;] = get_redirect_url(r)
            except TransportError:
                del r.headers[&#34;location&#34;]
        return auth_type, r

    def _get_authenticated_response(self, protocol):
        &#34;&#34;&#34;Get a response by using the credentials provided. We guess the auth type along the way.

        :param protocol:
        :return:
        &#34;&#34;&#34;
        # Redo the request with the correct auth
        data = Autodiscover.payload(email=self.email)
        headers = DEFAULT_HEADERS.copy()
        session = protocol.get_session()
        if GSSAPI in AUTH_TYPE_MAP and isinstance(session.auth, AUTH_TYPE_MAP[GSSAPI]):
            # https://docs.microsoft.com/en-us/exchange/client-developer/web-service-reference/pox-autodiscover-request-for-exchange
            headers[&#34;X-ClientCanHandle&#34;] = &#34;Negotiate&#34;
        try:
            r, session = post_ratelimited(
                protocol=protocol,
                session=session,
                url=protocol.service_endpoint,
                headers=headers,
                data=data,
            )
            protocol.release_session(session)
        except UnauthorizedError as e:
            # It&#39;s entirely possible for the endpoint to ask for login. We should continue if login fails because this
            # isn&#39;t necessarily the right endpoint to use.
            raise TransportError(str(e))
        except RedirectError as e:
            r = DummyResponse(url=protocol.service_endpoint, headers={&#34;location&#34;: e.url}, status_code=302)
        return r

    def _attempt_response(self, url):
        &#34;&#34;&#34;Return an (is_valid_response, response) tuple.

        :param url:
        :return:
        &#34;&#34;&#34;
        self._urls_visited.append(url.lower())
        log.debug(&#34;Attempting to get a valid response from %s&#34;, url)
        try:
            auth_type, r = self._get_unauthenticated_response(url=url)
            ad_protocol = AutodiscoverProtocol(
                config=Configuration(
                    service_endpoint=url,
                    credentials=self.credentials,
                    auth_type=auth_type,
                    retry_policy=self.INITIAL_RETRY_POLICY,
                )
            )
            if auth_type != NOAUTH:
                r = self._get_authenticated_response(protocol=ad_protocol)
        except TransportError as e:
            log.debug(&#34;Failed to get a response: %s&#34;, e)
            return False, None
        if r.status_code in (301, 302) and &#34;location&#34; in r.headers:
            redirect_url = get_redirect_url(r)
            if self._redirect_url_is_valid(url=redirect_url):
                # The protocol does not specify this explicitly, but by looking at how testconnectivity.microsoft.com
                # works, it seems that we should follow this URL now and try to get a valid response.
                return self._attempt_response(url=redirect_url)
        if r.status_code == 200:
            try:
                ad = Autodiscover.from_bytes(bytes_content=r.content)
            except ParseError as e:
                log.debug(&#34;Invalid response: %s&#34;, e)
            else:
                # We got a valid response. Unless this is a URL redirect response, we cache the result
                if ad.response is None or not ad.response.redirect_url:
                    cache_key = self._cache_key
                    log.debug(&#34;Adding cache entry for key %s: %s&#34;, cache_key, ad_protocol.service_endpoint)
                    autodiscover_cache[cache_key] = ad_protocol
                return True, ad
        return False, None</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="exchangelib.autodiscover.discovery.base.BaseAutodiscovery" href="discovery/base.html#exchangelib.autodiscover.discovery.base.BaseAutodiscovery">BaseAutodiscovery</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="exchangelib.autodiscover.PoxAutodiscovery.URL_PATH"><code class="name">var <span class="ident">URL_PATH</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="exchangelib" href="../index.html">exchangelib</a></code></li>
</ul>
</li>
<li><h3><a href="#header-submodules">Sub-modules</a></h3>
<ul>
<li><code><a title="exchangelib.autodiscover.cache" href="cache.html">exchangelib.autodiscover.cache</a></code></li>
<li><code><a title="exchangelib.autodiscover.discovery" href="discovery/index.html">exchangelib.autodiscover.discovery</a></code></li>
<li><code><a title="exchangelib.autodiscover.properties" href="properties.html">exchangelib.autodiscover.properties</a></code></li>
<li><code><a title="exchangelib.autodiscover.protocol" href="protocol.html">exchangelib.autodiscover.protocol</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="exchangelib.autodiscover.clear_cache" href="#exchangelib.autodiscover.clear_cache">clear_cache</a></code></li>
<li><code><a title="exchangelib.autodiscover.close_connections" href="#exchangelib.autodiscover.close_connections">close_connections</a></code></li>
<li><code><a title="exchangelib.autodiscover.discover" href="#exchangelib.autodiscover.discover">discover</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="exchangelib.autodiscover.AutodiscoverCache" href="#exchangelib.autodiscover.AutodiscoverCache">AutodiscoverCache</a></code></h4>
<ul class="">
<li><code><a title="exchangelib.autodiscover.AutodiscoverCache.clear" href="#exchangelib.autodiscover.AutodiscoverCache.clear">clear</a></code></li>
<li><code><a title="exchangelib.autodiscover.AutodiscoverCache.close" href="#exchangelib.autodiscover.AutodiscoverCache.close">close</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="exchangelib.autodiscover.AutodiscoverProtocol" href="#exchangelib.autodiscover.AutodiscoverProtocol">AutodiscoverProtocol</a></code></h4>
<ul class="">
<li><code><a title="exchangelib.autodiscover.AutodiscoverProtocol.TIMEOUT" href="#exchangelib.autodiscover.AutodiscoverProtocol.TIMEOUT">TIMEOUT</a></code></li>
<li><code><a title="exchangelib.autodiscover.AutodiscoverProtocol.auth_type" href="#exchangelib.autodiscover.AutodiscoverProtocol.auth_type">auth_type</a></code></li>
<li><code><a title="exchangelib.autodiscover.AutodiscoverProtocol.dummy_xml" href="#exchangelib.autodiscover.AutodiscoverProtocol.dummy_xml">dummy_xml</a></code></li>
<li><code><a title="exchangelib.autodiscover.AutodiscoverProtocol.get_user_settings" href="#exchangelib.autodiscover.AutodiscoverProtocol.get_user_settings">get_user_settings</a></code></li>
<li><code><a title="exchangelib.autodiscover.AutodiscoverProtocol.version" href="#exchangelib.autodiscover.AutodiscoverProtocol.version">version</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="exchangelib.autodiscover.PoxAutodiscovery" href="#exchangelib.autodiscover.PoxAutodiscovery">PoxAutodiscovery</a></code></h4>
<ul class="">
<li><code><a title="exchangelib.autodiscover.PoxAutodiscovery.URL_PATH" href="#exchangelib.autodiscover.PoxAutodiscovery.URL_PATH">URL_PATH</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>
