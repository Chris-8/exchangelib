<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>exchangelib.credentials API documentation</title>
<meta name="description" content="Implements an Exchange user object and access types. Exchange provides two different ways of granting access for a
login to a specific account â€¦" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>exchangelib.credentials</code></h1>
</header>
<section id="section-intro">
<p>Implements an Exchange user object and access types. Exchange provides two different ways of granting access for a
login to a specific account. Impersonation is used mainly for service accounts that connect via EWS. Delegate is used
for ad-hoc access e.g. granted manually by the user.
See <a href="http://blogs.msdn.com/b/exchangedev/archive/2009/06/15/exchange-impersonation-vs-delegate-access.aspx">http://blogs.msdn.com/b/exchangedev/archive/2009/06/15/exchange-impersonation-vs-delegate-access.aspx</a></p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;
Implements an Exchange user object and access types. Exchange provides two different ways of granting access for a
login to a specific account. Impersonation is used mainly for service accounts that connect via EWS. Delegate is used
for ad-hoc access e.g. granted manually by the user.
See http://blogs.msdn.com/b/exchangedev/archive/2009/06/15/exchange-impersonation-vs-delegate-access.aspx
&#34;&#34;&#34;
import abc
import logging
from threading import RLock

log = logging.getLogger(__name__)

IMPERSONATION = &#39;impersonation&#39;
DELEGATE = &#39;delegate&#39;
ACCESS_TYPES = (IMPERSONATION, DELEGATE)


class BaseCredentials(metaclass=abc.ABCMeta):
    &#34;&#34;&#34;Base for credential storage.

    Establishes a method for refreshing credentials (mostly useful with OAuth, which expires tokens relatively
    frequently) and provides a lock for synchronizing access to the object around refreshes.
    &#34;&#34;&#34;

    def __init__(self):
        self._lock = RLock()

    @property
    def lock(self):
        return self._lock

    @abc.abstractmethod
    def refresh(self, session):
        &#34;&#34;&#34;Obtain a new set of valid credentials. This is mostly intended to support OAuth token refreshing, which can
        happen in long- running applications or those that cache access tokens and so might start with a token close to
        expiration.

        :param session: requests session asking for refreshed credentials
        :return:
        &#34;&#34;&#34;

    def _get_hash_values(self):
        return (getattr(self, k) for k in self.__dict__ if k != &#39;_lock&#39;)

    def __eq__(self, other):
        for k in self.__dict__:
            if k == &#39;_lock&#39;:
                continue
            if getattr(self, k) != getattr(other, k):
                return False
        return True

    def __hash__(self):
        return hash(tuple(self._get_hash_values()))

    def __getstate__(self):
        # The lock cannot be pickled
        state = self.__dict__.copy()
        del state[&#39;_lock&#39;]
        return state

    def __setstate__(self, state):
        # Restore the lock
        self.__dict__.update(state)
        self._lock = RLock()


class Credentials(BaseCredentials):
    r&#34;&#34;&#34;Keeps login info the way Exchange likes it.

    Usernames for authentication are of one of these forms:
    * PrimarySMTPAddress
    * WINDOMAIN\username
    * User Principal Name (UPN)
      password: Clear-text password
    &#34;&#34;&#34;

    EMAIL = &#39;email&#39;
    DOMAIN = &#39;domain&#39;
    UPN = &#39;upn&#39;

    def __init__(self, username, password):
        super().__init__()
        if username.count(&#39;@&#39;) == 1:
            self.type = self.EMAIL
        elif username.count(&#39;\\&#39;) == 1:
            self.type = self.DOMAIN
        else:
            self.type = self.UPN
        self.username = username
        self.password = password

    def refresh(self, session):
        pass

    def __repr__(self):
        return self.__class__.__name__ + repr((self.username, &#39;********&#39;))

    def __str__(self):
        return self.username


class OAuth2Credentials(BaseCredentials):
    &#34;&#34;&#34;Login info for OAuth 2.0 client credentials authentication, as well as a base for other OAuth 2.0 grant types.

    This is primarily useful for in-house applications accessing data from a single Microsoft account. For applications
    that will access multiple tenants&#39; data, the client credentials flow does not give the application enough
    information to restrict end users&#39; access to the appropriate account. Use OAuth2AuthorizationCodeCredentials and
    the associated auth code grant type for multi-tenant applications.
    &#34;&#34;&#34;

    def __init__(self, client_id, client_secret, tenant_id=None, identity=None):
        &#34;&#34;&#34;

        :param client_id: ID of an authorized OAuth application, required for automatic token fetching and refreshing
        :param client_secret: Secret associated with the OAuth application
        :param tenant_id: Microsoft tenant ID of the account to access
        :param identity: An Identity object representing the account that these credentials are connected to.
        &#34;&#34;&#34;
        super().__init__()
        self.client_id = client_id
        self.client_secret = client_secret
        self.tenant_id = tenant_id
        self.identity = identity
        # When set, access_token is a dict (or an oauthlib.oauth2.OAuth2Token, which is also a dict)
        self.access_token = None

    def refresh(self, session):
        # Creating a new session gets a new access token, so there&#39;s no work here to refresh the credentials. This
        # implementation just makes sure we don&#39;t raise a NotImplementedError.
        pass

    def on_token_auto_refreshed(self, access_token):
        &#34;&#34;&#34;Set the access_token. Called after the access token is refreshed (requests-oauthlib can automatically
        refresh tokens if given an OAuth client ID and secret, so this is how our copy of the token stays up-to-date).
        Applications that cache access tokens can override this to store the new token - just remember to call the
        super() method.

        :param access_token: New token obtained by refreshing
        &#34;&#34;&#34;
        # Ensure we don&#39;t update the object in the middle of a new session being created, which could cause a race.
        if not isinstance(access_token, dict):
            raise ValueError(&#34;&#39;access_token&#39; must be an OAuth2Token&#34;)
        with self.lock:
            log.debug(&#39;%s auth token for %s&#39;, &#39;Refreshing&#39; if self.access_token else &#39;Setting&#39;, self.client_id)
            self.access_token = access_token

    def _get_hash_values(self):
        # &#39;access_token&#39; may be refreshed once in a while. This should not affect the hash signature.
        # &#39;identity&#39; is just informational and should also not affect the hash signature.
        return (getattr(self, k) for k in self.__dict__ if k not in (&#39;_lock&#39;, &#39;identity&#39;, &#39;access_token&#39;))

    def sig(self):
        # Like hash(self), but pulls in the access token. Protocol.refresh_credentials() uses this to find out
        # if the access_token needs to be refreshed.
        res = []
        for k in self.__dict__:
            if k in (&#39;_lock&#39;, &#39;identity&#39;):
                continue
            if k == &#39;access_token&#39;:
                res.append(self.access_token[&#39;access_token&#39;] if self.access_token else None)
                continue
            res.append(getattr(self, k))
        return hash(tuple(res))

    def __repr__(self):
        return self.__class__.__name__ + repr((self.client_id, &#39;********&#39;))

    def __str__(self):
        return self.client_id


class OAuth2AuthorizationCodeCredentials(OAuth2Credentials):
    &#34;&#34;&#34;Login info for OAuth 2.0 authentication using the authorization code grant type. This can be used in one of
    several ways:
    * Given an authorization code, client ID, and client secret, fetch a token ourselves and refresh it as needed if
      supplied with a refresh token.
    * Given an existing access token, refresh token, client ID, and client secret, use the access token until it
      expires and then refresh it as needed.
    * Given only an existing access token, use it until it expires. This can be used to let the calling application
      refresh tokens itself by subclassing and implementing refresh().

    Unlike the base (client credentials) grant, authorization code credentials don&#39;t require a Microsoft tenant ID
    because each access token (and the authorization code used to get the access token) is restricted to a single
    tenant.
    &#34;&#34;&#34;

    def __init__(self, authorization_code=None, access_token=None, **kwargs):
        &#34;&#34;&#34;

        :param client_id: ID of an authorized OAuth application, required for automatic token fetching and refreshing
        :param client_secret: Secret associated with the OAuth application
        :param tenant_id: Microsoft tenant ID of the account to access
        :param identity: An Identity object representing the account that these credentials are connected to.
        :param authorization_code: Code obtained when authorizing the application to access an account. In combination
          with client_id and client_secret, will be used to obtain an access token.
        :param access_token: Previously-obtained access token. If a token exists and the application will handle
          refreshing by itself (or opts not to handle it), this parameter alone is sufficient.
        &#34;&#34;&#34;
        super().__init__(**kwargs)
        self.authorization_code = authorization_code
        if access_token is not None and not isinstance(access_token, dict):
            raise ValueError(&#34;&#39;access_token&#39; must be an OAuth2Token&#34;)
        self.access_token = access_token

    def __repr__(self):
        return self.__class__.__name__ + repr(
            (self.client_id, &#39;[client_secret]&#39;, &#39;[authorization_code]&#39;, &#39;[access_token]&#39;)
        )

    def __str__(self):
        client_id = self.client_id
        credential = &#39;[access_token]&#39; if self.access_token is not None else \
            (&#39;[authorization_code]&#39; if self.authorization_code is not None else None)
        description = &#39; &#39;.join(filter(None, [client_id, credential]))
        return description or &#39;[underspecified credentials]&#39;</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="exchangelib.credentials.BaseCredentials"><code class="flex name class">
<span>class <span class="ident">BaseCredentials</span></span>
</code></dt>
<dd>
<div class="desc"><p>Base for credential storage.</p>
<p>Establishes a method for refreshing credentials (mostly useful with OAuth, which expires tokens relatively
frequently) and provides a lock for synchronizing access to the object around refreshes.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class BaseCredentials(metaclass=abc.ABCMeta):
    &#34;&#34;&#34;Base for credential storage.

    Establishes a method for refreshing credentials (mostly useful with OAuth, which expires tokens relatively
    frequently) and provides a lock for synchronizing access to the object around refreshes.
    &#34;&#34;&#34;

    def __init__(self):
        self._lock = RLock()

    @property
    def lock(self):
        return self._lock

    @abc.abstractmethod
    def refresh(self, session):
        &#34;&#34;&#34;Obtain a new set of valid credentials. This is mostly intended to support OAuth token refreshing, which can
        happen in long- running applications or those that cache access tokens and so might start with a token close to
        expiration.

        :param session: requests session asking for refreshed credentials
        :return:
        &#34;&#34;&#34;

    def _get_hash_values(self):
        return (getattr(self, k) for k in self.__dict__ if k != &#39;_lock&#39;)

    def __eq__(self, other):
        for k in self.__dict__:
            if k == &#39;_lock&#39;:
                continue
            if getattr(self, k) != getattr(other, k):
                return False
        return True

    def __hash__(self):
        return hash(tuple(self._get_hash_values()))

    def __getstate__(self):
        # The lock cannot be pickled
        state = self.__dict__.copy()
        del state[&#39;_lock&#39;]
        return state

    def __setstate__(self, state):
        # Restore the lock
        self.__dict__.update(state)
        self._lock = RLock()</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="exchangelib.credentials.Credentials" href="#exchangelib.credentials.Credentials">Credentials</a></li>
<li><a title="exchangelib.credentials.OAuth2Credentials" href="#exchangelib.credentials.OAuth2Credentials">OAuth2Credentials</a></li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="exchangelib.credentials.BaseCredentials.lock"><code class="name">var <span class="ident">lock</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def lock(self):
    return self._lock</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="exchangelib.credentials.BaseCredentials.refresh"><code class="name flex">
<span>def <span class="ident">refresh</span></span>(<span>self, session)</span>
</code></dt>
<dd>
<div class="desc"><p>Obtain a new set of valid credentials. This is mostly intended to support OAuth token refreshing, which can
happen in long- running applications or those that cache access tokens and so might start with a token close to
expiration.</p>
<p>:param session: requests session asking for refreshed credentials
:return:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@abc.abstractmethod
def refresh(self, session):
    &#34;&#34;&#34;Obtain a new set of valid credentials. This is mostly intended to support OAuth token refreshing, which can
    happen in long- running applications or those that cache access tokens and so might start with a token close to
    expiration.

    :param session: requests session asking for refreshed credentials
    :return:
    &#34;&#34;&#34;</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="exchangelib.credentials.Credentials"><code class="flex name class">
<span>class <span class="ident">Credentials</span></span>
<span>(</span><span>username, password)</span>
</code></dt>
<dd>
<div class="desc"><p>Keeps login info the way Exchange likes it.</p>
<p>Usernames for authentication are of one of these forms:
* PrimarySMTPAddress
* WINDOMAIN\username
* User Principal Name (UPN)
password: Clear-text password</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Credentials(BaseCredentials):
    r&#34;&#34;&#34;Keeps login info the way Exchange likes it.

    Usernames for authentication are of one of these forms:
    * PrimarySMTPAddress
    * WINDOMAIN\username
    * User Principal Name (UPN)
      password: Clear-text password
    &#34;&#34;&#34;

    EMAIL = &#39;email&#39;
    DOMAIN = &#39;domain&#39;
    UPN = &#39;upn&#39;

    def __init__(self, username, password):
        super().__init__()
        if username.count(&#39;@&#39;) == 1:
            self.type = self.EMAIL
        elif username.count(&#39;\\&#39;) == 1:
            self.type = self.DOMAIN
        else:
            self.type = self.UPN
        self.username = username
        self.password = password

    def refresh(self, session):
        pass

    def __repr__(self):
        return self.__class__.__name__ + repr((self.username, &#39;********&#39;))

    def __str__(self):
        return self.username</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="exchangelib.credentials.BaseCredentials" href="#exchangelib.credentials.BaseCredentials">BaseCredentials</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="exchangelib.credentials.Credentials.DOMAIN"><code class="name">var <span class="ident">DOMAIN</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.credentials.Credentials.EMAIL"><code class="name">var <span class="ident">EMAIL</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.credentials.Credentials.UPN"><code class="name">var <span class="ident">UPN</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="exchangelib.credentials.BaseCredentials" href="#exchangelib.credentials.BaseCredentials">BaseCredentials</a></b></code>:
<ul class="hlist">
<li><code><a title="exchangelib.credentials.BaseCredentials.refresh" href="#exchangelib.credentials.BaseCredentials.refresh">refresh</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="exchangelib.credentials.OAuth2AuthorizationCodeCredentials"><code class="flex name class">
<span>class <span class="ident">OAuth2AuthorizationCodeCredentials</span></span>
<span>(</span><span>authorization_code=None, access_token=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Login info for OAuth 2.0 authentication using the authorization code grant type. This can be used in one of
several ways:
* Given an authorization code, client ID, and client secret, fetch a token ourselves and refresh it as needed if
supplied with a refresh token.
* Given an existing access token, refresh token, client ID, and client secret, use the access token until it
expires and then refresh it as needed.
* Given only an existing access token, use it until it expires. This can be used to let the calling application
refresh tokens itself by subclassing and implementing refresh().</p>
<p>Unlike the base (client credentials) grant, authorization code credentials don't require a Microsoft tenant ID
because each access token (and the authorization code used to get the access token) is restricted to a single
tenant.</p>
<p>:param client_id: ID of an authorized OAuth application, required for automatic token fetching and refreshing
:param client_secret: Secret associated with the OAuth application
:param tenant_id: Microsoft tenant ID of the account to access
:param identity: An Identity object representing the account that these credentials are connected to.
:param authorization_code: Code obtained when authorizing the application to access an account. In combination
with client_id and client_secret, will be used to obtain an access token.
:param access_token: Previously-obtained access token. If a token exists and the application will handle
refreshing by itself (or opts not to handle it), this parameter alone is sufficient.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class OAuth2AuthorizationCodeCredentials(OAuth2Credentials):
    &#34;&#34;&#34;Login info for OAuth 2.0 authentication using the authorization code grant type. This can be used in one of
    several ways:
    * Given an authorization code, client ID, and client secret, fetch a token ourselves and refresh it as needed if
      supplied with a refresh token.
    * Given an existing access token, refresh token, client ID, and client secret, use the access token until it
      expires and then refresh it as needed.
    * Given only an existing access token, use it until it expires. This can be used to let the calling application
      refresh tokens itself by subclassing and implementing refresh().

    Unlike the base (client credentials) grant, authorization code credentials don&#39;t require a Microsoft tenant ID
    because each access token (and the authorization code used to get the access token) is restricted to a single
    tenant.
    &#34;&#34;&#34;

    def __init__(self, authorization_code=None, access_token=None, **kwargs):
        &#34;&#34;&#34;

        :param client_id: ID of an authorized OAuth application, required for automatic token fetching and refreshing
        :param client_secret: Secret associated with the OAuth application
        :param tenant_id: Microsoft tenant ID of the account to access
        :param identity: An Identity object representing the account that these credentials are connected to.
        :param authorization_code: Code obtained when authorizing the application to access an account. In combination
          with client_id and client_secret, will be used to obtain an access token.
        :param access_token: Previously-obtained access token. If a token exists and the application will handle
          refreshing by itself (or opts not to handle it), this parameter alone is sufficient.
        &#34;&#34;&#34;
        super().__init__(**kwargs)
        self.authorization_code = authorization_code
        if access_token is not None and not isinstance(access_token, dict):
            raise ValueError(&#34;&#39;access_token&#39; must be an OAuth2Token&#34;)
        self.access_token = access_token

    def __repr__(self):
        return self.__class__.__name__ + repr(
            (self.client_id, &#39;[client_secret]&#39;, &#39;[authorization_code]&#39;, &#39;[access_token]&#39;)
        )

    def __str__(self):
        client_id = self.client_id
        credential = &#39;[access_token]&#39; if self.access_token is not None else \
            (&#39;[authorization_code]&#39; if self.authorization_code is not None else None)
        description = &#39; &#39;.join(filter(None, [client_id, credential]))
        return description or &#39;[underspecified credentials]&#39;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="exchangelib.credentials.OAuth2Credentials" href="#exchangelib.credentials.OAuth2Credentials">OAuth2Credentials</a></li>
<li><a title="exchangelib.credentials.BaseCredentials" href="#exchangelib.credentials.BaseCredentials">BaseCredentials</a></li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="exchangelib.credentials.OAuth2Credentials" href="#exchangelib.credentials.OAuth2Credentials">OAuth2Credentials</a></b></code>:
<ul class="hlist">
<li><code><a title="exchangelib.credentials.OAuth2Credentials.on_token_auto_refreshed" href="#exchangelib.credentials.OAuth2Credentials.on_token_auto_refreshed">on_token_auto_refreshed</a></code></li>
<li><code><a title="exchangelib.credentials.OAuth2Credentials.refresh" href="#exchangelib.credentials.BaseCredentials.refresh">refresh</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="exchangelib.credentials.OAuth2Credentials"><code class="flex name class">
<span>class <span class="ident">OAuth2Credentials</span></span>
<span>(</span><span>client_id, client_secret, tenant_id=None, identity=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Login info for OAuth 2.0 client credentials authentication, as well as a base for other OAuth 2.0 grant types.</p>
<p>This is primarily useful for in-house applications accessing data from a single Microsoft account. For applications
that will access multiple tenants' data, the client credentials flow does not give the application enough
information to restrict end users' access to the appropriate account. Use OAuth2AuthorizationCodeCredentials and
the associated auth code grant type for multi-tenant applications.</p>
<p>:param client_id: ID of an authorized OAuth application, required for automatic token fetching and refreshing
:param client_secret: Secret associated with the OAuth application
:param tenant_id: Microsoft tenant ID of the account to access
:param identity: An Identity object representing the account that these credentials are connected to.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class OAuth2Credentials(BaseCredentials):
    &#34;&#34;&#34;Login info for OAuth 2.0 client credentials authentication, as well as a base for other OAuth 2.0 grant types.

    This is primarily useful for in-house applications accessing data from a single Microsoft account. For applications
    that will access multiple tenants&#39; data, the client credentials flow does not give the application enough
    information to restrict end users&#39; access to the appropriate account. Use OAuth2AuthorizationCodeCredentials and
    the associated auth code grant type for multi-tenant applications.
    &#34;&#34;&#34;

    def __init__(self, client_id, client_secret, tenant_id=None, identity=None):
        &#34;&#34;&#34;

        :param client_id: ID of an authorized OAuth application, required for automatic token fetching and refreshing
        :param client_secret: Secret associated with the OAuth application
        :param tenant_id: Microsoft tenant ID of the account to access
        :param identity: An Identity object representing the account that these credentials are connected to.
        &#34;&#34;&#34;
        super().__init__()
        self.client_id = client_id
        self.client_secret = client_secret
        self.tenant_id = tenant_id
        self.identity = identity
        # When set, access_token is a dict (or an oauthlib.oauth2.OAuth2Token, which is also a dict)
        self.access_token = None

    def refresh(self, session):
        # Creating a new session gets a new access token, so there&#39;s no work here to refresh the credentials. This
        # implementation just makes sure we don&#39;t raise a NotImplementedError.
        pass

    def on_token_auto_refreshed(self, access_token):
        &#34;&#34;&#34;Set the access_token. Called after the access token is refreshed (requests-oauthlib can automatically
        refresh tokens if given an OAuth client ID and secret, so this is how our copy of the token stays up-to-date).
        Applications that cache access tokens can override this to store the new token - just remember to call the
        super() method.

        :param access_token: New token obtained by refreshing
        &#34;&#34;&#34;
        # Ensure we don&#39;t update the object in the middle of a new session being created, which could cause a race.
        if not isinstance(access_token, dict):
            raise ValueError(&#34;&#39;access_token&#39; must be an OAuth2Token&#34;)
        with self.lock:
            log.debug(&#39;%s auth token for %s&#39;, &#39;Refreshing&#39; if self.access_token else &#39;Setting&#39;, self.client_id)
            self.access_token = access_token

    def _get_hash_values(self):
        # &#39;access_token&#39; may be refreshed once in a while. This should not affect the hash signature.
        # &#39;identity&#39; is just informational and should also not affect the hash signature.
        return (getattr(self, k) for k in self.__dict__ if k not in (&#39;_lock&#39;, &#39;identity&#39;, &#39;access_token&#39;))

    def sig(self):
        # Like hash(self), but pulls in the access token. Protocol.refresh_credentials() uses this to find out
        # if the access_token needs to be refreshed.
        res = []
        for k in self.__dict__:
            if k in (&#39;_lock&#39;, &#39;identity&#39;):
                continue
            if k == &#39;access_token&#39;:
                res.append(self.access_token[&#39;access_token&#39;] if self.access_token else None)
                continue
            res.append(getattr(self, k))
        return hash(tuple(res))

    def __repr__(self):
        return self.__class__.__name__ + repr((self.client_id, &#39;********&#39;))

    def __str__(self):
        return self.client_id</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="exchangelib.credentials.BaseCredentials" href="#exchangelib.credentials.BaseCredentials">BaseCredentials</a></li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="exchangelib.credentials.OAuth2AuthorizationCodeCredentials" href="#exchangelib.credentials.OAuth2AuthorizationCodeCredentials">OAuth2AuthorizationCodeCredentials</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="exchangelib.credentials.OAuth2Credentials.on_token_auto_refreshed"><code class="name flex">
<span>def <span class="ident">on_token_auto_refreshed</span></span>(<span>self, access_token)</span>
</code></dt>
<dd>
<div class="desc"><p>Set the access_token. Called after the access token is refreshed (requests-oauthlib can automatically
refresh tokens if given an OAuth client ID and secret, so this is how our copy of the token stays up-to-date).
Applications that cache access tokens can override this to store the new token - just remember to call the
super() method.</p>
<p>:param access_token: New token obtained by refreshing</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def on_token_auto_refreshed(self, access_token):
    &#34;&#34;&#34;Set the access_token. Called after the access token is refreshed (requests-oauthlib can automatically
    refresh tokens if given an OAuth client ID and secret, so this is how our copy of the token stays up-to-date).
    Applications that cache access tokens can override this to store the new token - just remember to call the
    super() method.

    :param access_token: New token obtained by refreshing
    &#34;&#34;&#34;
    # Ensure we don&#39;t update the object in the middle of a new session being created, which could cause a race.
    if not isinstance(access_token, dict):
        raise ValueError(&#34;&#39;access_token&#39; must be an OAuth2Token&#34;)
    with self.lock:
        log.debug(&#39;%s auth token for %s&#39;, &#39;Refreshing&#39; if self.access_token else &#39;Setting&#39;, self.client_id)
        self.access_token = access_token</code></pre>
</details>
</dd>
<dt id="exchangelib.credentials.OAuth2Credentials.sig"><code class="name flex">
<span>def <span class="ident">sig</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def sig(self):
    # Like hash(self), but pulls in the access token. Protocol.refresh_credentials() uses this to find out
    # if the access_token needs to be refreshed.
    res = []
    for k in self.__dict__:
        if k in (&#39;_lock&#39;, &#39;identity&#39;):
            continue
        if k == &#39;access_token&#39;:
            res.append(self.access_token[&#39;access_token&#39;] if self.access_token else None)
            continue
        res.append(getattr(self, k))
    return hash(tuple(res))</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="exchangelib.credentials.BaseCredentials" href="#exchangelib.credentials.BaseCredentials">BaseCredentials</a></b></code>:
<ul class="hlist">
<li><code><a title="exchangelib.credentials.BaseCredentials.refresh" href="#exchangelib.credentials.BaseCredentials.refresh">refresh</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="exchangelib" href="index.html">exchangelib</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="exchangelib.credentials.BaseCredentials" href="#exchangelib.credentials.BaseCredentials">BaseCredentials</a></code></h4>
<ul class="">
<li><code><a title="exchangelib.credentials.BaseCredentials.lock" href="#exchangelib.credentials.BaseCredentials.lock">lock</a></code></li>
<li><code><a title="exchangelib.credentials.BaseCredentials.refresh" href="#exchangelib.credentials.BaseCredentials.refresh">refresh</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="exchangelib.credentials.Credentials" href="#exchangelib.credentials.Credentials">Credentials</a></code></h4>
<ul class="">
<li><code><a title="exchangelib.credentials.Credentials.DOMAIN" href="#exchangelib.credentials.Credentials.DOMAIN">DOMAIN</a></code></li>
<li><code><a title="exchangelib.credentials.Credentials.EMAIL" href="#exchangelib.credentials.Credentials.EMAIL">EMAIL</a></code></li>
<li><code><a title="exchangelib.credentials.Credentials.UPN" href="#exchangelib.credentials.Credentials.UPN">UPN</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="exchangelib.credentials.OAuth2AuthorizationCodeCredentials" href="#exchangelib.credentials.OAuth2AuthorizationCodeCredentials">OAuth2AuthorizationCodeCredentials</a></code></h4>
</li>
<li>
<h4><code><a title="exchangelib.credentials.OAuth2Credentials" href="#exchangelib.credentials.OAuth2Credentials">OAuth2Credentials</a></code></h4>
<ul class="">
<li><code><a title="exchangelib.credentials.OAuth2Credentials.on_token_auto_refreshed" href="#exchangelib.credentials.OAuth2Credentials.on_token_auto_refreshed">on_token_auto_refreshed</a></code></li>
<li><code><a title="exchangelib.credentials.OAuth2Credentials.sig" href="#exchangelib.credentials.OAuth2Credentials.sig">sig</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>