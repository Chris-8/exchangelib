<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.8.3" />
<title>exchangelib.items.item API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.18.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.18.1/highlight.min.js" integrity="sha256-eOgo0OtLL4cdq7RdwRUiGKLX9XsIJ7nGhWEKbohmVAQ=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>exchangelib.items.item</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import logging

from ..fields import BooleanField, IntegerField, TextField, CharListField, ChoiceField, URIField, BodyField, \
    DateTimeField, MessageHeaderField, AttachmentField, Choice, EWSElementField, EffectiveRightsField, CultureField, \
    CharField, MimeContentField, FieldPath
from ..properties import ConversationId, ParentFolderId, ReferenceItemId, OccurrenceItemId, RecurringMasterItemId,\
    Fields
from ..services import GetItem, CreateItem, UpdateItem, DeleteItem, MoveItem, CopyItem, ArchiveItem
from ..util import is_iterable, require_account, require_id
from ..version import EXCHANGE_2010, EXCHANGE_2013
from .base import BaseItem, BulkCreateResult, SAVE_ONLY, SEND_ONLY, SEND_AND_SAVE_COPY, ID_ONLY, SEND_TO_NONE, \
    AUTO_RESOLVE, SOFT_DELETE, HARD_DELETE, ALL_OCCURRENCIES, MOVE_TO_DELETED_ITEMS

log = logging.getLogger(__name__)


class Item(BaseItem):
    &#34;&#34;&#34;MSDN: https://docs.microsoft.com/en-us/exchange/client-developer/web-service-reference/item&#34;&#34;&#34;
    ELEMENT_NAME = &#39;Item&#39;

    LOCAL_FIELDS = Fields(
        MimeContentField(&#39;mime_content&#39;, field_uri=&#39;item:MimeContent&#39;, is_read_only_after_send=True),
        EWSElementField(&#39;parent_folder_id&#39;, field_uri=&#39;item:ParentFolderId&#39;, value_cls=ParentFolderId,
                        is_read_only=True),
        CharField(&#39;item_class&#39;, field_uri=&#39;item:ItemClass&#39;, is_read_only=True),
        CharField(&#39;subject&#39;, field_uri=&#39;item:Subject&#39;),
        ChoiceField(&#39;sensitivity&#39;, field_uri=&#39;item:Sensitivity&#39;, choices={
            Choice(&#39;Normal&#39;), Choice(&#39;Personal&#39;), Choice(&#39;Private&#39;), Choice(&#39;Confidential&#39;)
        }, is_required=True, default=&#39;Normal&#39;),
        TextField(&#39;text_body&#39;, field_uri=&#39;item:TextBody&#39;, is_read_only=True, supported_from=EXCHANGE_2013),
        BodyField(&#39;body&#39;, field_uri=&#39;item:Body&#39;),  # Accepts and returns Body or HTMLBody instances
        AttachmentField(&#39;attachments&#39;, field_uri=&#39;item:Attachments&#39;),  # ItemAttachment or FileAttachment
        DateTimeField(&#39;datetime_received&#39;, field_uri=&#39;item:DateTimeReceived&#39;, is_read_only=True),
        IntegerField(&#39;size&#39;, field_uri=&#39;item:Size&#39;, is_read_only=True),  # Item size in bytes
        CharListField(&#39;categories&#39;, field_uri=&#39;item:Categories&#39;),
        ChoiceField(&#39;importance&#39;, field_uri=&#39;item:Importance&#39;, choices={
            Choice(&#39;Low&#39;), Choice(&#39;Normal&#39;), Choice(&#39;High&#39;)
        }, is_required=True, default=&#39;Normal&#39;),
        TextField(&#39;in_reply_to&#39;, field_uri=&#39;item:InReplyTo&#39;),
        BooleanField(&#39;is_submitted&#39;, field_uri=&#39;item:IsSubmitted&#39;, is_read_only=True),
        BooleanField(&#39;is_draft&#39;, field_uri=&#39;item:IsDraft&#39;, is_read_only=True),
        BooleanField(&#39;is_from_me&#39;, field_uri=&#39;item:IsFromMe&#39;, is_read_only=True),
        BooleanField(&#39;is_resend&#39;, field_uri=&#39;item:IsResend&#39;, is_read_only=True),
        BooleanField(&#39;is_unmodified&#39;, field_uri=&#39;item:IsUnmodified&#39;, is_read_only=True),
        MessageHeaderField(&#39;headers&#39;, field_uri=&#39;item:InternetMessageHeaders&#39;, is_read_only=True),
        DateTimeField(&#39;datetime_sent&#39;, field_uri=&#39;item:DateTimeSent&#39;, is_read_only=True),
        DateTimeField(&#39;datetime_created&#39;, field_uri=&#39;item:DateTimeCreated&#39;, is_read_only=True),
        # Placeholder for ResponseObjects
        DateTimeField(&#39;reminder_due_by&#39;, field_uri=&#39;item:ReminderDueBy&#39;, is_required_after_save=True,
                      is_searchable=False),
        BooleanField(&#39;reminder_is_set&#39;, field_uri=&#39;item:ReminderIsSet&#39;, is_required=True, default=False),
        IntegerField(&#39;reminder_minutes_before_start&#39;, field_uri=&#39;item:ReminderMinutesBeforeStart&#39;,
                     is_required_after_save=True, min=0, default=0),
        TextField(&#39;display_cc&#39;, field_uri=&#39;item:DisplayCc&#39;, is_read_only=True),
        TextField(&#39;display_to&#39;, field_uri=&#39;item:DisplayTo&#39;, is_read_only=True),
        BooleanField(&#39;has_attachments&#39;, field_uri=&#39;item:HasAttachments&#39;, is_read_only=True),
        # ExtendedProperty fields go here
        CultureField(&#39;culture&#39;, field_uri=&#39;item:Culture&#39;, is_required_after_save=True, is_searchable=False),
        EffectiveRightsField(&#39;effective_rights&#39;, field_uri=&#39;item:EffectiveRights&#39;, is_read_only=True),
        CharField(&#39;last_modified_name&#39;, field_uri=&#39;item:LastModifiedName&#39;, is_read_only=True),
        DateTimeField(&#39;last_modified_time&#39;, field_uri=&#39;item:LastModifiedTime&#39;, is_read_only=True),
        BooleanField(&#39;is_associated&#39;, field_uri=&#39;item:IsAssociated&#39;, is_read_only=True, supported_from=EXCHANGE_2010),
        URIField(&#39;web_client_read_form_query_string&#39;, field_uri=&#39;item:WebClientReadFormQueryString&#39;,
                 is_read_only=True, supported_from=EXCHANGE_2010),
        URIField(&#39;web_client_edit_form_query_string&#39;, field_uri=&#39;item:WebClientEditFormQueryString&#39;,
                 is_read_only=True, supported_from=EXCHANGE_2010),
        EWSElementField(&#39;conversation_id&#39;, field_uri=&#39;item:ConversationId&#39;, value_cls=ConversationId,
                        is_read_only=True, supported_from=EXCHANGE_2010),
        BodyField(&#39;unique_body&#39;, field_uri=&#39;item:UniqueBody&#39;, is_read_only=True, supported_from=EXCHANGE_2010),
    )
    FIELDS = LOCAL_FIELDS[0:1] + BaseItem.FIELDS + LOCAL_FIELDS[1:]

    __slots__ = tuple(f.name for f in LOCAL_FIELDS)

    # Used to register extended properties
    INSERT_AFTER_FIELD = &#39;has_attachments&#39;

    def __init__(self, **kwargs):
        super().__init__(**kwargs)
        # pylint: disable=access-member-before-definition
        if self.attachments:
            for a in self.attachments:
                if a.parent_item:
                    if a.parent_item is not self:
                        raise ValueError(&#34;&#39;parent_item&#39; of attachment %s must point to this item&#34; % a)
                else:
                    a.parent_item = self
                self.attach(self.attachments)
        else:
            self.attachments = []

    def save(self, update_fields=None, conflict_resolution=AUTO_RESOLVE, send_meeting_invitations=SEND_TO_NONE):
        if self.id:
            item_id, changekey = self._update(
                update_fieldnames=update_fields,
                message_disposition=SAVE_ONLY,
                conflict_resolution=conflict_resolution,
                send_meeting_invitations=send_meeting_invitations
            )
            if self.id != item_id and not isinstance(self._id, (OccurrenceItemId, RecurringMasterItemId)):
                # When we update an item with an OccurrenceItemId as ID, EWS returns the ID of the occurrence, so
                # the ID of this item changes.
                raise ValueError(&#34;&#39;id&#39; mismatch in returned update response&#34;)
            # Don&#39;t check that changekeys are different. No-op saves will sometimes leave the changekey intact
            self._id = self.ID_ELEMENT_CLS(item_id, changekey)
        else:
            if update_fields:
                raise ValueError(&#34;&#39;update_fields&#39; is only valid for updates&#34;)
            tmp_attachments = None
            if self.account and self.account.version.build &lt; EXCHANGE_2013 and self.attachments:
                # At least some versions prior to Exchange 2013 can&#39;t save attachments immediately. You need to first
                # save, then attach. Store the attachment of this item temporarily and attach later.
                tmp_attachments, self.attachments = self.attachments, []
            item = self._create(message_disposition=SAVE_ONLY, send_meeting_invitations=send_meeting_invitations)
            self._id = self.ID_ELEMENT_CLS(item.id, item.changekey)
            for old_att, new_att in zip(self.attachments, item.attachments):
                if old_att.attachment_id is not None:
                    raise ValueError(&#34;Old &#39;attachment_id&#39; is not empty&#34;)
                if new_att.attachment_id is None:
                    raise ValueError(&#34;New &#39;attachment_id&#39; is empty&#34;)
                old_att.attachment_id = new_att.attachment_id
            if tmp_attachments:
                # Exchange 2007 workaround. See above
                self.attach(tmp_attachments)
        return self

    @require_account
    def _create(self, message_disposition, send_meeting_invitations):
        # Return a BulkCreateResult because we want to return the ID of both the main item *and* attachments
        res = CreateItem(account=self.account).get(
            items=[self],
            folder=self.folder,
            message_disposition=message_disposition,
            send_meeting_invitations=send_meeting_invitations,
            expect_result=message_disposition not in (SEND_ONLY, SEND_AND_SAVE_COPY),
        )
        if res is None:
            return
        return BulkCreateResult.from_xml(elem=res, account=self)

    def _update_fieldnames(self):
        from .contact import Contact, DistributionList
        # Return the list of fields we are allowed to update
        update_fieldnames = []
        for f in self.supported_fields(version=self.account.version):
            if f.name == &#39;attachments&#39;:
                # Attachments are handled separately after item creation
                continue
            if f.is_read_only:
                # These cannot be changed
                continue
            if f.is_required or f.is_required_after_save:
                if getattr(self, f.name) is None or (f.is_list and not getattr(self, f.name)):
                    # These are required and cannot be deleted
                    continue
            if not self.is_draft and f.is_read_only_after_send:
                # These cannot be changed when the item is no longer a draft
                continue
            if f.name == &#39;message_id&#39; and f.is_read_only_after_send:
                # &#39;message_id&#39; doesn&#39;t support updating, no matter the draft status
                continue
            if f.name == &#39;mime_content&#39; and isinstance(self, (Contact, DistributionList)):
                # Contact and DistributionList don&#39;t support updating mime_content, no matter the draft status
                continue
            update_fieldnames.append(f.name)
        return update_fieldnames

    @require_account
    def _update(self, update_fieldnames, message_disposition, conflict_resolution, send_meeting_invitations):
        if not self.changekey:
            raise ValueError(&#39;%s must have changekey&#39; % self.__class__.__name__)
        if not update_fieldnames:
            # The fields to update was not specified explicitly. Update all fields where update is possible
            update_fieldnames = self._update_fieldnames()
        res = UpdateItem(account=self.account).get(
            items=[(self, update_fieldnames)],
            message_disposition=message_disposition,
            conflict_resolution=conflict_resolution,
            send_meeting_invitations_or_cancellations=send_meeting_invitations,
            suppress_read_receipts=True,
            expect_result=message_disposition != SEND_AND_SAVE_COPY,
        )
        if res is None:
            return
        return Item.id_from_xml(res)

    @require_id
    def refresh(self):
        # Updates the item based on fresh data from EWS
        from ..folders import Folder
        additional_fields = {
            FieldPath(field=f) for f in Folder(root=self.account.root).allowed_item_fields(version=self.account.version)
        }

        elem = GetItem(account=self.account).get(items=[self], additional_fields=additional_fields, shape=ID_ONLY)
        res = Folder.item_model_from_tag(elem.tag).from_xml(elem=elem, account=self.account)
        if self.id != res.id and not isinstance(self._id, (OccurrenceItemId, RecurringMasterItemId)):
            # When we refresh an item with an OccurrenceItemId as ID, EWS returns the ID of the occurrence, so
            # the ID of this item changes.
            raise ValueError(&#34;&#39;id&#39; mismatch in returned update response&#34;)
        for f in self.FIELDS:
            setattr(self, f.name, getattr(res, f.name))
        # &#39;parent_item&#39; should point to &#39;self&#39;, not &#39;fresh_item&#39;. That way, &#39;fresh_item&#39; can be garbage collected.
        for a in self.attachments:
            a.parent_item = self
        del res

    @require_id
    def copy(self, to_folder):
        res = CopyItem(account=self.account).get(
            items=[self],
            to_folder=to_folder,
            expect_result=None,
        )
        if res is None:
            # Assume &#39;to_folder&#39; is a public folder or a folder in a different mailbox
            return
        return Item.id_from_xml(res)

    @require_id
    def move(self, to_folder):
        res = MoveItem(account=self.account).get(
            items=[self],
            to_folder=to_folder,
            expect_result=None,
        )
        if res is None:
            # Assume &#39;to_folder&#39; is a public folder or a folder in a different mailbox
            self._id = None
            return
        self._id = self.ID_ELEMENT_CLS(*Item.id_from_xml(res))
        self.folder = to_folder

    def move_to_trash(self, send_meeting_cancellations=SEND_TO_NONE, affected_task_occurrences=ALL_OCCURRENCIES,
                      suppress_read_receipts=True):
        # Delete and move to the trash folder.
        self._delete(delete_type=MOVE_TO_DELETED_ITEMS, send_meeting_cancellations=send_meeting_cancellations,
                     affected_task_occurrences=affected_task_occurrences, suppress_read_receipts=suppress_read_receipts)
        self._id = None
        self.folder = self.account.trash

    def soft_delete(self, send_meeting_cancellations=SEND_TO_NONE, affected_task_occurrences=ALL_OCCURRENCIES,
                    suppress_read_receipts=True):
        # Delete and move to the dumpster, if it is enabled.
        self._delete(delete_type=SOFT_DELETE, send_meeting_cancellations=send_meeting_cancellations,
                     affected_task_occurrences=affected_task_occurrences, suppress_read_receipts=suppress_read_receipts)
        self._id = None
        self.folder = self.account.recoverable_items_deletions

    def delete(self, send_meeting_cancellations=SEND_TO_NONE, affected_task_occurrences=ALL_OCCURRENCIES,
               suppress_read_receipts=True):
        # Remove the item permanently. No copies are stored anywhere.
        self._delete(delete_type=HARD_DELETE, send_meeting_cancellations=send_meeting_cancellations,
                     affected_task_occurrences=affected_task_occurrences, suppress_read_receipts=suppress_read_receipts)
        self._id, self.folder = None, None

    @require_id
    def _delete(self, delete_type, send_meeting_cancellations, affected_task_occurrences, suppress_read_receipts):
        DeleteItem(account=self.account).get(
            items=[self],
            delete_type=delete_type,
            send_meeting_cancellations=send_meeting_cancellations,
            affected_task_occurrences=affected_task_occurrences,
            suppress_read_receipts=suppress_read_receipts,
        )

    @require_id
    def archive(self, to_folder):
        return ArchiveItem(account=self.account).get(items=[self], to_folder=to_folder)

    def attach(self, attachments):
        &#34;&#34;&#34;Add an attachment, or a list of attachments, to this item. If the item has already been saved, the
        attachments will be created on the server immediately. If the item has not yet been saved, the attachments will
        be created on the server when the item is saved.

        Adding attachments to an existing item will update the changekey of the item.

        Args:
          attachments:

        &#34;&#34;&#34;
        if not is_iterable(attachments, generators_allowed=True):
            attachments = [attachments]
        for a in attachments:
            if not a.parent_item:
                a.parent_item = self
            if self.id and not a.attachment_id:
                # Already saved object. Attach the attachment server-side now
                a.attach()
            if a not in self.attachments:
                self.attachments.append(a)

    def detach(self, attachments):
        &#34;&#34;&#34;Remove an attachment, or a list of attachments, from this item. If the item has already been saved, the
        attachments will be deleted on the server immediately. If the item has not yet been saved, the attachments will
        simply not be created on the server the item is saved.

        Removing attachments from an existing item will update the changekey of the item.

        Args:
          attachments:

        &#34;&#34;&#34;
        if not is_iterable(attachments, generators_allowed=True):
            attachments = [attachments]
        if attachments is self.attachments:
            # Don&#39;t remove from the same list we are iterating
            attachments = list(attachments)
        for a in attachments:
            if a.parent_item is not self:
                raise ValueError(&#39;Attachment does not belong to this item&#39;)
            if self.id:
                # Item is already created. Detach  the attachment server-side now
                a.detach()
            if a in self.attachments:
                self.attachments.remove(a)

    @require_id
    def create_forward(self, subject, body, to_recipients, cc_recipients=None, bcc_recipients=None):
        from .message import ForwardItem
        return ForwardItem(
            account=self.account,
            reference_item_id=ReferenceItemId(id=self.id, changekey=self.changekey),
            subject=subject,
            new_body=body,
            to_recipients=to_recipients,
            cc_recipients=cc_recipients,
            bcc_recipients=bcc_recipients,
        )

    def forward(self, subject, body, to_recipients, cc_recipients=None, bcc_recipients=None):
        self.create_forward(
            subject,
            body,
            to_recipients,
            cc_recipients,
            bcc_recipients,
        ).send()</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="exchangelib.items.item.Item"><code class="flex name class">
<span>class <span class="ident">Item</span></span>
<span>(</span><span>**kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>MSDN: <a href="https://docs.microsoft.com/en-us/exchange/client-developer/web-service-reference/item">https://docs.microsoft.com/en-us/exchange/client-developer/web-service-reference/item</a></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Item(BaseItem):
    &#34;&#34;&#34;MSDN: https://docs.microsoft.com/en-us/exchange/client-developer/web-service-reference/item&#34;&#34;&#34;
    ELEMENT_NAME = &#39;Item&#39;

    LOCAL_FIELDS = Fields(
        MimeContentField(&#39;mime_content&#39;, field_uri=&#39;item:MimeContent&#39;, is_read_only_after_send=True),
        EWSElementField(&#39;parent_folder_id&#39;, field_uri=&#39;item:ParentFolderId&#39;, value_cls=ParentFolderId,
                        is_read_only=True),
        CharField(&#39;item_class&#39;, field_uri=&#39;item:ItemClass&#39;, is_read_only=True),
        CharField(&#39;subject&#39;, field_uri=&#39;item:Subject&#39;),
        ChoiceField(&#39;sensitivity&#39;, field_uri=&#39;item:Sensitivity&#39;, choices={
            Choice(&#39;Normal&#39;), Choice(&#39;Personal&#39;), Choice(&#39;Private&#39;), Choice(&#39;Confidential&#39;)
        }, is_required=True, default=&#39;Normal&#39;),
        TextField(&#39;text_body&#39;, field_uri=&#39;item:TextBody&#39;, is_read_only=True, supported_from=EXCHANGE_2013),
        BodyField(&#39;body&#39;, field_uri=&#39;item:Body&#39;),  # Accepts and returns Body or HTMLBody instances
        AttachmentField(&#39;attachments&#39;, field_uri=&#39;item:Attachments&#39;),  # ItemAttachment or FileAttachment
        DateTimeField(&#39;datetime_received&#39;, field_uri=&#39;item:DateTimeReceived&#39;, is_read_only=True),
        IntegerField(&#39;size&#39;, field_uri=&#39;item:Size&#39;, is_read_only=True),  # Item size in bytes
        CharListField(&#39;categories&#39;, field_uri=&#39;item:Categories&#39;),
        ChoiceField(&#39;importance&#39;, field_uri=&#39;item:Importance&#39;, choices={
            Choice(&#39;Low&#39;), Choice(&#39;Normal&#39;), Choice(&#39;High&#39;)
        }, is_required=True, default=&#39;Normal&#39;),
        TextField(&#39;in_reply_to&#39;, field_uri=&#39;item:InReplyTo&#39;),
        BooleanField(&#39;is_submitted&#39;, field_uri=&#39;item:IsSubmitted&#39;, is_read_only=True),
        BooleanField(&#39;is_draft&#39;, field_uri=&#39;item:IsDraft&#39;, is_read_only=True),
        BooleanField(&#39;is_from_me&#39;, field_uri=&#39;item:IsFromMe&#39;, is_read_only=True),
        BooleanField(&#39;is_resend&#39;, field_uri=&#39;item:IsResend&#39;, is_read_only=True),
        BooleanField(&#39;is_unmodified&#39;, field_uri=&#39;item:IsUnmodified&#39;, is_read_only=True),
        MessageHeaderField(&#39;headers&#39;, field_uri=&#39;item:InternetMessageHeaders&#39;, is_read_only=True),
        DateTimeField(&#39;datetime_sent&#39;, field_uri=&#39;item:DateTimeSent&#39;, is_read_only=True),
        DateTimeField(&#39;datetime_created&#39;, field_uri=&#39;item:DateTimeCreated&#39;, is_read_only=True),
        # Placeholder for ResponseObjects
        DateTimeField(&#39;reminder_due_by&#39;, field_uri=&#39;item:ReminderDueBy&#39;, is_required_after_save=True,
                      is_searchable=False),
        BooleanField(&#39;reminder_is_set&#39;, field_uri=&#39;item:ReminderIsSet&#39;, is_required=True, default=False),
        IntegerField(&#39;reminder_minutes_before_start&#39;, field_uri=&#39;item:ReminderMinutesBeforeStart&#39;,
                     is_required_after_save=True, min=0, default=0),
        TextField(&#39;display_cc&#39;, field_uri=&#39;item:DisplayCc&#39;, is_read_only=True),
        TextField(&#39;display_to&#39;, field_uri=&#39;item:DisplayTo&#39;, is_read_only=True),
        BooleanField(&#39;has_attachments&#39;, field_uri=&#39;item:HasAttachments&#39;, is_read_only=True),
        # ExtendedProperty fields go here
        CultureField(&#39;culture&#39;, field_uri=&#39;item:Culture&#39;, is_required_after_save=True, is_searchable=False),
        EffectiveRightsField(&#39;effective_rights&#39;, field_uri=&#39;item:EffectiveRights&#39;, is_read_only=True),
        CharField(&#39;last_modified_name&#39;, field_uri=&#39;item:LastModifiedName&#39;, is_read_only=True),
        DateTimeField(&#39;last_modified_time&#39;, field_uri=&#39;item:LastModifiedTime&#39;, is_read_only=True),
        BooleanField(&#39;is_associated&#39;, field_uri=&#39;item:IsAssociated&#39;, is_read_only=True, supported_from=EXCHANGE_2010),
        URIField(&#39;web_client_read_form_query_string&#39;, field_uri=&#39;item:WebClientReadFormQueryString&#39;,
                 is_read_only=True, supported_from=EXCHANGE_2010),
        URIField(&#39;web_client_edit_form_query_string&#39;, field_uri=&#39;item:WebClientEditFormQueryString&#39;,
                 is_read_only=True, supported_from=EXCHANGE_2010),
        EWSElementField(&#39;conversation_id&#39;, field_uri=&#39;item:ConversationId&#39;, value_cls=ConversationId,
                        is_read_only=True, supported_from=EXCHANGE_2010),
        BodyField(&#39;unique_body&#39;, field_uri=&#39;item:UniqueBody&#39;, is_read_only=True, supported_from=EXCHANGE_2010),
    )
    FIELDS = LOCAL_FIELDS[0:1] + BaseItem.FIELDS + LOCAL_FIELDS[1:]

    __slots__ = tuple(f.name for f in LOCAL_FIELDS)

    # Used to register extended properties
    INSERT_AFTER_FIELD = &#39;has_attachments&#39;

    def __init__(self, **kwargs):
        super().__init__(**kwargs)
        # pylint: disable=access-member-before-definition
        if self.attachments:
            for a in self.attachments:
                if a.parent_item:
                    if a.parent_item is not self:
                        raise ValueError(&#34;&#39;parent_item&#39; of attachment %s must point to this item&#34; % a)
                else:
                    a.parent_item = self
                self.attach(self.attachments)
        else:
            self.attachments = []

    def save(self, update_fields=None, conflict_resolution=AUTO_RESOLVE, send_meeting_invitations=SEND_TO_NONE):
        if self.id:
            item_id, changekey = self._update(
                update_fieldnames=update_fields,
                message_disposition=SAVE_ONLY,
                conflict_resolution=conflict_resolution,
                send_meeting_invitations=send_meeting_invitations
            )
            if self.id != item_id and not isinstance(self._id, (OccurrenceItemId, RecurringMasterItemId)):
                # When we update an item with an OccurrenceItemId as ID, EWS returns the ID of the occurrence, so
                # the ID of this item changes.
                raise ValueError(&#34;&#39;id&#39; mismatch in returned update response&#34;)
            # Don&#39;t check that changekeys are different. No-op saves will sometimes leave the changekey intact
            self._id = self.ID_ELEMENT_CLS(item_id, changekey)
        else:
            if update_fields:
                raise ValueError(&#34;&#39;update_fields&#39; is only valid for updates&#34;)
            tmp_attachments = None
            if self.account and self.account.version.build &lt; EXCHANGE_2013 and self.attachments:
                # At least some versions prior to Exchange 2013 can&#39;t save attachments immediately. You need to first
                # save, then attach. Store the attachment of this item temporarily and attach later.
                tmp_attachments, self.attachments = self.attachments, []
            item = self._create(message_disposition=SAVE_ONLY, send_meeting_invitations=send_meeting_invitations)
            self._id = self.ID_ELEMENT_CLS(item.id, item.changekey)
            for old_att, new_att in zip(self.attachments, item.attachments):
                if old_att.attachment_id is not None:
                    raise ValueError(&#34;Old &#39;attachment_id&#39; is not empty&#34;)
                if new_att.attachment_id is None:
                    raise ValueError(&#34;New &#39;attachment_id&#39; is empty&#34;)
                old_att.attachment_id = new_att.attachment_id
            if tmp_attachments:
                # Exchange 2007 workaround. See above
                self.attach(tmp_attachments)
        return self

    @require_account
    def _create(self, message_disposition, send_meeting_invitations):
        # Return a BulkCreateResult because we want to return the ID of both the main item *and* attachments
        res = CreateItem(account=self.account).get(
            items=[self],
            folder=self.folder,
            message_disposition=message_disposition,
            send_meeting_invitations=send_meeting_invitations,
            expect_result=message_disposition not in (SEND_ONLY, SEND_AND_SAVE_COPY),
        )
        if res is None:
            return
        return BulkCreateResult.from_xml(elem=res, account=self)

    def _update_fieldnames(self):
        from .contact import Contact, DistributionList
        # Return the list of fields we are allowed to update
        update_fieldnames = []
        for f in self.supported_fields(version=self.account.version):
            if f.name == &#39;attachments&#39;:
                # Attachments are handled separately after item creation
                continue
            if f.is_read_only:
                # These cannot be changed
                continue
            if f.is_required or f.is_required_after_save:
                if getattr(self, f.name) is None or (f.is_list and not getattr(self, f.name)):
                    # These are required and cannot be deleted
                    continue
            if not self.is_draft and f.is_read_only_after_send:
                # These cannot be changed when the item is no longer a draft
                continue
            if f.name == &#39;message_id&#39; and f.is_read_only_after_send:
                # &#39;message_id&#39; doesn&#39;t support updating, no matter the draft status
                continue
            if f.name == &#39;mime_content&#39; and isinstance(self, (Contact, DistributionList)):
                # Contact and DistributionList don&#39;t support updating mime_content, no matter the draft status
                continue
            update_fieldnames.append(f.name)
        return update_fieldnames

    @require_account
    def _update(self, update_fieldnames, message_disposition, conflict_resolution, send_meeting_invitations):
        if not self.changekey:
            raise ValueError(&#39;%s must have changekey&#39; % self.__class__.__name__)
        if not update_fieldnames:
            # The fields to update was not specified explicitly. Update all fields where update is possible
            update_fieldnames = self._update_fieldnames()
        res = UpdateItem(account=self.account).get(
            items=[(self, update_fieldnames)],
            message_disposition=message_disposition,
            conflict_resolution=conflict_resolution,
            send_meeting_invitations_or_cancellations=send_meeting_invitations,
            suppress_read_receipts=True,
            expect_result=message_disposition != SEND_AND_SAVE_COPY,
        )
        if res is None:
            return
        return Item.id_from_xml(res)

    @require_id
    def refresh(self):
        # Updates the item based on fresh data from EWS
        from ..folders import Folder
        additional_fields = {
            FieldPath(field=f) for f in Folder(root=self.account.root).allowed_item_fields(version=self.account.version)
        }

        elem = GetItem(account=self.account).get(items=[self], additional_fields=additional_fields, shape=ID_ONLY)
        res = Folder.item_model_from_tag(elem.tag).from_xml(elem=elem, account=self.account)
        if self.id != res.id and not isinstance(self._id, (OccurrenceItemId, RecurringMasterItemId)):
            # When we refresh an item with an OccurrenceItemId as ID, EWS returns the ID of the occurrence, so
            # the ID of this item changes.
            raise ValueError(&#34;&#39;id&#39; mismatch in returned update response&#34;)
        for f in self.FIELDS:
            setattr(self, f.name, getattr(res, f.name))
        # &#39;parent_item&#39; should point to &#39;self&#39;, not &#39;fresh_item&#39;. That way, &#39;fresh_item&#39; can be garbage collected.
        for a in self.attachments:
            a.parent_item = self
        del res

    @require_id
    def copy(self, to_folder):
        res = CopyItem(account=self.account).get(
            items=[self],
            to_folder=to_folder,
            expect_result=None,
        )
        if res is None:
            # Assume &#39;to_folder&#39; is a public folder or a folder in a different mailbox
            return
        return Item.id_from_xml(res)

    @require_id
    def move(self, to_folder):
        res = MoveItem(account=self.account).get(
            items=[self],
            to_folder=to_folder,
            expect_result=None,
        )
        if res is None:
            # Assume &#39;to_folder&#39; is a public folder or a folder in a different mailbox
            self._id = None
            return
        self._id = self.ID_ELEMENT_CLS(*Item.id_from_xml(res))
        self.folder = to_folder

    def move_to_trash(self, send_meeting_cancellations=SEND_TO_NONE, affected_task_occurrences=ALL_OCCURRENCIES,
                      suppress_read_receipts=True):
        # Delete and move to the trash folder.
        self._delete(delete_type=MOVE_TO_DELETED_ITEMS, send_meeting_cancellations=send_meeting_cancellations,
                     affected_task_occurrences=affected_task_occurrences, suppress_read_receipts=suppress_read_receipts)
        self._id = None
        self.folder = self.account.trash

    def soft_delete(self, send_meeting_cancellations=SEND_TO_NONE, affected_task_occurrences=ALL_OCCURRENCIES,
                    suppress_read_receipts=True):
        # Delete and move to the dumpster, if it is enabled.
        self._delete(delete_type=SOFT_DELETE, send_meeting_cancellations=send_meeting_cancellations,
                     affected_task_occurrences=affected_task_occurrences, suppress_read_receipts=suppress_read_receipts)
        self._id = None
        self.folder = self.account.recoverable_items_deletions

    def delete(self, send_meeting_cancellations=SEND_TO_NONE, affected_task_occurrences=ALL_OCCURRENCIES,
               suppress_read_receipts=True):
        # Remove the item permanently. No copies are stored anywhere.
        self._delete(delete_type=HARD_DELETE, send_meeting_cancellations=send_meeting_cancellations,
                     affected_task_occurrences=affected_task_occurrences, suppress_read_receipts=suppress_read_receipts)
        self._id, self.folder = None, None

    @require_id
    def _delete(self, delete_type, send_meeting_cancellations, affected_task_occurrences, suppress_read_receipts):
        DeleteItem(account=self.account).get(
            items=[self],
            delete_type=delete_type,
            send_meeting_cancellations=send_meeting_cancellations,
            affected_task_occurrences=affected_task_occurrences,
            suppress_read_receipts=suppress_read_receipts,
        )

    @require_id
    def archive(self, to_folder):
        return ArchiveItem(account=self.account).get(items=[self], to_folder=to_folder)

    def attach(self, attachments):
        &#34;&#34;&#34;Add an attachment, or a list of attachments, to this item. If the item has already been saved, the
        attachments will be created on the server immediately. If the item has not yet been saved, the attachments will
        be created on the server when the item is saved.

        Adding attachments to an existing item will update the changekey of the item.

        Args:
          attachments:

        &#34;&#34;&#34;
        if not is_iterable(attachments, generators_allowed=True):
            attachments = [attachments]
        for a in attachments:
            if not a.parent_item:
                a.parent_item = self
            if self.id and not a.attachment_id:
                # Already saved object. Attach the attachment server-side now
                a.attach()
            if a not in self.attachments:
                self.attachments.append(a)

    def detach(self, attachments):
        &#34;&#34;&#34;Remove an attachment, or a list of attachments, from this item. If the item has already been saved, the
        attachments will be deleted on the server immediately. If the item has not yet been saved, the attachments will
        simply not be created on the server the item is saved.

        Removing attachments from an existing item will update the changekey of the item.

        Args:
          attachments:

        &#34;&#34;&#34;
        if not is_iterable(attachments, generators_allowed=True):
            attachments = [attachments]
        if attachments is self.attachments:
            # Don&#39;t remove from the same list we are iterating
            attachments = list(attachments)
        for a in attachments:
            if a.parent_item is not self:
                raise ValueError(&#39;Attachment does not belong to this item&#39;)
            if self.id:
                # Item is already created. Detach  the attachment server-side now
                a.detach()
            if a in self.attachments:
                self.attachments.remove(a)

    @require_id
    def create_forward(self, subject, body, to_recipients, cc_recipients=None, bcc_recipients=None):
        from .message import ForwardItem
        return ForwardItem(
            account=self.account,
            reference_item_id=ReferenceItemId(id=self.id, changekey=self.changekey),
            subject=subject,
            new_body=body,
            to_recipients=to_recipients,
            cc_recipients=cc_recipients,
            bcc_recipients=bcc_recipients,
        )

    def forward(self, subject, body, to_recipients, cc_recipients=None, bcc_recipients=None):
        self.create_forward(
            subject,
            body,
            to_recipients,
            cc_recipients,
            bcc_recipients,
        ).send()</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="exchangelib.items.base.BaseItem" href="base.html#exchangelib.items.base.BaseItem">BaseItem</a></li>
<li><a title="exchangelib.items.base.RegisterMixIn" href="base.html#exchangelib.items.base.RegisterMixIn">RegisterMixIn</a></li>
<li><a title="exchangelib.properties.IdChangeKeyMixIn" href="../properties.html#exchangelib.properties.IdChangeKeyMixIn">IdChangeKeyMixIn</a></li>
<li><a title="exchangelib.properties.EWSElement" href="../properties.html#exchangelib.properties.EWSElement">EWSElement</a></li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="exchangelib.items.calendar_item.BaseMeetingItem" href="calendar_item.html#exchangelib.items.calendar_item.BaseMeetingItem">BaseMeetingItem</a></li>
<li><a title="exchangelib.items.calendar_item.CalendarItem" href="calendar_item.html#exchangelib.items.calendar_item.CalendarItem">CalendarItem</a></li>
<li><a title="exchangelib.items.contact.Contact" href="contact.html#exchangelib.items.contact.Contact">Contact</a></li>
<li><a title="exchangelib.items.contact.DistributionList" href="contact.html#exchangelib.items.contact.DistributionList">DistributionList</a></li>
<li><a title="exchangelib.items.message.Message" href="message.html#exchangelib.items.message.Message">Message</a></li>
<li><a title="exchangelib.items.post.PostItem" href="post.html#exchangelib.items.post.PostItem">PostItem</a></li>
<li><a title="exchangelib.items.post.PostReplyItem" href="post.html#exchangelib.items.post.PostReplyItem">PostReplyItem</a></li>
<li><a title="exchangelib.items.task.Task" href="task.html#exchangelib.items.task.Task">Task</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="exchangelib.items.item.Item.ELEMENT_NAME"><code class="name">var <span class="ident">ELEMENT_NAME</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.items.item.Item.FIELDS"><code class="name">var <span class="ident">FIELDS</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.items.item.Item.INSERT_AFTER_FIELD"><code class="name">var <span class="ident">INSERT_AFTER_FIELD</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.items.item.Item.LOCAL_FIELDS"><code class="name">var <span class="ident">LOCAL_FIELDS</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="exchangelib.items.item.Item.attachments"><code class="name">var <span class="ident">attachments</span></code></dt>
<dd>
<div class="desc"><p>Return an attribute of instance, which is of type owner.</p></div>
</dd>
<dt id="exchangelib.items.item.Item.body"><code class="name">var <span class="ident">body</span></code></dt>
<dd>
<div class="desc"><p>Return an attribute of instance, which is of type owner.</p></div>
</dd>
<dt id="exchangelib.items.item.Item.categories"><code class="name">var <span class="ident">categories</span></code></dt>
<dd>
<div class="desc"><p>Return an attribute of instance, which is of type owner.</p></div>
</dd>
<dt id="exchangelib.items.item.Item.conversation_id"><code class="name">var <span class="ident">conversation_id</span></code></dt>
<dd>
<div class="desc"><p>Return an attribute of instance, which is of type owner.</p></div>
</dd>
<dt id="exchangelib.items.item.Item.culture"><code class="name">var <span class="ident">culture</span></code></dt>
<dd>
<div class="desc"><p>Return an attribute of instance, which is of type owner.</p></div>
</dd>
<dt id="exchangelib.items.item.Item.datetime_created"><code class="name">var <span class="ident">datetime_created</span></code></dt>
<dd>
<div class="desc"><p>Return an attribute of instance, which is of type owner.</p></div>
</dd>
<dt id="exchangelib.items.item.Item.datetime_received"><code class="name">var <span class="ident">datetime_received</span></code></dt>
<dd>
<div class="desc"><p>Return an attribute of instance, which is of type owner.</p></div>
</dd>
<dt id="exchangelib.items.item.Item.datetime_sent"><code class="name">var <span class="ident">datetime_sent</span></code></dt>
<dd>
<div class="desc"><p>Return an attribute of instance, which is of type owner.</p></div>
</dd>
<dt id="exchangelib.items.item.Item.display_cc"><code class="name">var <span class="ident">display_cc</span></code></dt>
<dd>
<div class="desc"><p>Return an attribute of instance, which is of type owner.</p></div>
</dd>
<dt id="exchangelib.items.item.Item.display_to"><code class="name">var <span class="ident">display_to</span></code></dt>
<dd>
<div class="desc"><p>Return an attribute of instance, which is of type owner.</p></div>
</dd>
<dt id="exchangelib.items.item.Item.effective_rights"><code class="name">var <span class="ident">effective_rights</span></code></dt>
<dd>
<div class="desc"><p>Return an attribute of instance, which is of type owner.</p></div>
</dd>
<dt id="exchangelib.items.item.Item.has_attachments"><code class="name">var <span class="ident">has_attachments</span></code></dt>
<dd>
<div class="desc"><p>Return an attribute of instance, which is of type owner.</p></div>
</dd>
<dt id="exchangelib.items.item.Item.headers"><code class="name">var <span class="ident">headers</span></code></dt>
<dd>
<div class="desc"><p>Return an attribute of instance, which is of type owner.</p></div>
</dd>
<dt id="exchangelib.items.item.Item.importance"><code class="name">var <span class="ident">importance</span></code></dt>
<dd>
<div class="desc"><p>Return an attribute of instance, which is of type owner.</p></div>
</dd>
<dt id="exchangelib.items.item.Item.in_reply_to"><code class="name">var <span class="ident">in_reply_to</span></code></dt>
<dd>
<div class="desc"><p>Return an attribute of instance, which is of type owner.</p></div>
</dd>
<dt id="exchangelib.items.item.Item.is_associated"><code class="name">var <span class="ident">is_associated</span></code></dt>
<dd>
<div class="desc"><p>Return an attribute of instance, which is of type owner.</p></div>
</dd>
<dt id="exchangelib.items.item.Item.is_draft"><code class="name">var <span class="ident">is_draft</span></code></dt>
<dd>
<div class="desc"><p>Return an attribute of instance, which is of type owner.</p></div>
</dd>
<dt id="exchangelib.items.item.Item.is_from_me"><code class="name">var <span class="ident">is_from_me</span></code></dt>
<dd>
<div class="desc"><p>Return an attribute of instance, which is of type owner.</p></div>
</dd>
<dt id="exchangelib.items.item.Item.is_resend"><code class="name">var <span class="ident">is_resend</span></code></dt>
<dd>
<div class="desc"><p>Return an attribute of instance, which is of type owner.</p></div>
</dd>
<dt id="exchangelib.items.item.Item.is_submitted"><code class="name">var <span class="ident">is_submitted</span></code></dt>
<dd>
<div class="desc"><p>Return an attribute of instance, which is of type owner.</p></div>
</dd>
<dt id="exchangelib.items.item.Item.is_unmodified"><code class="name">var <span class="ident">is_unmodified</span></code></dt>
<dd>
<div class="desc"><p>Return an attribute of instance, which is of type owner.</p></div>
</dd>
<dt id="exchangelib.items.item.Item.item_class"><code class="name">var <span class="ident">item_class</span></code></dt>
<dd>
<div class="desc"><p>Return an attribute of instance, which is of type owner.</p></div>
</dd>
<dt id="exchangelib.items.item.Item.last_modified_name"><code class="name">var <span class="ident">last_modified_name</span></code></dt>
<dd>
<div class="desc"><p>Return an attribute of instance, which is of type owner.</p></div>
</dd>
<dt id="exchangelib.items.item.Item.last_modified_time"><code class="name">var <span class="ident">last_modified_time</span></code></dt>
<dd>
<div class="desc"><p>Return an attribute of instance, which is of type owner.</p></div>
</dd>
<dt id="exchangelib.items.item.Item.mime_content"><code class="name">var <span class="ident">mime_content</span></code></dt>
<dd>
<div class="desc"><p>Return an attribute of instance, which is of type owner.</p></div>
</dd>
<dt id="exchangelib.items.item.Item.parent_folder_id"><code class="name">var <span class="ident">parent_folder_id</span></code></dt>
<dd>
<div class="desc"><p>Return an attribute of instance, which is of type owner.</p></div>
</dd>
<dt id="exchangelib.items.item.Item.reminder_due_by"><code class="name">var <span class="ident">reminder_due_by</span></code></dt>
<dd>
<div class="desc"><p>Return an attribute of instance, which is of type owner.</p></div>
</dd>
<dt id="exchangelib.items.item.Item.reminder_is_set"><code class="name">var <span class="ident">reminder_is_set</span></code></dt>
<dd>
<div class="desc"><p>Return an attribute of instance, which is of type owner.</p></div>
</dd>
<dt id="exchangelib.items.item.Item.reminder_minutes_before_start"><code class="name">var <span class="ident">reminder_minutes_before_start</span></code></dt>
<dd>
<div class="desc"><p>Return an attribute of instance, which is of type owner.</p></div>
</dd>
<dt id="exchangelib.items.item.Item.sensitivity"><code class="name">var <span class="ident">sensitivity</span></code></dt>
<dd>
<div class="desc"><p>Return an attribute of instance, which is of type owner.</p></div>
</dd>
<dt id="exchangelib.items.item.Item.size"><code class="name">var <span class="ident">size</span></code></dt>
<dd>
<div class="desc"><p>Return an attribute of instance, which is of type owner.</p></div>
</dd>
<dt id="exchangelib.items.item.Item.subject"><code class="name">var <span class="ident">subject</span></code></dt>
<dd>
<div class="desc"><p>Return an attribute of instance, which is of type owner.</p></div>
</dd>
<dt id="exchangelib.items.item.Item.text_body"><code class="name">var <span class="ident">text_body</span></code></dt>
<dd>
<div class="desc"><p>Return an attribute of instance, which is of type owner.</p></div>
</dd>
<dt id="exchangelib.items.item.Item.unique_body"><code class="name">var <span class="ident">unique_body</span></code></dt>
<dd>
<div class="desc"><p>Return an attribute of instance, which is of type owner.</p></div>
</dd>
<dt id="exchangelib.items.item.Item.web_client_edit_form_query_string"><code class="name">var <span class="ident">web_client_edit_form_query_string</span></code></dt>
<dd>
<div class="desc"><p>Return an attribute of instance, which is of type owner.</p></div>
</dd>
<dt id="exchangelib.items.item.Item.web_client_read_form_query_string"><code class="name">var <span class="ident">web_client_read_form_query_string</span></code></dt>
<dd>
<div class="desc"><p>Return an attribute of instance, which is of type owner.</p></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="exchangelib.items.item.Item.archive"><code class="name flex">
<span>def <span class="ident">archive</span></span>(<span>self, to_folder)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@require_id
def archive(self, to_folder):
    return ArchiveItem(account=self.account).get(items=[self], to_folder=to_folder)</code></pre>
</details>
</dd>
<dt id="exchangelib.items.item.Item.attach"><code class="name flex">
<span>def <span class="ident">attach</span></span>(<span>self, attachments)</span>
</code></dt>
<dd>
<div class="desc"><p>Add an attachment, or a list of attachments, to this item. If the item has already been saved, the
attachments will be created on the server immediately. If the item has not yet been saved, the attachments will
be created on the server when the item is saved.</p>
<p>Adding attachments to an existing item will update the changekey of the item.</p>
<h2 id="args">Args</h2>
<p>attachments:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def attach(self, attachments):
    &#34;&#34;&#34;Add an attachment, or a list of attachments, to this item. If the item has already been saved, the
    attachments will be created on the server immediately. If the item has not yet been saved, the attachments will
    be created on the server when the item is saved.

    Adding attachments to an existing item will update the changekey of the item.

    Args:
      attachments:

    &#34;&#34;&#34;
    if not is_iterable(attachments, generators_allowed=True):
        attachments = [attachments]
    for a in attachments:
        if not a.parent_item:
            a.parent_item = self
        if self.id and not a.attachment_id:
            # Already saved object. Attach the attachment server-side now
            a.attach()
        if a not in self.attachments:
            self.attachments.append(a)</code></pre>
</details>
</dd>
<dt id="exchangelib.items.item.Item.copy"><code class="name flex">
<span>def <span class="ident">copy</span></span>(<span>self, to_folder)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@require_id
def copy(self, to_folder):
    res = CopyItem(account=self.account).get(
        items=[self],
        to_folder=to_folder,
        expect_result=None,
    )
    if res is None:
        # Assume &#39;to_folder&#39; is a public folder or a folder in a different mailbox
        return
    return Item.id_from_xml(res)</code></pre>
</details>
</dd>
<dt id="exchangelib.items.item.Item.create_forward"><code class="name flex">
<span>def <span class="ident">create_forward</span></span>(<span>self, subject, body, to_recipients, cc_recipients=None, bcc_recipients=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@require_id
def create_forward(self, subject, body, to_recipients, cc_recipients=None, bcc_recipients=None):
    from .message import ForwardItem
    return ForwardItem(
        account=self.account,
        reference_item_id=ReferenceItemId(id=self.id, changekey=self.changekey),
        subject=subject,
        new_body=body,
        to_recipients=to_recipients,
        cc_recipients=cc_recipients,
        bcc_recipients=bcc_recipients,
    )</code></pre>
</details>
</dd>
<dt id="exchangelib.items.item.Item.delete"><code class="name flex">
<span>def <span class="ident">delete</span></span>(<span>self, send_meeting_cancellations='SendToNone', affected_task_occurrences='AllOccurrences', suppress_read_receipts=True)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def delete(self, send_meeting_cancellations=SEND_TO_NONE, affected_task_occurrences=ALL_OCCURRENCIES,
           suppress_read_receipts=True):
    # Remove the item permanently. No copies are stored anywhere.
    self._delete(delete_type=HARD_DELETE, send_meeting_cancellations=send_meeting_cancellations,
                 affected_task_occurrences=affected_task_occurrences, suppress_read_receipts=suppress_read_receipts)
    self._id, self.folder = None, None</code></pre>
</details>
</dd>
<dt id="exchangelib.items.item.Item.detach"><code class="name flex">
<span>def <span class="ident">detach</span></span>(<span>self, attachments)</span>
</code></dt>
<dd>
<div class="desc"><p>Remove an attachment, or a list of attachments, from this item. If the item has already been saved, the
attachments will be deleted on the server immediately. If the item has not yet been saved, the attachments will
simply not be created on the server the item is saved.</p>
<p>Removing attachments from an existing item will update the changekey of the item.</p>
<h2 id="args">Args</h2>
<p>attachments:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def detach(self, attachments):
    &#34;&#34;&#34;Remove an attachment, or a list of attachments, from this item. If the item has already been saved, the
    attachments will be deleted on the server immediately. If the item has not yet been saved, the attachments will
    simply not be created on the server the item is saved.

    Removing attachments from an existing item will update the changekey of the item.

    Args:
      attachments:

    &#34;&#34;&#34;
    if not is_iterable(attachments, generators_allowed=True):
        attachments = [attachments]
    if attachments is self.attachments:
        # Don&#39;t remove from the same list we are iterating
        attachments = list(attachments)
    for a in attachments:
        if a.parent_item is not self:
            raise ValueError(&#39;Attachment does not belong to this item&#39;)
        if self.id:
            # Item is already created. Detach  the attachment server-side now
            a.detach()
        if a in self.attachments:
            self.attachments.remove(a)</code></pre>
</details>
</dd>
<dt id="exchangelib.items.item.Item.forward"><code class="name flex">
<span>def <span class="ident">forward</span></span>(<span>self, subject, body, to_recipients, cc_recipients=None, bcc_recipients=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def forward(self, subject, body, to_recipients, cc_recipients=None, bcc_recipients=None):
    self.create_forward(
        subject,
        body,
        to_recipients,
        cc_recipients,
        bcc_recipients,
    ).send()</code></pre>
</details>
</dd>
<dt id="exchangelib.items.item.Item.move"><code class="name flex">
<span>def <span class="ident">move</span></span>(<span>self, to_folder)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@require_id
def move(self, to_folder):
    res = MoveItem(account=self.account).get(
        items=[self],
        to_folder=to_folder,
        expect_result=None,
    )
    if res is None:
        # Assume &#39;to_folder&#39; is a public folder or a folder in a different mailbox
        self._id = None
        return
    self._id = self.ID_ELEMENT_CLS(*Item.id_from_xml(res))
    self.folder = to_folder</code></pre>
</details>
</dd>
<dt id="exchangelib.items.item.Item.move_to_trash"><code class="name flex">
<span>def <span class="ident">move_to_trash</span></span>(<span>self, send_meeting_cancellations='SendToNone', affected_task_occurrences='AllOccurrences', suppress_read_receipts=True)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def move_to_trash(self, send_meeting_cancellations=SEND_TO_NONE, affected_task_occurrences=ALL_OCCURRENCIES,
                  suppress_read_receipts=True):
    # Delete and move to the trash folder.
    self._delete(delete_type=MOVE_TO_DELETED_ITEMS, send_meeting_cancellations=send_meeting_cancellations,
                 affected_task_occurrences=affected_task_occurrences, suppress_read_receipts=suppress_read_receipts)
    self._id = None
    self.folder = self.account.trash</code></pre>
</details>
</dd>
<dt id="exchangelib.items.item.Item.refresh"><code class="name flex">
<span>def <span class="ident">refresh</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@require_id
def refresh(self):
    # Updates the item based on fresh data from EWS
    from ..folders import Folder
    additional_fields = {
        FieldPath(field=f) for f in Folder(root=self.account.root).allowed_item_fields(version=self.account.version)
    }

    elem = GetItem(account=self.account).get(items=[self], additional_fields=additional_fields, shape=ID_ONLY)
    res = Folder.item_model_from_tag(elem.tag).from_xml(elem=elem, account=self.account)
    if self.id != res.id and not isinstance(self._id, (OccurrenceItemId, RecurringMasterItemId)):
        # When we refresh an item with an OccurrenceItemId as ID, EWS returns the ID of the occurrence, so
        # the ID of this item changes.
        raise ValueError(&#34;&#39;id&#39; mismatch in returned update response&#34;)
    for f in self.FIELDS:
        setattr(self, f.name, getattr(res, f.name))
    # &#39;parent_item&#39; should point to &#39;self&#39;, not &#39;fresh_item&#39;. That way, &#39;fresh_item&#39; can be garbage collected.
    for a in self.attachments:
        a.parent_item = self
    del res</code></pre>
</details>
</dd>
<dt id="exchangelib.items.item.Item.save"><code class="name flex">
<span>def <span class="ident">save</span></span>(<span>self, update_fields=None, conflict_resolution='AutoResolve', send_meeting_invitations='SendToNone')</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def save(self, update_fields=None, conflict_resolution=AUTO_RESOLVE, send_meeting_invitations=SEND_TO_NONE):
    if self.id:
        item_id, changekey = self._update(
            update_fieldnames=update_fields,
            message_disposition=SAVE_ONLY,
            conflict_resolution=conflict_resolution,
            send_meeting_invitations=send_meeting_invitations
        )
        if self.id != item_id and not isinstance(self._id, (OccurrenceItemId, RecurringMasterItemId)):
            # When we update an item with an OccurrenceItemId as ID, EWS returns the ID of the occurrence, so
            # the ID of this item changes.
            raise ValueError(&#34;&#39;id&#39; mismatch in returned update response&#34;)
        # Don&#39;t check that changekeys are different. No-op saves will sometimes leave the changekey intact
        self._id = self.ID_ELEMENT_CLS(item_id, changekey)
    else:
        if update_fields:
            raise ValueError(&#34;&#39;update_fields&#39; is only valid for updates&#34;)
        tmp_attachments = None
        if self.account and self.account.version.build &lt; EXCHANGE_2013 and self.attachments:
            # At least some versions prior to Exchange 2013 can&#39;t save attachments immediately. You need to first
            # save, then attach. Store the attachment of this item temporarily and attach later.
            tmp_attachments, self.attachments = self.attachments, []
        item = self._create(message_disposition=SAVE_ONLY, send_meeting_invitations=send_meeting_invitations)
        self._id = self.ID_ELEMENT_CLS(item.id, item.changekey)
        for old_att, new_att in zip(self.attachments, item.attachments):
            if old_att.attachment_id is not None:
                raise ValueError(&#34;Old &#39;attachment_id&#39; is not empty&#34;)
            if new_att.attachment_id is None:
                raise ValueError(&#34;New &#39;attachment_id&#39; is empty&#34;)
            old_att.attachment_id = new_att.attachment_id
        if tmp_attachments:
            # Exchange 2007 workaround. See above
            self.attach(tmp_attachments)
    return self</code></pre>
</details>
</dd>
<dt id="exchangelib.items.item.Item.soft_delete"><code class="name flex">
<span>def <span class="ident">soft_delete</span></span>(<span>self, send_meeting_cancellations='SendToNone', affected_task_occurrences='AllOccurrences', suppress_read_receipts=True)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def soft_delete(self, send_meeting_cancellations=SEND_TO_NONE, affected_task_occurrences=ALL_OCCURRENCIES,
                suppress_read_receipts=True):
    # Delete and move to the dumpster, if it is enabled.
    self._delete(delete_type=SOFT_DELETE, send_meeting_cancellations=send_meeting_cancellations,
                 affected_task_occurrences=affected_task_occurrences, suppress_read_receipts=suppress_read_receipts)
    self._id = None
    self.folder = self.account.recoverable_items_deletions</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="exchangelib.items.base.BaseItem" href="base.html#exchangelib.items.base.BaseItem">BaseItem</a></b></code>:
<ul class="hlist">
<li><code><a title="exchangelib.items.base.BaseItem.ID_ELEMENT_CLS" href="base.html#exchangelib.items.base.BaseItem.ID_ELEMENT_CLS">ID_ELEMENT_CLS</a></code></li>
<li><code><a title="exchangelib.items.base.BaseItem.account" href="base.html#exchangelib.items.base.BaseItem.account">account</a></code></li>
<li><code><a title="exchangelib.items.base.BaseItem.add_field" href="../properties.html#exchangelib.properties.EWSElement.add_field">add_field</a></code></li>
<li><code><a title="exchangelib.items.base.BaseItem.deregister" href="base.html#exchangelib.items.base.RegisterMixIn.deregister">deregister</a></code></li>
<li><code><a title="exchangelib.items.base.BaseItem.folder" href="base.html#exchangelib.items.base.BaseItem.folder">folder</a></code></li>
<li><code><a title="exchangelib.items.base.BaseItem.register" href="base.html#exchangelib.items.base.RegisterMixIn.register">register</a></code></li>
<li><code><a title="exchangelib.items.base.BaseItem.remove_field" href="../properties.html#exchangelib.properties.EWSElement.remove_field">remove_field</a></code></li>
<li><code><a title="exchangelib.items.base.BaseItem.supported_fields" href="../properties.html#exchangelib.properties.EWSElement.supported_fields">supported_fields</a></code></li>
<li><code><a title="exchangelib.items.base.BaseItem.validate_field" href="../properties.html#exchangelib.properties.EWSElement.validate_field">validate_field</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="exchangelib.items" href="index.html">exchangelib.items</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="exchangelib.items.item.Item" href="#exchangelib.items.item.Item">Item</a></code></h4>
<ul class="">
<li><code><a title="exchangelib.items.item.Item.ELEMENT_NAME" href="#exchangelib.items.item.Item.ELEMENT_NAME">ELEMENT_NAME</a></code></li>
<li><code><a title="exchangelib.items.item.Item.FIELDS" href="#exchangelib.items.item.Item.FIELDS">FIELDS</a></code></li>
<li><code><a title="exchangelib.items.item.Item.INSERT_AFTER_FIELD" href="#exchangelib.items.item.Item.INSERT_AFTER_FIELD">INSERT_AFTER_FIELD</a></code></li>
<li><code><a title="exchangelib.items.item.Item.LOCAL_FIELDS" href="#exchangelib.items.item.Item.LOCAL_FIELDS">LOCAL_FIELDS</a></code></li>
<li><code><a title="exchangelib.items.item.Item.archive" href="#exchangelib.items.item.Item.archive">archive</a></code></li>
<li><code><a title="exchangelib.items.item.Item.attach" href="#exchangelib.items.item.Item.attach">attach</a></code></li>
<li><code><a title="exchangelib.items.item.Item.attachments" href="#exchangelib.items.item.Item.attachments">attachments</a></code></li>
<li><code><a title="exchangelib.items.item.Item.body" href="#exchangelib.items.item.Item.body">body</a></code></li>
<li><code><a title="exchangelib.items.item.Item.categories" href="#exchangelib.items.item.Item.categories">categories</a></code></li>
<li><code><a title="exchangelib.items.item.Item.conversation_id" href="#exchangelib.items.item.Item.conversation_id">conversation_id</a></code></li>
<li><code><a title="exchangelib.items.item.Item.copy" href="#exchangelib.items.item.Item.copy">copy</a></code></li>
<li><code><a title="exchangelib.items.item.Item.create_forward" href="#exchangelib.items.item.Item.create_forward">create_forward</a></code></li>
<li><code><a title="exchangelib.items.item.Item.culture" href="#exchangelib.items.item.Item.culture">culture</a></code></li>
<li><code><a title="exchangelib.items.item.Item.datetime_created" href="#exchangelib.items.item.Item.datetime_created">datetime_created</a></code></li>
<li><code><a title="exchangelib.items.item.Item.datetime_received" href="#exchangelib.items.item.Item.datetime_received">datetime_received</a></code></li>
<li><code><a title="exchangelib.items.item.Item.datetime_sent" href="#exchangelib.items.item.Item.datetime_sent">datetime_sent</a></code></li>
<li><code><a title="exchangelib.items.item.Item.delete" href="#exchangelib.items.item.Item.delete">delete</a></code></li>
<li><code><a title="exchangelib.items.item.Item.detach" href="#exchangelib.items.item.Item.detach">detach</a></code></li>
<li><code><a title="exchangelib.items.item.Item.display_cc" href="#exchangelib.items.item.Item.display_cc">display_cc</a></code></li>
<li><code><a title="exchangelib.items.item.Item.display_to" href="#exchangelib.items.item.Item.display_to">display_to</a></code></li>
<li><code><a title="exchangelib.items.item.Item.effective_rights" href="#exchangelib.items.item.Item.effective_rights">effective_rights</a></code></li>
<li><code><a title="exchangelib.items.item.Item.forward" href="#exchangelib.items.item.Item.forward">forward</a></code></li>
<li><code><a title="exchangelib.items.item.Item.has_attachments" href="#exchangelib.items.item.Item.has_attachments">has_attachments</a></code></li>
<li><code><a title="exchangelib.items.item.Item.headers" href="#exchangelib.items.item.Item.headers">headers</a></code></li>
<li><code><a title="exchangelib.items.item.Item.importance" href="#exchangelib.items.item.Item.importance">importance</a></code></li>
<li><code><a title="exchangelib.items.item.Item.in_reply_to" href="#exchangelib.items.item.Item.in_reply_to">in_reply_to</a></code></li>
<li><code><a title="exchangelib.items.item.Item.is_associated" href="#exchangelib.items.item.Item.is_associated">is_associated</a></code></li>
<li><code><a title="exchangelib.items.item.Item.is_draft" href="#exchangelib.items.item.Item.is_draft">is_draft</a></code></li>
<li><code><a title="exchangelib.items.item.Item.is_from_me" href="#exchangelib.items.item.Item.is_from_me">is_from_me</a></code></li>
<li><code><a title="exchangelib.items.item.Item.is_resend" href="#exchangelib.items.item.Item.is_resend">is_resend</a></code></li>
<li><code><a title="exchangelib.items.item.Item.is_submitted" href="#exchangelib.items.item.Item.is_submitted">is_submitted</a></code></li>
<li><code><a title="exchangelib.items.item.Item.is_unmodified" href="#exchangelib.items.item.Item.is_unmodified">is_unmodified</a></code></li>
<li><code><a title="exchangelib.items.item.Item.item_class" href="#exchangelib.items.item.Item.item_class">item_class</a></code></li>
<li><code><a title="exchangelib.items.item.Item.last_modified_name" href="#exchangelib.items.item.Item.last_modified_name">last_modified_name</a></code></li>
<li><code><a title="exchangelib.items.item.Item.last_modified_time" href="#exchangelib.items.item.Item.last_modified_time">last_modified_time</a></code></li>
<li><code><a title="exchangelib.items.item.Item.mime_content" href="#exchangelib.items.item.Item.mime_content">mime_content</a></code></li>
<li><code><a title="exchangelib.items.item.Item.move" href="#exchangelib.items.item.Item.move">move</a></code></li>
<li><code><a title="exchangelib.items.item.Item.move_to_trash" href="#exchangelib.items.item.Item.move_to_trash">move_to_trash</a></code></li>
<li><code><a title="exchangelib.items.item.Item.parent_folder_id" href="#exchangelib.items.item.Item.parent_folder_id">parent_folder_id</a></code></li>
<li><code><a title="exchangelib.items.item.Item.refresh" href="#exchangelib.items.item.Item.refresh">refresh</a></code></li>
<li><code><a title="exchangelib.items.item.Item.reminder_due_by" href="#exchangelib.items.item.Item.reminder_due_by">reminder_due_by</a></code></li>
<li><code><a title="exchangelib.items.item.Item.reminder_is_set" href="#exchangelib.items.item.Item.reminder_is_set">reminder_is_set</a></code></li>
<li><code><a title="exchangelib.items.item.Item.reminder_minutes_before_start" href="#exchangelib.items.item.Item.reminder_minutes_before_start">reminder_minutes_before_start</a></code></li>
<li><code><a title="exchangelib.items.item.Item.save" href="#exchangelib.items.item.Item.save">save</a></code></li>
<li><code><a title="exchangelib.items.item.Item.sensitivity" href="#exchangelib.items.item.Item.sensitivity">sensitivity</a></code></li>
<li><code><a title="exchangelib.items.item.Item.size" href="#exchangelib.items.item.Item.size">size</a></code></li>
<li><code><a title="exchangelib.items.item.Item.soft_delete" href="#exchangelib.items.item.Item.soft_delete">soft_delete</a></code></li>
<li><code><a title="exchangelib.items.item.Item.subject" href="#exchangelib.items.item.Item.subject">subject</a></code></li>
<li><code><a title="exchangelib.items.item.Item.text_body" href="#exchangelib.items.item.Item.text_body">text_body</a></code></li>
<li><code><a title="exchangelib.items.item.Item.unique_body" href="#exchangelib.items.item.Item.unique_body">unique_body</a></code></li>
<li><code><a title="exchangelib.items.item.Item.web_client_edit_form_query_string" href="#exchangelib.items.item.Item.web_client_edit_form_query_string">web_client_edit_form_query_string</a></code></li>
<li><code><a title="exchangelib.items.item.Item.web_client_read_form_query_string" href="#exchangelib.items.item.Item.web_client_read_form_query_string">web_client_read_form_query_string</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.8.3</a>.</p>
</footer>
</body>
</html>