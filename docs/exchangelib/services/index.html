<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.1" />
<title>exchangelib.services API documentation</title>
<meta name="description" content="Implement a selection of EWS services (operations) â€¦" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>exchangelib.services</code></h1>
</header>
<section id="section-intro">
<p>Implement a selection of EWS services (operations).</p>
<p>Exchange is very picky about things like the order of XML elements in SOAP requests, so we need to generate XML
automatically instead of taking advantage of Python SOAP libraries and the WSDL file.</p>
<p>Exchange EWS operations overview:
<a href="https://docs.microsoft.com/en-us/exchange/client-developer/web-service-reference/ews-operations-in-exchange">https://docs.microsoft.com/en-us/exchange/client-developer/web-service-reference/ews-operations-in-exchange</a></p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;
Implement a selection of EWS services (operations).

Exchange is very picky about things like the order of XML elements in SOAP requests, so we need to generate XML
automatically instead of taking advantage of Python SOAP libraries and the WSDL file.

Exchange EWS operations overview:
    https://docs.microsoft.com/en-us/exchange/client-developer/web-service-reference/ews-operations-in-exchange
&#34;&#34;&#34;

from .common import CHUNK_SIZE
from .archive_item import ArchiveItem
from .convert_id import ConvertId
from .copy_item import CopyItem
from .create_attachment import CreateAttachment
from .create_folder import CreateFolder
from .create_item import CreateItem
from .delete_attachment import DeleteAttachment
from .delete_folder import DeleteFolder
from .delete_item import DeleteItem
from .empty_folder import EmptyFolder
from .expand_dl import ExpandDL
from .export_items import ExportItems
from .find_folder import FindFolder
from .find_item import FindItem
from .find_people import FindPeople
from .get_attachment import GetAttachment
from .get_delegate import GetDelegate
from .get_folder import GetFolder
from .get_item import GetItem
from .get_mail_tips import GetMailTips
from .get_persona import GetPersona
from .get_room_lists import GetRoomLists
from .get_rooms import GetRooms
from .get_searchable_mailboxes import GetSearchableMailboxes
from .get_server_time_zones import GetServerTimeZones
from .get_user_availability import GetUserAvailability
from .get_user_oof_settings import GetUserOofSettings
from .move_item import MoveItem
from .resolve_names import ResolveNames
from .send_item import SendItem
from .set_user_oof_settings import SetUserOofSettings
from .update_folder import UpdateFolder
from .update_item import UpdateItem
from .upload_items import UploadItems

__all__ = [
    &#39;CHUNK_SIZE&#39;,
    &#39;ArchiveItem&#39;,
    &#39;ConvertId&#39;,
    &#39;CopyItem&#39;,
    &#39;CreateAttachment&#39;,
    &#39;CreateFolder&#39;,
    &#39;CreateItem&#39;,
    &#39;DeleteAttachment&#39;,
    &#39;DeleteFolder&#39;,
    &#39;DeleteItem&#39;,
    &#39;EmptyFolder&#39;,
    &#39;ExpandDL&#39;,
    &#39;ExportItems&#39;,
    &#39;FindFolder&#39;,
    &#39;FindItem&#39;,
    &#39;FindPeople&#39;,
    &#39;GetAttachment&#39;,
    &#39;GetDelegate&#39;,
    &#39;GetFolder&#39;,
    &#39;GetItem&#39;,
    &#39;GetMailTips&#39;,
    &#39;GetPersona&#39;,
    &#39;GetRoomLists&#39;,
    &#39;GetRooms&#39;,
    &#39;GetSearchableMailboxes&#39;,
    &#39;GetServerTimeZones&#39;,
    &#39;GetUserAvailability&#39;,
    &#39;GetUserOofSettings&#39;,
    &#39;MoveItem&#39;,
    &#39;ResolveNames&#39;,
    &#39;SendItem&#39;,
    &#39;SetUserOofSettings&#39;,
    &#39;UpdateFolder&#39;,
    &#39;UpdateItem&#39;,
    &#39;UploadItems&#39;,
]</code></pre>
</details>
</section>
<section>
<h2 class="section-title" id="header-submodules">Sub-modules</h2>
<dl>
<dt><code class="name"><a title="exchangelib.services.archive_item" href="archive_item.html">exchangelib.services.archive_item</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="exchangelib.services.common" href="common.html">exchangelib.services.common</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="exchangelib.services.convert_id" href="convert_id.html">exchangelib.services.convert_id</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="exchangelib.services.copy_item" href="copy_item.html">exchangelib.services.copy_item</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="exchangelib.services.create_attachment" href="create_attachment.html">exchangelib.services.create_attachment</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="exchangelib.services.create_folder" href="create_folder.html">exchangelib.services.create_folder</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="exchangelib.services.create_item" href="create_item.html">exchangelib.services.create_item</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="exchangelib.services.delete_attachment" href="delete_attachment.html">exchangelib.services.delete_attachment</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="exchangelib.services.delete_folder" href="delete_folder.html">exchangelib.services.delete_folder</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="exchangelib.services.delete_item" href="delete_item.html">exchangelib.services.delete_item</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="exchangelib.services.empty_folder" href="empty_folder.html">exchangelib.services.empty_folder</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="exchangelib.services.expand_dl" href="expand_dl.html">exchangelib.services.expand_dl</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="exchangelib.services.export_items" href="export_items.html">exchangelib.services.export_items</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="exchangelib.services.find_folder" href="find_folder.html">exchangelib.services.find_folder</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="exchangelib.services.find_item" href="find_item.html">exchangelib.services.find_item</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="exchangelib.services.find_people" href="find_people.html">exchangelib.services.find_people</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="exchangelib.services.get_attachment" href="get_attachment.html">exchangelib.services.get_attachment</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="exchangelib.services.get_delegate" href="get_delegate.html">exchangelib.services.get_delegate</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="exchangelib.services.get_folder" href="get_folder.html">exchangelib.services.get_folder</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="exchangelib.services.get_item" href="get_item.html">exchangelib.services.get_item</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="exchangelib.services.get_mail_tips" href="get_mail_tips.html">exchangelib.services.get_mail_tips</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="exchangelib.services.get_persona" href="get_persona.html">exchangelib.services.get_persona</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="exchangelib.services.get_room_lists" href="get_room_lists.html">exchangelib.services.get_room_lists</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="exchangelib.services.get_rooms" href="get_rooms.html">exchangelib.services.get_rooms</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="exchangelib.services.get_searchable_mailboxes" href="get_searchable_mailboxes.html">exchangelib.services.get_searchable_mailboxes</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="exchangelib.services.get_server_time_zones" href="get_server_time_zones.html">exchangelib.services.get_server_time_zones</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="exchangelib.services.get_user_availability" href="get_user_availability.html">exchangelib.services.get_user_availability</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="exchangelib.services.get_user_oof_settings" href="get_user_oof_settings.html">exchangelib.services.get_user_oof_settings</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="exchangelib.services.move_item" href="move_item.html">exchangelib.services.move_item</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="exchangelib.services.resolve_names" href="resolve_names.html">exchangelib.services.resolve_names</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="exchangelib.services.send_item" href="send_item.html">exchangelib.services.send_item</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="exchangelib.services.set_user_oof_settings" href="set_user_oof_settings.html">exchangelib.services.set_user_oof_settings</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="exchangelib.services.update_folder" href="update_folder.html">exchangelib.services.update_folder</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="exchangelib.services.update_item" href="update_item.html">exchangelib.services.update_item</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="exchangelib.services.upload_items" href="upload_items.html">exchangelib.services.upload_items</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="exchangelib.services.ArchiveItem"><code class="flex name class">
<span>class <span class="ident">ArchiveItem</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>MSDN: <a href="https://docs.microsoft.com/en-us/exchange/client-developer/web-service-reference/archiveitem-operation">https://docs.microsoft.com/en-us/exchange/client-developer/web-service-reference/archiveitem-operation</a></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ArchiveItem(EWSAccountService, EWSPooledMixIn):
    &#34;&#34;&#34;MSDN: https://docs.microsoft.com/en-us/exchange/client-developer/web-service-reference/archiveitem-operation&#34;&#34;&#34;
    SERVICE_NAME = &#39;ArchiveItem&#39;
    element_container_name = &#39;{%s}Items&#39; % MNS

    def call(self, items, to_folder):
        &#34;&#34;&#34;Move a list of items to a specific folder in the archive mailbox.

        Args:
          items: a list of (id, changekey) tuples or Item objects
          to_folder:

        Returns:
          None

        &#34;&#34;&#34;
        if self.protocol.version.build &lt; EXCHANGE_2013:
            raise NotImplementedError(&#39;%s is only supported for Exchange 2013 servers and later&#39; % self.SERVICE_NAME)
        return self._pool_requests(payload_func=self.get_payload, **dict(items=items, to_folder=to_folder))

    def _get_elements_in_response(self, response):
        for msg in response:
            container_or_exc = self._get_element_container(message=msg, name=self.element_container_name)
            if isinstance(container_or_exc, (bool, Exception)):
                yield container_or_exc
            else:
                if len(container_or_exc):
                    raise ValueError(&#39;Unexpected container length: %s&#39; % container_or_exc)
                yield True

    def get_payload(self, items, to_folder):
        archiveitem = create_element(&#39;m:%s&#39; % self.SERVICE_NAME)
        folder_id = create_folder_ids_element(tag=&#39;m:ArchiveSourceFolderId&#39;, folders=[to_folder],
                                              version=self.account.version)
        item_ids = create_item_ids_element(items=items, version=self.account.version)
        archiveitem.append(folder_id)
        archiveitem.append(item_ids)
        return archiveitem</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="exchangelib.services.common.EWSAccountService" href="common.html#exchangelib.services.common.EWSAccountService">EWSAccountService</a></li>
<li><a title="exchangelib.services.common.EWSPooledMixIn" href="common.html#exchangelib.services.common.EWSPooledMixIn">EWSPooledMixIn</a></li>
<li><a title="exchangelib.services.common.EWSService" href="common.html#exchangelib.services.common.EWSService">EWSService</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="exchangelib.services.ArchiveItem.SERVICE_NAME"><code class="name">var <span class="ident">SERVICE_NAME</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.services.ArchiveItem.element_container_name"><code class="name">var <span class="ident">element_container_name</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="exchangelib.services.ArchiveItem.call"><code class="name flex">
<span>def <span class="ident">call</span></span>(<span>self, items, to_folder)</span>
</code></dt>
<dd>
<div class="desc"><p>Move a list of items to a specific folder in the archive mailbox.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>items</code></strong></dt>
<dd>a list of (id, changekey) tuples or Item objects</dd>
</dl>
<p>to_folder:</p>
<h2 id="returns">Returns</h2>
<p>None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def call(self, items, to_folder):
    &#34;&#34;&#34;Move a list of items to a specific folder in the archive mailbox.

    Args:
      items: a list of (id, changekey) tuples or Item objects
      to_folder:

    Returns:
      None

    &#34;&#34;&#34;
    if self.protocol.version.build &lt; EXCHANGE_2013:
        raise NotImplementedError(&#39;%s is only supported for Exchange 2013 servers and later&#39; % self.SERVICE_NAME)
    return self._pool_requests(payload_func=self.get_payload, **dict(items=items, to_folder=to_folder))</code></pre>
</details>
</dd>
<dt id="exchangelib.services.ArchiveItem.get_payload"><code class="name flex">
<span>def <span class="ident">get_payload</span></span>(<span>self, items, to_folder)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_payload(self, items, to_folder):
    archiveitem = create_element(&#39;m:%s&#39; % self.SERVICE_NAME)
    folder_id = create_folder_ids_element(tag=&#39;m:ArchiveSourceFolderId&#39;, folders=[to_folder],
                                          version=self.account.version)
    item_ids = create_item_ids_element(items=items, version=self.account.version)
    archiveitem.append(folder_id)
    archiveitem.append(item_ids)
    return archiveitem</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="exchangelib.services.common.EWSAccountService" href="common.html#exchangelib.services.common.EWSAccountService">EWSAccountService</a></b></code>:
<ul class="hlist">
<li><code><a title="exchangelib.services.common.EWSAccountService.WARNINGS_TO_CATCH_IN_RESPONSE" href="common.html#exchangelib.services.common.EWSService.WARNINGS_TO_CATCH_IN_RESPONSE">WARNINGS_TO_CATCH_IN_RESPONSE</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="exchangelib.services.ConvertId"><code class="flex name class">
<span>class <span class="ident">ConvertId</span></span>
<span>(</span><span>protocol, chunk_size=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Takes a list of IDs to convert. Returns a list of converted IDs or exception instances, in the same order as the
input list.</p>
<p>MSDN: <a href="https://docs.microsoft.com/en-us/exchange/client-developer/web-service-reference/convertid-operation">https://docs.microsoft.com/en-us/exchange/client-developer/web-service-reference/convertid-operation</a></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ConvertId(EWSPooledMixIn):
    &#34;&#34;&#34;Takes a list of IDs to convert. Returns a list of converted IDs or exception instances, in the same order as the
    input list.

    MSDN: https://docs.microsoft.com/en-us/exchange/client-developer/web-service-reference/convertid-operation

    &#34;&#34;&#34;
    SERVICE_NAME = &#39;ConvertId&#39;

    def call(self, items, destination_format):
        if self.protocol.version.build &lt; EXCHANGE_2007_SP1:
            raise NotImplementedError(
                &#39;%r is only supported for Exchange 2007 SP1 servers and later&#39; % self.SERVICE_NAME)
        from ..properties import ID_FORMATS
        if destination_format not in ID_FORMATS:
            raise ValueError(&#34;&#39;destination_format&#39; %r must be one of %s&#34; % (destination_format, ID_FORMATS))
        return self._pool_requests(payload_func=self.get_payload, **dict(
            items=items,
            destination_format=destination_format,
        ))

    def get_payload(self, items, destination_format):
        from ..properties import AlternateId, AlternatePublicFolderId, AlternatePublicFolderItemId
        supported_item_classes = AlternateId, AlternatePublicFolderId, AlternatePublicFolderItemId
        convertid = create_element(&#39;m:%s&#39; % self.SERVICE_NAME, attrs=dict(DestinationFormat=destination_format))
        item_ids = create_element(&#39;m:SourceIds&#39;)
        for item in items:
            log.debug(&#39;Collecting item %s&#39;, item)
            if not isinstance(item, supported_item_classes):
                raise ValueError(&#34;&#39;item&#39; value %r must be an instance of %r&#34; % (item, supported_item_classes))
            set_xml_value(item_ids, item, version=self.protocol.version)
        if not len(item_ids):
            raise ValueError(&#39;&#34;items&#34; must not be empty&#39;)
        convertid.append(item_ids)
        return convertid

    def _get_elements_in_container(self, container):
        # We may have other elements in here, e.g. &#39;ResponseCode&#39;. Filter away those.
        from ..properties import AlternateId, AlternatePublicFolderId, AlternatePublicFolderItemId
        return container.findall(AlternateId.response_tag()) \
            + container.findall(AlternatePublicFolderId.response_tag()) \
            + container.findall(AlternatePublicFolderItemId.response_tag())

    def _get_element_container(self, message, response_message=None, name=None):
        # There is no element container
        return message</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="exchangelib.services.common.EWSPooledMixIn" href="common.html#exchangelib.services.common.EWSPooledMixIn">EWSPooledMixIn</a></li>
<li><a title="exchangelib.services.common.EWSService" href="common.html#exchangelib.services.common.EWSService">EWSService</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="exchangelib.services.ConvertId.SERVICE_NAME"><code class="name">var <span class="ident">SERVICE_NAME</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="exchangelib.services.ConvertId.call"><code class="name flex">
<span>def <span class="ident">call</span></span>(<span>self, items, destination_format)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def call(self, items, destination_format):
    if self.protocol.version.build &lt; EXCHANGE_2007_SP1:
        raise NotImplementedError(
            &#39;%r is only supported for Exchange 2007 SP1 servers and later&#39; % self.SERVICE_NAME)
    from ..properties import ID_FORMATS
    if destination_format not in ID_FORMATS:
        raise ValueError(&#34;&#39;destination_format&#39; %r must be one of %s&#34; % (destination_format, ID_FORMATS))
    return self._pool_requests(payload_func=self.get_payload, **dict(
        items=items,
        destination_format=destination_format,
    ))</code></pre>
</details>
</dd>
<dt id="exchangelib.services.ConvertId.get_payload"><code class="name flex">
<span>def <span class="ident">get_payload</span></span>(<span>self, items, destination_format)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_payload(self, items, destination_format):
    from ..properties import AlternateId, AlternatePublicFolderId, AlternatePublicFolderItemId
    supported_item_classes = AlternateId, AlternatePublicFolderId, AlternatePublicFolderItemId
    convertid = create_element(&#39;m:%s&#39; % self.SERVICE_NAME, attrs=dict(DestinationFormat=destination_format))
    item_ids = create_element(&#39;m:SourceIds&#39;)
    for item in items:
        log.debug(&#39;Collecting item %s&#39;, item)
        if not isinstance(item, supported_item_classes):
            raise ValueError(&#34;&#39;item&#39; value %r must be an instance of %r&#34; % (item, supported_item_classes))
        set_xml_value(item_ids, item, version=self.protocol.version)
    if not len(item_ids):
        raise ValueError(&#39;&#34;items&#34; must not be empty&#39;)
    convertid.append(item_ids)
    return convertid</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="exchangelib.services.common.EWSPooledMixIn" href="common.html#exchangelib.services.common.EWSPooledMixIn">EWSPooledMixIn</a></b></code>:
<ul class="hlist">
<li><code><a title="exchangelib.services.common.EWSPooledMixIn.WARNINGS_TO_CATCH_IN_RESPONSE" href="common.html#exchangelib.services.common.EWSService.WARNINGS_TO_CATCH_IN_RESPONSE">WARNINGS_TO_CATCH_IN_RESPONSE</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="exchangelib.services.CopyItem"><code class="flex name class">
<span>class <span class="ident">CopyItem</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>MSDN: <a href="https://docs.microsoft.com/en-us/exchange/client-developer/web-service-reference/copyitem-operation">https://docs.microsoft.com/en-us/exchange/client-developer/web-service-reference/copyitem-operation</a></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class CopyItem(move_item.MoveItem):
    &#34;&#34;&#34;MSDN: https://docs.microsoft.com/en-us/exchange/client-developer/web-service-reference/copyitem-operation&#34;&#34;&#34;
    SERVICE_NAME = &#39;CopyItem&#39;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="exchangelib.services.move_item.MoveItem" href="move_item.html#exchangelib.services.move_item.MoveItem">MoveItem</a></li>
<li><a title="exchangelib.services.common.EWSAccountService" href="common.html#exchangelib.services.common.EWSAccountService">EWSAccountService</a></li>
<li><a title="exchangelib.services.common.EWSService" href="common.html#exchangelib.services.common.EWSService">EWSService</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="exchangelib.services.CopyItem.SERVICE_NAME"><code class="name">var <span class="ident">SERVICE_NAME</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="exchangelib.services.move_item.MoveItem" href="move_item.html#exchangelib.services.move_item.MoveItem">MoveItem</a></b></code>:
<ul class="hlist">
<li><code><a title="exchangelib.services.move_item.MoveItem.WARNINGS_TO_CATCH_IN_RESPONSE" href="common.html#exchangelib.services.common.EWSService.WARNINGS_TO_CATCH_IN_RESPONSE">WARNINGS_TO_CATCH_IN_RESPONSE</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="exchangelib.services.CreateAttachment"><code class="flex name class">
<span>class <span class="ident">CreateAttachment</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>MSDN: <a href="https://docs.microsoft.com/en-us/exchange/client-developer/web-service-reference/createattachment-operation">https://docs.microsoft.com/en-us/exchange/client-developer/web-service-reference/createattachment-operation</a></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class CreateAttachment(EWSAccountService):
    &#34;&#34;&#34;MSDN: https://docs.microsoft.com/en-us/exchange/client-developer/web-service-reference/createattachment-operation
    &#34;&#34;&#34;
    SERVICE_NAME = &#39;CreateAttachment&#39;
    element_container_name = &#39;{%s}Attachments&#39; % MNS

    def call(self, parent_item, items):
        return self._get_elements(payload=self.get_payload(
            parent_item=parent_item,
            items=items,
        ))

    def get_payload(self, parent_item, items):
        from ..properties import ParentItemId
        from ..items import BaseItem
        payload = create_element(&#39;m:%s&#39; % self.SERVICE_NAME)
        version = self.account.version
        if isinstance(parent_item, BaseItem):
            # to_item_id() would convert this to a normal ItemId, but the service wants a ParentItemId
            parent_item = ParentItemId(parent_item.id, parent_item.changekey)
        set_xml_value(payload, to_item_id(parent_item, ParentItemId, version=version), version=version)
        attachments = create_element(&#39;m:Attachments&#39;)
        for item in items:
            set_xml_value(attachments, item, version=self.account.version)
        if not len(attachments):
            raise ValueError(&#39;&#34;items&#34; must not be empty&#39;)
        payload.append(attachments)
        return payload</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="exchangelib.services.common.EWSAccountService" href="common.html#exchangelib.services.common.EWSAccountService">EWSAccountService</a></li>
<li><a title="exchangelib.services.common.EWSService" href="common.html#exchangelib.services.common.EWSService">EWSService</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="exchangelib.services.CreateAttachment.SERVICE_NAME"><code class="name">var <span class="ident">SERVICE_NAME</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.services.CreateAttachment.element_container_name"><code class="name">var <span class="ident">element_container_name</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="exchangelib.services.CreateAttachment.call"><code class="name flex">
<span>def <span class="ident">call</span></span>(<span>self, parent_item, items)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def call(self, parent_item, items):
    return self._get_elements(payload=self.get_payload(
        parent_item=parent_item,
        items=items,
    ))</code></pre>
</details>
</dd>
<dt id="exchangelib.services.CreateAttachment.get_payload"><code class="name flex">
<span>def <span class="ident">get_payload</span></span>(<span>self, parent_item, items)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_payload(self, parent_item, items):
    from ..properties import ParentItemId
    from ..items import BaseItem
    payload = create_element(&#39;m:%s&#39; % self.SERVICE_NAME)
    version = self.account.version
    if isinstance(parent_item, BaseItem):
        # to_item_id() would convert this to a normal ItemId, but the service wants a ParentItemId
        parent_item = ParentItemId(parent_item.id, parent_item.changekey)
    set_xml_value(payload, to_item_id(parent_item, ParentItemId, version=version), version=version)
    attachments = create_element(&#39;m:Attachments&#39;)
    for item in items:
        set_xml_value(attachments, item, version=self.account.version)
    if not len(attachments):
        raise ValueError(&#39;&#34;items&#34; must not be empty&#39;)
    payload.append(attachments)
    return payload</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="exchangelib.services.common.EWSAccountService" href="common.html#exchangelib.services.common.EWSAccountService">EWSAccountService</a></b></code>:
<ul class="hlist">
<li><code><a title="exchangelib.services.common.EWSAccountService.WARNINGS_TO_CATCH_IN_RESPONSE" href="common.html#exchangelib.services.common.EWSService.WARNINGS_TO_CATCH_IN_RESPONSE">WARNINGS_TO_CATCH_IN_RESPONSE</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="exchangelib.services.CreateFolder"><code class="flex name class">
<span>class <span class="ident">CreateFolder</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>MSDN: <a href="https://docs.microsoft.com/en-us/exchange/client-developer/web-service-reference/createfolder-operation">https://docs.microsoft.com/en-us/exchange/client-developer/web-service-reference/createfolder-operation</a></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class CreateFolder(EWSAccountService):
    &#34;&#34;&#34;MSDN: https://docs.microsoft.com/en-us/exchange/client-developer/web-service-reference/createfolder-operation&#34;&#34;&#34;
    SERVICE_NAME = &#39;CreateFolder&#39;
    element_container_name = &#39;{%s}Folders&#39; % MNS

    def call(self, parent_folder, folders):
        # We can&#39;t easily find the correct folder class from the returned XML. Instead, return objects with the same
        # class as the folder instance it was requested with.
        folders_list = list(folders)  # Convert to a list, in case &#39;folders&#39; is a generator
        for folder, elem in zip(folders_list, self._get_elements(payload=self.get_payload(
                parent_folder=parent_folder, folders=folders
        ))):
            yield parse_folder_elem(elem=elem, folder=folder, account=self.account)

    def get_payload(self, parent_folder, folders):
        create_folder = create_element(&#39;m:%s&#39; % self.SERVICE_NAME)
        parentfolderid = create_element(&#39;m:ParentFolderId&#39;)
        set_xml_value(parentfolderid, parent_folder, version=self.account.version)
        set_xml_value(create_folder, parentfolderid, version=self.account.version)
        folder_ids = create_folder_ids_element(tag=&#39;m:Folders&#39;, folders=folders, version=self.account.version)
        create_folder.append(folder_ids)
        return create_folder</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="exchangelib.services.common.EWSAccountService" href="common.html#exchangelib.services.common.EWSAccountService">EWSAccountService</a></li>
<li><a title="exchangelib.services.common.EWSService" href="common.html#exchangelib.services.common.EWSService">EWSService</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="exchangelib.services.CreateFolder.SERVICE_NAME"><code class="name">var <span class="ident">SERVICE_NAME</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.services.CreateFolder.element_container_name"><code class="name">var <span class="ident">element_container_name</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="exchangelib.services.CreateFolder.call"><code class="name flex">
<span>def <span class="ident">call</span></span>(<span>self, parent_folder, folders)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def call(self, parent_folder, folders):
    # We can&#39;t easily find the correct folder class from the returned XML. Instead, return objects with the same
    # class as the folder instance it was requested with.
    folders_list = list(folders)  # Convert to a list, in case &#39;folders&#39; is a generator
    for folder, elem in zip(folders_list, self._get_elements(payload=self.get_payload(
            parent_folder=parent_folder, folders=folders
    ))):
        yield parse_folder_elem(elem=elem, folder=folder, account=self.account)</code></pre>
</details>
</dd>
<dt id="exchangelib.services.CreateFolder.get_payload"><code class="name flex">
<span>def <span class="ident">get_payload</span></span>(<span>self, parent_folder, folders)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_payload(self, parent_folder, folders):
    create_folder = create_element(&#39;m:%s&#39; % self.SERVICE_NAME)
    parentfolderid = create_element(&#39;m:ParentFolderId&#39;)
    set_xml_value(parentfolderid, parent_folder, version=self.account.version)
    set_xml_value(create_folder, parentfolderid, version=self.account.version)
    folder_ids = create_folder_ids_element(tag=&#39;m:Folders&#39;, folders=folders, version=self.account.version)
    create_folder.append(folder_ids)
    return create_folder</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="exchangelib.services.common.EWSAccountService" href="common.html#exchangelib.services.common.EWSAccountService">EWSAccountService</a></b></code>:
<ul class="hlist">
<li><code><a title="exchangelib.services.common.EWSAccountService.WARNINGS_TO_CATCH_IN_RESPONSE" href="common.html#exchangelib.services.common.EWSService.WARNINGS_TO_CATCH_IN_RESPONSE">WARNINGS_TO_CATCH_IN_RESPONSE</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="exchangelib.services.CreateItem"><code class="flex name class">
<span>class <span class="ident">CreateItem</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Takes folder and a list of items. Returns result of creation as a list of tuples (success[True|False],
errormessage), in the same order as the input list.</p>
<p>MSDN: <a href="https://docs.microsoft.com/en-us/exchange/client-developer/web-service-reference/createitem">https://docs.microsoft.com/en-us/exchange/client-developer/web-service-reference/createitem</a></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class CreateItem(EWSAccountService, EWSPooledMixIn):
    &#34;&#34;&#34;Takes folder and a list of items. Returns result of creation as a list of tuples (success[True|False],
    errormessage), in the same order as the input list.

    MSDN: https://docs.microsoft.com/en-us/exchange/client-developer/web-service-reference/createitem

    &#34;&#34;&#34;
    SERVICE_NAME = &#39;CreateItem&#39;
    element_container_name = &#39;{%s}Items&#39; % MNS

    def call(self, items, folder, message_disposition, send_meeting_invitations):
        from ..folders import BaseFolder, FolderId, DistinguishedFolderId
        from ..items import SAVE_ONLY, SEND_AND_SAVE_COPY, SEND_ONLY, SEND_MEETING_INVITATIONS_CHOICES, \
            MESSAGE_DISPOSITION_CHOICES
        if message_disposition not in MESSAGE_DISPOSITION_CHOICES:
            raise ValueError(&#34;&#39;message_disposition&#39; %s must be one of %s&#34; % (
                message_disposition, MESSAGE_DISPOSITION_CHOICES
            ))
        if send_meeting_invitations not in SEND_MEETING_INVITATIONS_CHOICES:
            raise ValueError(&#34;&#39;send_meeting_invitations&#39; %s must be one of %s&#34; % (
                send_meeting_invitations, SEND_MEETING_INVITATIONS_CHOICES
            ))
        if folder is not None:
            if not isinstance(folder, (BaseFolder, FolderId, DistinguishedFolderId)):
                raise ValueError(&#34;&#39;folder&#39; %r must be a Folder or FolderId instance&#34; % folder)
            if folder.account != self.account:
                raise ValueError(&#39;&#34;Folder must belong to this account&#39;)
        if message_disposition == SAVE_ONLY and folder is None:
            raise AttributeError(&#34;Folder must be supplied when in save-only mode&#34;)
        if message_disposition == SEND_AND_SAVE_COPY and folder is None:
            folder = self.account.sent  # &#39;Sent&#39; is default EWS behaviour
        if message_disposition == SEND_ONLY and folder is not None:
            raise AttributeError(&#34;Folder must be None in send-ony mode&#34;)
        return self._pool_requests(payload_func=self.get_payload, **dict(
            items=items,
            folder=folder,
            message_disposition=message_disposition,
            send_meeting_invitations=send_meeting_invitations,
        ))

    def get_payload(self, items, folder, message_disposition, send_meeting_invitations):
        &#34;&#34;&#34;Takes a list of Item objects (CalendarItem, Message etc) and returns the XML for a CreateItem request.
        convert items to XML Elements

        MessageDisposition is only applicable to email messages, where it is required.

        SendMeetingInvitations is required for calendar items. It is also applicable to tasks, meeting request
        responses (see
        https://docs.microsoft.com/en-us/exchange/client-developer/web-service-reference/createitem-operation-meeting-request
        ) and sharing
        invitation accepts (see
        https://docs.microsoft.com/en-us/exchange/client-developer/web-service-reference/createitem-acceptsharinginvitation
        ). The last two are not supported yet.

        Args:
          items:
          folder:
          message_disposition:
          send_meeting_invitations:

        &#34;&#34;&#34;
        createitem = create_element(
            &#39;m:%s&#39; % self.SERVICE_NAME,
            attrs=OrderedDict([
                (&#39;MessageDisposition&#39;, message_disposition),
                (&#39;SendMeetingInvitations&#39;, send_meeting_invitations),
            ])
        )
        if folder:
            saveditemfolderid = create_element(&#39;m:SavedItemFolderId&#39;)
            set_xml_value(saveditemfolderid, folder, version=self.account.version)
            createitem.append(saveditemfolderid)
        item_elems = create_element(&#39;m:Items&#39;)
        for item in items:
            log.debug(&#39;Adding item %s&#39;, item)
            set_xml_value(item_elems, item, version=self.account.version)
        if not len(item_elems):
            raise ValueError(&#39;&#34;items&#34; must not be empty&#39;)
        createitem.append(item_elems)
        return createitem</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="exchangelib.services.common.EWSAccountService" href="common.html#exchangelib.services.common.EWSAccountService">EWSAccountService</a></li>
<li><a title="exchangelib.services.common.EWSPooledMixIn" href="common.html#exchangelib.services.common.EWSPooledMixIn">EWSPooledMixIn</a></li>
<li><a title="exchangelib.services.common.EWSService" href="common.html#exchangelib.services.common.EWSService">EWSService</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="exchangelib.services.CreateItem.SERVICE_NAME"><code class="name">var <span class="ident">SERVICE_NAME</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.services.CreateItem.element_container_name"><code class="name">var <span class="ident">element_container_name</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="exchangelib.services.CreateItem.call"><code class="name flex">
<span>def <span class="ident">call</span></span>(<span>self, items, folder, message_disposition, send_meeting_invitations)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def call(self, items, folder, message_disposition, send_meeting_invitations):
    from ..folders import BaseFolder, FolderId, DistinguishedFolderId
    from ..items import SAVE_ONLY, SEND_AND_SAVE_COPY, SEND_ONLY, SEND_MEETING_INVITATIONS_CHOICES, \
        MESSAGE_DISPOSITION_CHOICES
    if message_disposition not in MESSAGE_DISPOSITION_CHOICES:
        raise ValueError(&#34;&#39;message_disposition&#39; %s must be one of %s&#34; % (
            message_disposition, MESSAGE_DISPOSITION_CHOICES
        ))
    if send_meeting_invitations not in SEND_MEETING_INVITATIONS_CHOICES:
        raise ValueError(&#34;&#39;send_meeting_invitations&#39; %s must be one of %s&#34; % (
            send_meeting_invitations, SEND_MEETING_INVITATIONS_CHOICES
        ))
    if folder is not None:
        if not isinstance(folder, (BaseFolder, FolderId, DistinguishedFolderId)):
            raise ValueError(&#34;&#39;folder&#39; %r must be a Folder or FolderId instance&#34; % folder)
        if folder.account != self.account:
            raise ValueError(&#39;&#34;Folder must belong to this account&#39;)
    if message_disposition == SAVE_ONLY and folder is None:
        raise AttributeError(&#34;Folder must be supplied when in save-only mode&#34;)
    if message_disposition == SEND_AND_SAVE_COPY and folder is None:
        folder = self.account.sent  # &#39;Sent&#39; is default EWS behaviour
    if message_disposition == SEND_ONLY and folder is not None:
        raise AttributeError(&#34;Folder must be None in send-ony mode&#34;)
    return self._pool_requests(payload_func=self.get_payload, **dict(
        items=items,
        folder=folder,
        message_disposition=message_disposition,
        send_meeting_invitations=send_meeting_invitations,
    ))</code></pre>
</details>
</dd>
<dt id="exchangelib.services.CreateItem.get_payload"><code class="name flex">
<span>def <span class="ident">get_payload</span></span>(<span>self, items, folder, message_disposition, send_meeting_invitations)</span>
</code></dt>
<dd>
<div class="desc"><p>Takes a list of Item objects (CalendarItem, Message etc) and returns the XML for a CreateItem request.
convert items to XML Elements</p>
<p>MessageDisposition is only applicable to email messages, where it is required.</p>
<p>SendMeetingInvitations is required for calendar items. It is also applicable to tasks, meeting request
responses (see
<a href="https://docs.microsoft.com/en-us/exchange/client-developer/web-service-reference/createitem-operation-meeting-request">https://docs.microsoft.com/en-us/exchange/client-developer/web-service-reference/createitem-operation-meeting-request</a>
) and sharing
invitation accepts (see
<a href="https://docs.microsoft.com/en-us/exchange/client-developer/web-service-reference/createitem-acceptsharinginvitation">https://docs.microsoft.com/en-us/exchange/client-developer/web-service-reference/createitem-acceptsharinginvitation</a>
). The last two are not supported yet.</p>
<h2 id="args">Args</h2>
<p>items:
folder:
message_disposition:
send_meeting_invitations:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_payload(self, items, folder, message_disposition, send_meeting_invitations):
    &#34;&#34;&#34;Takes a list of Item objects (CalendarItem, Message etc) and returns the XML for a CreateItem request.
    convert items to XML Elements

    MessageDisposition is only applicable to email messages, where it is required.

    SendMeetingInvitations is required for calendar items. It is also applicable to tasks, meeting request
    responses (see
    https://docs.microsoft.com/en-us/exchange/client-developer/web-service-reference/createitem-operation-meeting-request
    ) and sharing
    invitation accepts (see
    https://docs.microsoft.com/en-us/exchange/client-developer/web-service-reference/createitem-acceptsharinginvitation
    ). The last two are not supported yet.

    Args:
      items:
      folder:
      message_disposition:
      send_meeting_invitations:

    &#34;&#34;&#34;
    createitem = create_element(
        &#39;m:%s&#39; % self.SERVICE_NAME,
        attrs=OrderedDict([
            (&#39;MessageDisposition&#39;, message_disposition),
            (&#39;SendMeetingInvitations&#39;, send_meeting_invitations),
        ])
    )
    if folder:
        saveditemfolderid = create_element(&#39;m:SavedItemFolderId&#39;)
        set_xml_value(saveditemfolderid, folder, version=self.account.version)
        createitem.append(saveditemfolderid)
    item_elems = create_element(&#39;m:Items&#39;)
    for item in items:
        log.debug(&#39;Adding item %s&#39;, item)
        set_xml_value(item_elems, item, version=self.account.version)
    if not len(item_elems):
        raise ValueError(&#39;&#34;items&#34; must not be empty&#39;)
    createitem.append(item_elems)
    return createitem</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="exchangelib.services.common.EWSAccountService" href="common.html#exchangelib.services.common.EWSAccountService">EWSAccountService</a></b></code>:
<ul class="hlist">
<li><code><a title="exchangelib.services.common.EWSAccountService.WARNINGS_TO_CATCH_IN_RESPONSE" href="common.html#exchangelib.services.common.EWSService.WARNINGS_TO_CATCH_IN_RESPONSE">WARNINGS_TO_CATCH_IN_RESPONSE</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="exchangelib.services.DeleteAttachment"><code class="flex name class">
<span>class <span class="ident">DeleteAttachment</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>MSDN: <a href="https://docs.microsoft.com/en-us/exchange/client-developer/web-service-reference/deleteattachment-operation">https://docs.microsoft.com/en-us/exchange/client-developer/web-service-reference/deleteattachment-operation</a></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class DeleteAttachment(EWSAccountService):
    &#34;&#34;&#34;MSDN: https://docs.microsoft.com/en-us/exchange/client-developer/web-service-reference/deleteattachment-operation
    &#34;&#34;&#34;
    SERVICE_NAME = &#39;DeleteAttachment&#39;

    def call(self, items):
        return self._get_elements(payload=self.get_payload(
            items=items,
        ))

    def _get_element_container(self, message, response_message=None, name=None):
        # DeleteAttachment returns RootItemIds directly beneath DeleteAttachmentResponseMessage. Collect the elements
        # and make our own fake container.
        from ..properties import RootItemId
        res = super()._get_element_container(
            message=message, response_message=response_message, name=name
        )
        if not res:
            return res
        fake_elem = create_element(&#39;FakeContainer&#39;)
        for elem in message.findall(RootItemId.response_tag()):
            fake_elem.append(elem)
        return fake_elem

    def get_payload(self, items):
        payload = create_element(&#39;m:%s&#39; % self.SERVICE_NAME)
        attachment_ids = create_attachment_ids_element(items=items, version=self.account.version)
        payload.append(attachment_ids)
        return payload</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="exchangelib.services.common.EWSAccountService" href="common.html#exchangelib.services.common.EWSAccountService">EWSAccountService</a></li>
<li><a title="exchangelib.services.common.EWSService" href="common.html#exchangelib.services.common.EWSService">EWSService</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="exchangelib.services.DeleteAttachment.SERVICE_NAME"><code class="name">var <span class="ident">SERVICE_NAME</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="exchangelib.services.DeleteAttachment.call"><code class="name flex">
<span>def <span class="ident">call</span></span>(<span>self, items)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def call(self, items):
    return self._get_elements(payload=self.get_payload(
        items=items,
    ))</code></pre>
</details>
</dd>
<dt id="exchangelib.services.DeleteAttachment.get_payload"><code class="name flex">
<span>def <span class="ident">get_payload</span></span>(<span>self, items)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_payload(self, items):
    payload = create_element(&#39;m:%s&#39; % self.SERVICE_NAME)
    attachment_ids = create_attachment_ids_element(items=items, version=self.account.version)
    payload.append(attachment_ids)
    return payload</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="exchangelib.services.common.EWSAccountService" href="common.html#exchangelib.services.common.EWSAccountService">EWSAccountService</a></b></code>:
<ul class="hlist">
<li><code><a title="exchangelib.services.common.EWSAccountService.WARNINGS_TO_CATCH_IN_RESPONSE" href="common.html#exchangelib.services.common.EWSService.WARNINGS_TO_CATCH_IN_RESPONSE">WARNINGS_TO_CATCH_IN_RESPONSE</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="exchangelib.services.DeleteFolder"><code class="flex name class">
<span>class <span class="ident">DeleteFolder</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>MSDN: <a href="https://docs.microsoft.com/en-us/exchange/client-developer/web-service-reference/deletefolder-operation">https://docs.microsoft.com/en-us/exchange/client-developer/web-service-reference/deletefolder-operation</a></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class DeleteFolder(EWSAccountService):
    &#34;&#34;&#34;MSDN: https://docs.microsoft.com/en-us/exchange/client-developer/web-service-reference/deletefolder-operation&#34;&#34;&#34;
    SERVICE_NAME = &#39;DeleteFolder&#39;
    element_container_name = None  # DeleteFolder doesn&#39;t return a response object, just status in XML attrs

    def call(self, folders, delete_type):
        return self._get_elements(payload=self.get_payload(folders=folders, delete_type=delete_type))

    def get_payload(self, folders, delete_type):
        deletefolder = create_element(&#39;m:%s&#39; % self.SERVICE_NAME, attrs=dict(DeleteType=delete_type))
        folder_ids = create_folder_ids_element(tag=&#39;m:FolderIds&#39;, folders=folders, version=self.account.version)
        deletefolder.append(folder_ids)
        return deletefolder</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="exchangelib.services.common.EWSAccountService" href="common.html#exchangelib.services.common.EWSAccountService">EWSAccountService</a></li>
<li><a title="exchangelib.services.common.EWSService" href="common.html#exchangelib.services.common.EWSService">EWSService</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="exchangelib.services.DeleteFolder.SERVICE_NAME"><code class="name">var <span class="ident">SERVICE_NAME</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.services.DeleteFolder.element_container_name"><code class="name">var <span class="ident">element_container_name</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="exchangelib.services.DeleteFolder.call"><code class="name flex">
<span>def <span class="ident">call</span></span>(<span>self, folders, delete_type)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def call(self, folders, delete_type):
    return self._get_elements(payload=self.get_payload(folders=folders, delete_type=delete_type))</code></pre>
</details>
</dd>
<dt id="exchangelib.services.DeleteFolder.get_payload"><code class="name flex">
<span>def <span class="ident">get_payload</span></span>(<span>self, folders, delete_type)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_payload(self, folders, delete_type):
    deletefolder = create_element(&#39;m:%s&#39; % self.SERVICE_NAME, attrs=dict(DeleteType=delete_type))
    folder_ids = create_folder_ids_element(tag=&#39;m:FolderIds&#39;, folders=folders, version=self.account.version)
    deletefolder.append(folder_ids)
    return deletefolder</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="exchangelib.services.common.EWSAccountService" href="common.html#exchangelib.services.common.EWSAccountService">EWSAccountService</a></b></code>:
<ul class="hlist">
<li><code><a title="exchangelib.services.common.EWSAccountService.WARNINGS_TO_CATCH_IN_RESPONSE" href="common.html#exchangelib.services.common.EWSService.WARNINGS_TO_CATCH_IN_RESPONSE">WARNINGS_TO_CATCH_IN_RESPONSE</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="exchangelib.services.DeleteItem"><code class="flex name class">
<span>class <span class="ident">DeleteItem</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Takes a folder and a list of (id, changekey) tuples. Returns result of deletion as a list of tuples
(success[True|False], errormessage), in the same order as the input list.</p>
<p>MSDN: <a href="https://docs.microsoft.com/en-us/exchange/client-developer/web-service-reference/deleteitem">https://docs.microsoft.com/en-us/exchange/client-developer/web-service-reference/deleteitem</a></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class DeleteItem(EWSAccountService, EWSPooledMixIn):
    &#34;&#34;&#34;Takes a folder and a list of (id, changekey) tuples. Returns result of deletion as a list of tuples
    (success[True|False], errormessage), in the same order as the input list.

    MSDN: https://docs.microsoft.com/en-us/exchange/client-developer/web-service-reference/deleteitem

    &#34;&#34;&#34;
    SERVICE_NAME = &#39;DeleteItem&#39;
    element_container_name = None  # DeleteItem doesn&#39;t return a response object, just status in XML attrs

    def call(self, items, delete_type, send_meeting_cancellations, affected_task_occurrences, suppress_read_receipts):
        from ..items import DELETE_TYPE_CHOICES, SEND_MEETING_CANCELLATIONS_CHOICES, AFFECTED_TASK_OCCURRENCES_CHOICES
        if delete_type not in DELETE_TYPE_CHOICES:
            raise ValueError(&#34;&#39;delete_type&#39; %s must be one of %s&#34; % (
                delete_type, DELETE_TYPE_CHOICES
            ))
        if send_meeting_cancellations not in SEND_MEETING_CANCELLATIONS_CHOICES:
            raise ValueError(&#34;&#39;send_meeting_cancellations&#39; %s must be one of %s&#34; % (
                send_meeting_cancellations, SEND_MEETING_CANCELLATIONS_CHOICES
            ))
        if affected_task_occurrences not in AFFECTED_TASK_OCCURRENCES_CHOICES:
            raise ValueError(&#34;&#39;affected_task_occurrences&#39; %s must be one of %s&#34; % (
                affected_task_occurrences, AFFECTED_TASK_OCCURRENCES_CHOICES
            ))
        if suppress_read_receipts not in (True, False):
            raise ValueError(&#34;&#39;suppress_read_receipts&#39; %s must be True or False&#34; % suppress_read_receipts)
        return self._pool_requests(payload_func=self.get_payload, **dict(
            items=items,
            delete_type=delete_type,
            send_meeting_cancellations=send_meeting_cancellations,
            affected_task_occurrences=affected_task_occurrences,
            suppress_read_receipts=suppress_read_receipts,
        ))

    def get_payload(self, items, delete_type, send_meeting_cancellations, affected_task_occurrences,
                    suppress_read_receipts):
        # Takes a list of (id, changekey) tuples or Item objects and returns the XML for a DeleteItem request.
        if self.account.version.build &gt;= EXCHANGE_2013_SP1:
            deleteitem = create_element(
                &#39;m:%s&#39; % self.SERVICE_NAME,
                attrs=OrderedDict([
                    (&#39;DeleteType&#39;, delete_type),
                    (&#39;SendMeetingCancellations&#39;, send_meeting_cancellations),
                    (&#39;AffectedTaskOccurrences&#39;, affected_task_occurrences),
                    (&#39;SuppressReadReceipts&#39;, &#39;true&#39; if suppress_read_receipts else &#39;false&#39;),
                ])
            )
        else:
            deleteitem = create_element(
                &#39;m:%s&#39; % self.SERVICE_NAME,
                attrs=OrderedDict([
                    (&#39;DeleteType&#39;, delete_type),
                    (&#39;SendMeetingCancellations&#39;, send_meeting_cancellations),
                    (&#39;AffectedTaskOccurrences&#39;, affected_task_occurrences),
                 ])
            )

        item_ids = create_item_ids_element(items=items, version=self.account.version)
        deleteitem.append(item_ids)
        return deleteitem</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="exchangelib.services.common.EWSAccountService" href="common.html#exchangelib.services.common.EWSAccountService">EWSAccountService</a></li>
<li><a title="exchangelib.services.common.EWSPooledMixIn" href="common.html#exchangelib.services.common.EWSPooledMixIn">EWSPooledMixIn</a></li>
<li><a title="exchangelib.services.common.EWSService" href="common.html#exchangelib.services.common.EWSService">EWSService</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="exchangelib.services.DeleteItem.SERVICE_NAME"><code class="name">var <span class="ident">SERVICE_NAME</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.services.DeleteItem.element_container_name"><code class="name">var <span class="ident">element_container_name</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="exchangelib.services.DeleteItem.call"><code class="name flex">
<span>def <span class="ident">call</span></span>(<span>self, items, delete_type, send_meeting_cancellations, affected_task_occurrences, suppress_read_receipts)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def call(self, items, delete_type, send_meeting_cancellations, affected_task_occurrences, suppress_read_receipts):
    from ..items import DELETE_TYPE_CHOICES, SEND_MEETING_CANCELLATIONS_CHOICES, AFFECTED_TASK_OCCURRENCES_CHOICES
    if delete_type not in DELETE_TYPE_CHOICES:
        raise ValueError(&#34;&#39;delete_type&#39; %s must be one of %s&#34; % (
            delete_type, DELETE_TYPE_CHOICES
        ))
    if send_meeting_cancellations not in SEND_MEETING_CANCELLATIONS_CHOICES:
        raise ValueError(&#34;&#39;send_meeting_cancellations&#39; %s must be one of %s&#34; % (
            send_meeting_cancellations, SEND_MEETING_CANCELLATIONS_CHOICES
        ))
    if affected_task_occurrences not in AFFECTED_TASK_OCCURRENCES_CHOICES:
        raise ValueError(&#34;&#39;affected_task_occurrences&#39; %s must be one of %s&#34; % (
            affected_task_occurrences, AFFECTED_TASK_OCCURRENCES_CHOICES
        ))
    if suppress_read_receipts not in (True, False):
        raise ValueError(&#34;&#39;suppress_read_receipts&#39; %s must be True or False&#34; % suppress_read_receipts)
    return self._pool_requests(payload_func=self.get_payload, **dict(
        items=items,
        delete_type=delete_type,
        send_meeting_cancellations=send_meeting_cancellations,
        affected_task_occurrences=affected_task_occurrences,
        suppress_read_receipts=suppress_read_receipts,
    ))</code></pre>
</details>
</dd>
<dt id="exchangelib.services.DeleteItem.get_payload"><code class="name flex">
<span>def <span class="ident">get_payload</span></span>(<span>self, items, delete_type, send_meeting_cancellations, affected_task_occurrences, suppress_read_receipts)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_payload(self, items, delete_type, send_meeting_cancellations, affected_task_occurrences,
                suppress_read_receipts):
    # Takes a list of (id, changekey) tuples or Item objects and returns the XML for a DeleteItem request.
    if self.account.version.build &gt;= EXCHANGE_2013_SP1:
        deleteitem = create_element(
            &#39;m:%s&#39; % self.SERVICE_NAME,
            attrs=OrderedDict([
                (&#39;DeleteType&#39;, delete_type),
                (&#39;SendMeetingCancellations&#39;, send_meeting_cancellations),
                (&#39;AffectedTaskOccurrences&#39;, affected_task_occurrences),
                (&#39;SuppressReadReceipts&#39;, &#39;true&#39; if suppress_read_receipts else &#39;false&#39;),
            ])
        )
    else:
        deleteitem = create_element(
            &#39;m:%s&#39; % self.SERVICE_NAME,
            attrs=OrderedDict([
                (&#39;DeleteType&#39;, delete_type),
                (&#39;SendMeetingCancellations&#39;, send_meeting_cancellations),
                (&#39;AffectedTaskOccurrences&#39;, affected_task_occurrences),
             ])
        )

    item_ids = create_item_ids_element(items=items, version=self.account.version)
    deleteitem.append(item_ids)
    return deleteitem</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="exchangelib.services.common.EWSAccountService" href="common.html#exchangelib.services.common.EWSAccountService">EWSAccountService</a></b></code>:
<ul class="hlist">
<li><code><a title="exchangelib.services.common.EWSAccountService.WARNINGS_TO_CATCH_IN_RESPONSE" href="common.html#exchangelib.services.common.EWSService.WARNINGS_TO_CATCH_IN_RESPONSE">WARNINGS_TO_CATCH_IN_RESPONSE</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="exchangelib.services.EmptyFolder"><code class="flex name class">
<span>class <span class="ident">EmptyFolder</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>MSDN: <a href="https://docs.microsoft.com/en-us/exchange/client-developer/web-service-reference/emptyfolder">https://docs.microsoft.com/en-us/exchange/client-developer/web-service-reference/emptyfolder</a></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class EmptyFolder(EWSAccountService):
    &#34;&#34;&#34;MSDN: https://docs.microsoft.com/en-us/exchange/client-developer/web-service-reference/emptyfolder&#34;&#34;&#34;
    SERVICE_NAME = &#39;EmptyFolder&#39;
    element_container_name = None  # EmptyFolder doesn&#39;t return a response object, just status in XML attrs

    def call(self, folders, delete_type, delete_sub_folders):
        return self._get_elements(payload=self.get_payload(folders=folders, delete_type=delete_type,
                                                           delete_sub_folders=delete_sub_folders))

    def get_payload(self, folders, delete_type, delete_sub_folders):
        emptyfolder = create_element(
            &#39;m:%s&#39; % self.SERVICE_NAME,
            attrs=OrderedDict([
                (&#39;DeleteType&#39;, delete_type),
                (&#39;DeleteSubFolders&#39;, &#39;true&#39; if delete_sub_folders else &#39;false&#39;),
            ])
        )
        folder_ids = create_folder_ids_element(tag=&#39;m:FolderIds&#39;, folders=folders, version=self.account.version)
        emptyfolder.append(folder_ids)
        return emptyfolder</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="exchangelib.services.common.EWSAccountService" href="common.html#exchangelib.services.common.EWSAccountService">EWSAccountService</a></li>
<li><a title="exchangelib.services.common.EWSService" href="common.html#exchangelib.services.common.EWSService">EWSService</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="exchangelib.services.EmptyFolder.SERVICE_NAME"><code class="name">var <span class="ident">SERVICE_NAME</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.services.EmptyFolder.element_container_name"><code class="name">var <span class="ident">element_container_name</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="exchangelib.services.EmptyFolder.call"><code class="name flex">
<span>def <span class="ident">call</span></span>(<span>self, folders, delete_type, delete_sub_folders)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def call(self, folders, delete_type, delete_sub_folders):
    return self._get_elements(payload=self.get_payload(folders=folders, delete_type=delete_type,
                                                       delete_sub_folders=delete_sub_folders))</code></pre>
</details>
</dd>
<dt id="exchangelib.services.EmptyFolder.get_payload"><code class="name flex">
<span>def <span class="ident">get_payload</span></span>(<span>self, folders, delete_type, delete_sub_folders)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_payload(self, folders, delete_type, delete_sub_folders):
    emptyfolder = create_element(
        &#39;m:%s&#39; % self.SERVICE_NAME,
        attrs=OrderedDict([
            (&#39;DeleteType&#39;, delete_type),
            (&#39;DeleteSubFolders&#39;, &#39;true&#39; if delete_sub_folders else &#39;false&#39;),
        ])
    )
    folder_ids = create_folder_ids_element(tag=&#39;m:FolderIds&#39;, folders=folders, version=self.account.version)
    emptyfolder.append(folder_ids)
    return emptyfolder</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="exchangelib.services.common.EWSAccountService" href="common.html#exchangelib.services.common.EWSAccountService">EWSAccountService</a></b></code>:
<ul class="hlist">
<li><code><a title="exchangelib.services.common.EWSAccountService.WARNINGS_TO_CATCH_IN_RESPONSE" href="common.html#exchangelib.services.common.EWSService.WARNINGS_TO_CATCH_IN_RESPONSE">WARNINGS_TO_CATCH_IN_RESPONSE</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="exchangelib.services.ExpandDL"><code class="flex name class">
<span>class <span class="ident">ExpandDL</span></span>
<span>(</span><span>protocol, chunk_size=None)</span>
</code></dt>
<dd>
<div class="desc"><p>MSDN: <a href="https://docs.microsoft.com/en-us/exchange/client-developer/web-service-reference/expanddl-operation">https://docs.microsoft.com/en-us/exchange/client-developer/web-service-reference/expanddl-operation</a></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ExpandDL(EWSService):
    &#34;&#34;&#34;MSDN: https://docs.microsoft.com/en-us/exchange/client-developer/web-service-reference/expanddl-operation&#34;&#34;&#34;
    SERVICE_NAME = &#39;ExpandDL&#39;
    element_container_name = &#39;{%s}DLExpansion&#39; % MNS
    ERRORS_TO_CATCH_IN_RESPONSE = ErrorNameResolutionNoResults
    WARNINGS_TO_IGNORE_IN_RESPONSE = ErrorNameResolutionMultipleResults

    def call(self, distribution_list):
        from ..properties import Mailbox
        elements = self._get_elements(payload=self.get_payload(distribution_list=distribution_list))
        for elem in elements:
            if isinstance(elem, Exception):
                raise elem
            yield Mailbox.from_xml(elem, account=None)

    def get_payload(self, distribution_list):
        payload = create_element(&#39;m:%s&#39; % self.SERVICE_NAME)
        set_xml_value(payload, distribution_list, version=self.protocol.version)
        return payload</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="exchangelib.services.common.EWSService" href="common.html#exchangelib.services.common.EWSService">EWSService</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="exchangelib.services.ExpandDL.ERRORS_TO_CATCH_IN_RESPONSE"><code class="name">var <span class="ident">ERRORS_TO_CATCH_IN_RESPONSE</span></code></dt>
<dd>
<div class="desc"><p>Global error type within this module.</p></div>
</dd>
<dt id="exchangelib.services.ExpandDL.SERVICE_NAME"><code class="name">var <span class="ident">SERVICE_NAME</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.services.ExpandDL.WARNINGS_TO_IGNORE_IN_RESPONSE"><code class="name">var <span class="ident">WARNINGS_TO_IGNORE_IN_RESPONSE</span></code></dt>
<dd>
<div class="desc"><p>Global error type within this module.</p></div>
</dd>
<dt id="exchangelib.services.ExpandDL.element_container_name"><code class="name">var <span class="ident">element_container_name</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="exchangelib.services.ExpandDL.call"><code class="name flex">
<span>def <span class="ident">call</span></span>(<span>self, distribution_list)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def call(self, distribution_list):
    from ..properties import Mailbox
    elements = self._get_elements(payload=self.get_payload(distribution_list=distribution_list))
    for elem in elements:
        if isinstance(elem, Exception):
            raise elem
        yield Mailbox.from_xml(elem, account=None)</code></pre>
</details>
</dd>
<dt id="exchangelib.services.ExpandDL.get_payload"><code class="name flex">
<span>def <span class="ident">get_payload</span></span>(<span>self, distribution_list)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_payload(self, distribution_list):
    payload = create_element(&#39;m:%s&#39; % self.SERVICE_NAME)
    set_xml_value(payload, distribution_list, version=self.protocol.version)
    return payload</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="exchangelib.services.common.EWSService" href="common.html#exchangelib.services.common.EWSService">EWSService</a></b></code>:
<ul class="hlist">
<li><code><a title="exchangelib.services.common.EWSService.WARNINGS_TO_CATCH_IN_RESPONSE" href="common.html#exchangelib.services.common.EWSService.WARNINGS_TO_CATCH_IN_RESPONSE">WARNINGS_TO_CATCH_IN_RESPONSE</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="exchangelib.services.ExportItems"><code class="flex name class">
<span>class <span class="ident">ExportItems</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>MSDN: <a href="https://docs.microsoft.com/en-us/exchange/client-developer/web-service-reference/exportitems-operation">https://docs.microsoft.com/en-us/exchange/client-developer/web-service-reference/exportitems-operation</a></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ExportItems(EWSAccountService, EWSPooledMixIn):
    &#34;&#34;&#34;MSDN: https://docs.microsoft.com/en-us/exchange/client-developer/web-service-reference/exportitems-operation&#34;&#34;&#34;
    ERRORS_TO_CATCH_IN_RESPONSE = ResponseMessageError
    SERVICE_NAME = &#39;ExportItems&#39;
    element_container_name = &#39;{%s}Data&#39; % MNS

    def call(self, items):
        return self._pool_requests(payload_func=self.get_payload, **dict(items=items))

    def get_payload(self, items):
        exportitems = create_element(&#39;m:%s&#39; % self.SERVICE_NAME)
        item_ids = create_item_ids_element(items=items, version=self.account.version)
        exportitems.append(item_ids)
        return exportitems

    # We need to override this since ExportItemsResponseMessage is formatted a
    #  little bit differently. Namely, all we want is the 64bit string in the
    #  Data tag.
    def _get_elements_in_container(self, container):
        return [container.text]</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="exchangelib.services.common.EWSAccountService" href="common.html#exchangelib.services.common.EWSAccountService">EWSAccountService</a></li>
<li><a title="exchangelib.services.common.EWSPooledMixIn" href="common.html#exchangelib.services.common.EWSPooledMixIn">EWSPooledMixIn</a></li>
<li><a title="exchangelib.services.common.EWSService" href="common.html#exchangelib.services.common.EWSService">EWSService</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="exchangelib.services.ExportItems.ERRORS_TO_CATCH_IN_RESPONSE"><code class="name">var <span class="ident">ERRORS_TO_CATCH_IN_RESPONSE</span></code></dt>
<dd>
<div class="desc"><p>Global error type within this module.</p></div>
</dd>
<dt id="exchangelib.services.ExportItems.SERVICE_NAME"><code class="name">var <span class="ident">SERVICE_NAME</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.services.ExportItems.element_container_name"><code class="name">var <span class="ident">element_container_name</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="exchangelib.services.ExportItems.call"><code class="name flex">
<span>def <span class="ident">call</span></span>(<span>self, items)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def call(self, items):
    return self._pool_requests(payload_func=self.get_payload, **dict(items=items))</code></pre>
</details>
</dd>
<dt id="exchangelib.services.ExportItems.get_payload"><code class="name flex">
<span>def <span class="ident">get_payload</span></span>(<span>self, items)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_payload(self, items):
    exportitems = create_element(&#39;m:%s&#39; % self.SERVICE_NAME)
    item_ids = create_item_ids_element(items=items, version=self.account.version)
    exportitems.append(item_ids)
    return exportitems</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="exchangelib.services.common.EWSAccountService" href="common.html#exchangelib.services.common.EWSAccountService">EWSAccountService</a></b></code>:
<ul class="hlist">
<li><code><a title="exchangelib.services.common.EWSAccountService.WARNINGS_TO_CATCH_IN_RESPONSE" href="common.html#exchangelib.services.common.EWSService.WARNINGS_TO_CATCH_IN_RESPONSE">WARNINGS_TO_CATCH_IN_RESPONSE</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="exchangelib.services.FindFolder"><code class="flex name class">
<span>class <span class="ident">FindFolder</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>MSDN: <a href="https://docs.microsoft.com/en-us/exchange/client-developer/web-service-reference/findfolder">https://docs.microsoft.com/en-us/exchange/client-developer/web-service-reference/findfolder</a></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class FindFolder(EWSFolderService, PagingEWSMixIn):
    &#34;&#34;&#34;MSDN: https://docs.microsoft.com/en-us/exchange/client-developer/web-service-reference/findfolder&#34;&#34;&#34;
    SERVICE_NAME = &#39;FindFolder&#39;
    element_container_name = &#39;{%s}Folders&#39; % TNS

    def call(self, additional_fields, restriction, shape, depth, max_items, offset):
        &#34;&#34;&#34;Find subfolders of a folder.

        Args:
          additional_fields: the extra fields that should be returned with the folder, as FieldPath objects
          restriction: Restriction object that defines the filters for the query
          shape: The set of attributes to return
          depth: How deep in the folder structure to search for folders
          max_items: The maximum number of items to return
          offset: the offset relative to the first item in the item collection. Usually 0.

        Returns:
          XML elements for the matching folders

        &#34;&#34;&#34;
        from ..folders import Folder
        roots = {f.root for f in self.folders}
        if len(roots) != 1:
            raise ValueError(&#39;FindFolder must be called with folders in the same root hierarchy (%r)&#39; % roots)
        root = roots.pop()
        for elem in self._paged_call(payload_func=self.get_payload, max_items=max_items, **dict(
            additional_fields=additional_fields,
            restriction=restriction,
            shape=shape,
            depth=depth,
            page_size=self.chunk_size,
            offset=offset,
        )):
            if isinstance(elem, Exception):
                yield elem
                continue
            yield Folder.from_xml_with_root(elem=elem, root=root)

    def get_payload(self, additional_fields, restriction, shape, depth, page_size, offset=0):
        findfolder = create_element(&#39;m:%s&#39; % self.SERVICE_NAME, attrs=dict(Traversal=depth))
        foldershape = create_shape_element(
            tag=&#39;m:FolderShape&#39;, shape=shape, additional_fields=additional_fields, version=self.account.version
        )
        findfolder.append(foldershape)
        if self.account.version.build &gt;= EXCHANGE_2010:
            indexedpageviewitem = create_element(
                &#39;m:IndexedPageFolderView&#39;,
                attrs=OrderedDict([
                    (&#39;MaxEntriesReturned&#39;, str(page_size)),
                    (&#39;Offset&#39;, str(offset)),
                    (&#39;BasePoint&#39;, &#39;Beginning&#39;),
                ])
            )
            findfolder.append(indexedpageviewitem)
        else:
            if offset != 0:
                raise ValueError(&#39;Offsets are only supported from Exchange 2010&#39;)
        if restriction:
            findfolder.append(restriction.to_xml(version=self.account.version))
        parentfolderids = create_element(&#39;m:ParentFolderIds&#39;)
        set_xml_value(parentfolderids, self.folders, version=self.account.version)
        findfolder.append(parentfolderids)
        return findfolder</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="exchangelib.services.common.EWSFolderService" href="common.html#exchangelib.services.common.EWSFolderService">EWSFolderService</a></li>
<li><a title="exchangelib.services.common.EWSAccountService" href="common.html#exchangelib.services.common.EWSAccountService">EWSAccountService</a></li>
<li><a title="exchangelib.services.common.PagingEWSMixIn" href="common.html#exchangelib.services.common.PagingEWSMixIn">PagingEWSMixIn</a></li>
<li><a title="exchangelib.services.common.EWSService" href="common.html#exchangelib.services.common.EWSService">EWSService</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="exchangelib.services.FindFolder.SERVICE_NAME"><code class="name">var <span class="ident">SERVICE_NAME</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.services.FindFolder.element_container_name"><code class="name">var <span class="ident">element_container_name</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="exchangelib.services.FindFolder.call"><code class="name flex">
<span>def <span class="ident">call</span></span>(<span>self, additional_fields, restriction, shape, depth, max_items, offset)</span>
</code></dt>
<dd>
<div class="desc"><p>Find subfolders of a folder.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>additional_fields</code></strong></dt>
<dd>the extra fields that should be returned with the folder, as FieldPath objects</dd>
<dt><strong><code>restriction</code></strong></dt>
<dd>Restriction object that defines the filters for the query</dd>
<dt><strong><code>shape</code></strong></dt>
<dd>The set of attributes to return</dd>
<dt><strong><code>depth</code></strong></dt>
<dd>How deep in the folder structure to search for folders</dd>
<dt><strong><code>max_items</code></strong></dt>
<dd>The maximum number of items to return</dd>
<dt><strong><code>offset</code></strong></dt>
<dd>the offset relative to the first item in the item collection. Usually 0.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>XML elements for the matching folders</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def call(self, additional_fields, restriction, shape, depth, max_items, offset):
    &#34;&#34;&#34;Find subfolders of a folder.

    Args:
      additional_fields: the extra fields that should be returned with the folder, as FieldPath objects
      restriction: Restriction object that defines the filters for the query
      shape: The set of attributes to return
      depth: How deep in the folder structure to search for folders
      max_items: The maximum number of items to return
      offset: the offset relative to the first item in the item collection. Usually 0.

    Returns:
      XML elements for the matching folders

    &#34;&#34;&#34;
    from ..folders import Folder
    roots = {f.root for f in self.folders}
    if len(roots) != 1:
        raise ValueError(&#39;FindFolder must be called with folders in the same root hierarchy (%r)&#39; % roots)
    root = roots.pop()
    for elem in self._paged_call(payload_func=self.get_payload, max_items=max_items, **dict(
        additional_fields=additional_fields,
        restriction=restriction,
        shape=shape,
        depth=depth,
        page_size=self.chunk_size,
        offset=offset,
    )):
        if isinstance(elem, Exception):
            yield elem
            continue
        yield Folder.from_xml_with_root(elem=elem, root=root)</code></pre>
</details>
</dd>
<dt id="exchangelib.services.FindFolder.get_payload"><code class="name flex">
<span>def <span class="ident">get_payload</span></span>(<span>self, additional_fields, restriction, shape, depth, page_size, offset=0)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_payload(self, additional_fields, restriction, shape, depth, page_size, offset=0):
    findfolder = create_element(&#39;m:%s&#39; % self.SERVICE_NAME, attrs=dict(Traversal=depth))
    foldershape = create_shape_element(
        tag=&#39;m:FolderShape&#39;, shape=shape, additional_fields=additional_fields, version=self.account.version
    )
    findfolder.append(foldershape)
    if self.account.version.build &gt;= EXCHANGE_2010:
        indexedpageviewitem = create_element(
            &#39;m:IndexedPageFolderView&#39;,
            attrs=OrderedDict([
                (&#39;MaxEntriesReturned&#39;, str(page_size)),
                (&#39;Offset&#39;, str(offset)),
                (&#39;BasePoint&#39;, &#39;Beginning&#39;),
            ])
        )
        findfolder.append(indexedpageviewitem)
    else:
        if offset != 0:
            raise ValueError(&#39;Offsets are only supported from Exchange 2010&#39;)
    if restriction:
        findfolder.append(restriction.to_xml(version=self.account.version))
    parentfolderids = create_element(&#39;m:ParentFolderIds&#39;)
    set_xml_value(parentfolderids, self.folders, version=self.account.version)
    findfolder.append(parentfolderids)
    return findfolder</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="exchangelib.services.common.EWSFolderService" href="common.html#exchangelib.services.common.EWSFolderService">EWSFolderService</a></b></code>:
<ul class="hlist">
<li><code><a title="exchangelib.services.common.EWSFolderService.WARNINGS_TO_CATCH_IN_RESPONSE" href="common.html#exchangelib.services.common.EWSService.WARNINGS_TO_CATCH_IN_RESPONSE">WARNINGS_TO_CATCH_IN_RESPONSE</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="exchangelib.services.FindItem"><code class="flex name class">
<span>class <span class="ident">FindItem</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>MSDN: <a href="https://docs.microsoft.com/en-us/exchange/client-developer/web-service-reference/finditem">https://docs.microsoft.com/en-us/exchange/client-developer/web-service-reference/finditem</a></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class FindItem(EWSFolderService, PagingEWSMixIn):
    &#34;&#34;&#34;MSDN: https://docs.microsoft.com/en-us/exchange/client-developer/web-service-reference/finditem&#34;&#34;&#34;
    SERVICE_NAME = &#39;FindItem&#39;
    element_container_name = &#39;{%s}Items&#39; % TNS

    def call(self, additional_fields, restriction, order_fields, shape, query_string, depth, calendar_view, max_items,
             offset):
        &#34;&#34;&#34;Find items in an account.

        Args:
          additional_fields: the extra fields that should be returned with the item, as FieldPath objects
          restriction: a Restriction object for
          order_fields: the fields to sort the results by
          shape: The set of attributes to return
          query_string: a QueryString object
          depth: How deep in the folder structure to search for items
          calendar_view: If set, returns recurring calendar items unfolded
          max_items: the max number of items to return
          offset: the offset relative to the first item in the item collection. Usually 0.

        Returns:
          XML elements for the matching items

        &#34;&#34;&#34;
        return self._paged_call(payload_func=self.get_payload, max_items=max_items, **dict(
            additional_fields=additional_fields,
            restriction=restriction,
            order_fields=order_fields,
            query_string=query_string,
            shape=shape,
            depth=depth,
            calendar_view=calendar_view,
            page_size=self.chunk_size,
            offset=offset,
        ))

    def get_payload(self, additional_fields, restriction, order_fields, query_string, shape, depth, calendar_view,
                    page_size, offset=0):
        finditem = create_element(&#39;m:%s&#39; % self.SERVICE_NAME, attrs=dict(Traversal=depth))
        itemshape = create_shape_element(
            tag=&#39;m:ItemShape&#39;, shape=shape, additional_fields=additional_fields, version=self.account.version
        )
        finditem.append(itemshape)
        if calendar_view is None:
            view_type = create_element(
                &#39;m:IndexedPageItemView&#39;,
                attrs=OrderedDict([
                    (&#39;MaxEntriesReturned&#39;, str(page_size)),
                    (&#39;Offset&#39;, str(offset)),
                    (&#39;BasePoint&#39;, &#39;Beginning&#39;),
                ])
            )
        else:
            view_type = calendar_view.to_xml(version=self.account.version)
        finditem.append(view_type)
        if restriction:
            finditem.append(restriction.to_xml(version=self.account.version))
        if order_fields:
            finditem.append(set_xml_value(
                create_element(&#39;m:SortOrder&#39;),
                order_fields,
                version=self.account.version
            ))
        finditem.append(set_xml_value(
            create_element(&#39;m:ParentFolderIds&#39;),
            self.folders,
            version=self.account.version
        ))
        if query_string:
            finditem.append(query_string.to_xml(version=self.account.version))
        return finditem</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="exchangelib.services.common.EWSFolderService" href="common.html#exchangelib.services.common.EWSFolderService">EWSFolderService</a></li>
<li><a title="exchangelib.services.common.EWSAccountService" href="common.html#exchangelib.services.common.EWSAccountService">EWSAccountService</a></li>
<li><a title="exchangelib.services.common.PagingEWSMixIn" href="common.html#exchangelib.services.common.PagingEWSMixIn">PagingEWSMixIn</a></li>
<li><a title="exchangelib.services.common.EWSService" href="common.html#exchangelib.services.common.EWSService">EWSService</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="exchangelib.services.FindItem.SERVICE_NAME"><code class="name">var <span class="ident">SERVICE_NAME</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.services.FindItem.element_container_name"><code class="name">var <span class="ident">element_container_name</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="exchangelib.services.FindItem.call"><code class="name flex">
<span>def <span class="ident">call</span></span>(<span>self, additional_fields, restriction, order_fields, shape, query_string, depth, calendar_view, max_items, offset)</span>
</code></dt>
<dd>
<div class="desc"><p>Find items in an account.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>additional_fields</code></strong></dt>
<dd>the extra fields that should be returned with the item, as FieldPath objects</dd>
<dt><strong><code>restriction</code></strong></dt>
<dd>a Restriction object for</dd>
<dt><strong><code>order_fields</code></strong></dt>
<dd>the fields to sort the results by</dd>
<dt><strong><code>shape</code></strong></dt>
<dd>The set of attributes to return</dd>
<dt><strong><code>query_string</code></strong></dt>
<dd>a QueryString object</dd>
<dt><strong><code>depth</code></strong></dt>
<dd>How deep in the folder structure to search for items</dd>
<dt><strong><code>calendar_view</code></strong></dt>
<dd>If set, returns recurring calendar items unfolded</dd>
<dt><strong><code>max_items</code></strong></dt>
<dd>the max number of items to return</dd>
<dt><strong><code>offset</code></strong></dt>
<dd>the offset relative to the first item in the item collection. Usually 0.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>XML elements for the matching items</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def call(self, additional_fields, restriction, order_fields, shape, query_string, depth, calendar_view, max_items,
         offset):
    &#34;&#34;&#34;Find items in an account.

    Args:
      additional_fields: the extra fields that should be returned with the item, as FieldPath objects
      restriction: a Restriction object for
      order_fields: the fields to sort the results by
      shape: The set of attributes to return
      query_string: a QueryString object
      depth: How deep in the folder structure to search for items
      calendar_view: If set, returns recurring calendar items unfolded
      max_items: the max number of items to return
      offset: the offset relative to the first item in the item collection. Usually 0.

    Returns:
      XML elements for the matching items

    &#34;&#34;&#34;
    return self._paged_call(payload_func=self.get_payload, max_items=max_items, **dict(
        additional_fields=additional_fields,
        restriction=restriction,
        order_fields=order_fields,
        query_string=query_string,
        shape=shape,
        depth=depth,
        calendar_view=calendar_view,
        page_size=self.chunk_size,
        offset=offset,
    ))</code></pre>
</details>
</dd>
<dt id="exchangelib.services.FindItem.get_payload"><code class="name flex">
<span>def <span class="ident">get_payload</span></span>(<span>self, additional_fields, restriction, order_fields, query_string, shape, depth, calendar_view, page_size, offset=0)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_payload(self, additional_fields, restriction, order_fields, query_string, shape, depth, calendar_view,
                page_size, offset=0):
    finditem = create_element(&#39;m:%s&#39; % self.SERVICE_NAME, attrs=dict(Traversal=depth))
    itemshape = create_shape_element(
        tag=&#39;m:ItemShape&#39;, shape=shape, additional_fields=additional_fields, version=self.account.version
    )
    finditem.append(itemshape)
    if calendar_view is None:
        view_type = create_element(
            &#39;m:IndexedPageItemView&#39;,
            attrs=OrderedDict([
                (&#39;MaxEntriesReturned&#39;, str(page_size)),
                (&#39;Offset&#39;, str(offset)),
                (&#39;BasePoint&#39;, &#39;Beginning&#39;),
            ])
        )
    else:
        view_type = calendar_view.to_xml(version=self.account.version)
    finditem.append(view_type)
    if restriction:
        finditem.append(restriction.to_xml(version=self.account.version))
    if order_fields:
        finditem.append(set_xml_value(
            create_element(&#39;m:SortOrder&#39;),
            order_fields,
            version=self.account.version
        ))
    finditem.append(set_xml_value(
        create_element(&#39;m:ParentFolderIds&#39;),
        self.folders,
        version=self.account.version
    ))
    if query_string:
        finditem.append(query_string.to_xml(version=self.account.version))
    return finditem</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="exchangelib.services.common.EWSFolderService" href="common.html#exchangelib.services.common.EWSFolderService">EWSFolderService</a></b></code>:
<ul class="hlist">
<li><code><a title="exchangelib.services.common.EWSFolderService.WARNINGS_TO_CATCH_IN_RESPONSE" href="common.html#exchangelib.services.common.EWSService.WARNINGS_TO_CATCH_IN_RESPONSE">WARNINGS_TO_CATCH_IN_RESPONSE</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="exchangelib.services.FindPeople"><code class="flex name class">
<span>class <span class="ident">FindPeople</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>MSDN: <a href="https://docs.microsoft.com/en-us/exchange/client-developer/web-service-reference/findpeople-operation">https://docs.microsoft.com/en-us/exchange/client-developer/web-service-reference/findpeople-operation</a></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class FindPeople(EWSAccountService, PagingEWSMixIn):
    &#34;&#34;&#34;MSDN: https://docs.microsoft.com/en-us/exchange/client-developer/web-service-reference/findpeople-operation&#34;&#34;&#34;
    SERVICE_NAME = &#39;FindPeople&#39;
    element_container_name = &#39;{%s}People&#39; % MNS

    def call(self, folder, additional_fields, restriction, order_fields, shape, query_string, depth, max_items, offset):
        &#34;&#34;&#34;Find items in an account.

        Args:
          folder: the Folder object to query
          additional_fields: the extra fields that should be returned with the item, as FieldPath objects
          restriction: a Restriction object for
          order_fields: the fields to sort the results by
          shape: The set of attributes to return
          query_string: a QueryString object
          depth: How deep in the folder structure to search for items
          max_items: the max number of items to return
          offset: the offset relative to the first item in the item collection. Usually 0.

        Returns:
          XML elements for the matching items

        &#34;&#34;&#34;
        from ..items import Persona, ID_ONLY
        personas = self._paged_call(payload_func=self.get_payload, max_items=max_items, **dict(
            folder=folder,
            additional_fields=additional_fields,
            restriction=restriction,
            order_fields=order_fields,
            query_string=query_string,
            shape=shape,
            depth=depth,
            page_size=self.chunk_size,
            offset=offset,
        ))
        if shape == ID_ONLY and additional_fields is None:
            for p in personas:
                yield p if isinstance(p, Exception) else Persona.id_from_xml(p)
        else:
            for p in personas:
                yield p if isinstance(p, Exception) else Persona.from_xml(p, account=self.account)

    def get_payload(self, folder, additional_fields, restriction, order_fields, query_string, shape, depth, page_size,
                    offset=0):
        findpeople = create_element(&#39;m:%s&#39; % self.SERVICE_NAME, attrs=dict(Traversal=depth))
        personashape = create_shape_element(
            tag=&#39;m:PersonaShape&#39;, shape=shape, additional_fields=additional_fields, version=self.account.version
        )
        findpeople.append(personashape)
        view_type = create_element(
            &#39;m:IndexedPageItemView&#39;,
            attrs=OrderedDict([
                (&#39;MaxEntriesReturned&#39;, str(page_size)),
                (&#39;Offset&#39;, str(offset)),
                (&#39;BasePoint&#39;, &#39;Beginning&#39;),
            ])
        )
        findpeople.append(view_type)
        if restriction:
            findpeople.append(restriction.to_xml(version=self.account.version))
        if order_fields:
            findpeople.append(set_xml_value(
                create_element(&#39;m:SortOrder&#39;),
                order_fields,
                version=self.account.version
            ))
        findpeople.append(set_xml_value(
            create_element(&#39;m:ParentFolderId&#39;),
            folder,
            version=self.account.version
        ))
        if query_string:
            findpeople.append(query_string.to_xml(version=self.account.version))
        return findpeople

    def _paged_call(self, payload_func, max_items, **kwargs):
        item_count = kwargs[&#39;offset&#39;]
        while True:
            log.debug(&#39;EWS %s, account %s, service %s: Getting items at offset %s&#39;,
                      self.protocol.service_endpoint, self.account, self.SERVICE_NAME, item_count)
            kwargs[&#39;offset&#39;] = item_count
            payload = payload_func(**kwargs)
            parsed_pages = list(self._get_elements(payload=payload))
            if len(parsed_pages) != 1:
                # We can only query one folder, so there should only be one element in response
                raise MalformedResponseError(&#34;Expected single item in &#39;response&#39;, got %s&#34; % len(parsed_pages))
            rootfolder, total_items = parsed_pages[0]
            if rootfolder is not None:
                container = rootfolder.find(self.element_container_name)
                if container is None:
                    raise MalformedResponseError(&#39;No %s elements in ResponseMessage (%s)&#39; % (
                        self.element_container_name, xml_to_str(rootfolder)))
                for elem in self._get_elements_in_container(container=container):
                    item_count += 1
                    yield elem
                if max_items and item_count &gt;= max_items:
                    log.debug(&#34;&#39;max_items&#39; count reached&#34;)
                    break
            if total_items &lt;= 0 or item_count &gt;= total_items:
                log.debug(&#39;Got all items in view&#39;)
                break

    def _get_page(self, message):
        self._get_element_container(message=message)  # Just raise exceptions
        total_items = int(message.find(&#39;{%s}TotalNumberOfPeopleInView&#39; % MNS).text)
        first_matching = int(message.find(&#39;{%s}FirstMatchingRowIndex&#39; % MNS).text)
        first_loaded = int(message.find(&#39;{%s}FirstLoadedRowIndex&#39; % MNS).text)
        log.debug(&#39;%s: Got page with total items %s, first matching %s, first loaded %s &#39;, self.SERVICE_NAME,
                  total_items, first_matching, first_loaded)
        return message, total_items</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="exchangelib.services.common.EWSAccountService" href="common.html#exchangelib.services.common.EWSAccountService">EWSAccountService</a></li>
<li><a title="exchangelib.services.common.PagingEWSMixIn" href="common.html#exchangelib.services.common.PagingEWSMixIn">PagingEWSMixIn</a></li>
<li><a title="exchangelib.services.common.EWSService" href="common.html#exchangelib.services.common.EWSService">EWSService</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="exchangelib.services.FindPeople.SERVICE_NAME"><code class="name">var <span class="ident">SERVICE_NAME</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.services.FindPeople.element_container_name"><code class="name">var <span class="ident">element_container_name</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="exchangelib.services.FindPeople.call"><code class="name flex">
<span>def <span class="ident">call</span></span>(<span>self, folder, additional_fields, restriction, order_fields, shape, query_string, depth, max_items, offset)</span>
</code></dt>
<dd>
<div class="desc"><p>Find items in an account.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>folder</code></strong></dt>
<dd>the Folder object to query</dd>
<dt><strong><code>additional_fields</code></strong></dt>
<dd>the extra fields that should be returned with the item, as FieldPath objects</dd>
<dt><strong><code>restriction</code></strong></dt>
<dd>a Restriction object for</dd>
<dt><strong><code>order_fields</code></strong></dt>
<dd>the fields to sort the results by</dd>
<dt><strong><code>shape</code></strong></dt>
<dd>The set of attributes to return</dd>
<dt><strong><code>query_string</code></strong></dt>
<dd>a QueryString object</dd>
<dt><strong><code>depth</code></strong></dt>
<dd>How deep in the folder structure to search for items</dd>
<dt><strong><code>max_items</code></strong></dt>
<dd>the max number of items to return</dd>
<dt><strong><code>offset</code></strong></dt>
<dd>the offset relative to the first item in the item collection. Usually 0.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>XML elements for the matching items</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def call(self, folder, additional_fields, restriction, order_fields, shape, query_string, depth, max_items, offset):
    &#34;&#34;&#34;Find items in an account.

    Args:
      folder: the Folder object to query
      additional_fields: the extra fields that should be returned with the item, as FieldPath objects
      restriction: a Restriction object for
      order_fields: the fields to sort the results by
      shape: The set of attributes to return
      query_string: a QueryString object
      depth: How deep in the folder structure to search for items
      max_items: the max number of items to return
      offset: the offset relative to the first item in the item collection. Usually 0.

    Returns:
      XML elements for the matching items

    &#34;&#34;&#34;
    from ..items import Persona, ID_ONLY
    personas = self._paged_call(payload_func=self.get_payload, max_items=max_items, **dict(
        folder=folder,
        additional_fields=additional_fields,
        restriction=restriction,
        order_fields=order_fields,
        query_string=query_string,
        shape=shape,
        depth=depth,
        page_size=self.chunk_size,
        offset=offset,
    ))
    if shape == ID_ONLY and additional_fields is None:
        for p in personas:
            yield p if isinstance(p, Exception) else Persona.id_from_xml(p)
    else:
        for p in personas:
            yield p if isinstance(p, Exception) else Persona.from_xml(p, account=self.account)</code></pre>
</details>
</dd>
<dt id="exchangelib.services.FindPeople.get_payload"><code class="name flex">
<span>def <span class="ident">get_payload</span></span>(<span>self, folder, additional_fields, restriction, order_fields, query_string, shape, depth, page_size, offset=0)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_payload(self, folder, additional_fields, restriction, order_fields, query_string, shape, depth, page_size,
                offset=0):
    findpeople = create_element(&#39;m:%s&#39; % self.SERVICE_NAME, attrs=dict(Traversal=depth))
    personashape = create_shape_element(
        tag=&#39;m:PersonaShape&#39;, shape=shape, additional_fields=additional_fields, version=self.account.version
    )
    findpeople.append(personashape)
    view_type = create_element(
        &#39;m:IndexedPageItemView&#39;,
        attrs=OrderedDict([
            (&#39;MaxEntriesReturned&#39;, str(page_size)),
            (&#39;Offset&#39;, str(offset)),
            (&#39;BasePoint&#39;, &#39;Beginning&#39;),
        ])
    )
    findpeople.append(view_type)
    if restriction:
        findpeople.append(restriction.to_xml(version=self.account.version))
    if order_fields:
        findpeople.append(set_xml_value(
            create_element(&#39;m:SortOrder&#39;),
            order_fields,
            version=self.account.version
        ))
    findpeople.append(set_xml_value(
        create_element(&#39;m:ParentFolderId&#39;),
        folder,
        version=self.account.version
    ))
    if query_string:
        findpeople.append(query_string.to_xml(version=self.account.version))
    return findpeople</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="exchangelib.services.common.EWSAccountService" href="common.html#exchangelib.services.common.EWSAccountService">EWSAccountService</a></b></code>:
<ul class="hlist">
<li><code><a title="exchangelib.services.common.EWSAccountService.WARNINGS_TO_CATCH_IN_RESPONSE" href="common.html#exchangelib.services.common.EWSService.WARNINGS_TO_CATCH_IN_RESPONSE">WARNINGS_TO_CATCH_IN_RESPONSE</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="exchangelib.services.GetAttachment"><code class="flex name class">
<span>class <span class="ident">GetAttachment</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>MSDN: <a href="https://docs.microsoft.com/en-us/exchange/client-developer/web-service-reference/getattachment-operation">https://docs.microsoft.com/en-us/exchange/client-developer/web-service-reference/getattachment-operation</a></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class GetAttachment(EWSAccountService):
    &#34;&#34;&#34;MSDN: https://docs.microsoft.com/en-us/exchange/client-developer/web-service-reference/getattachment-operation&#34;&#34;&#34;
    SERVICE_NAME = &#39;GetAttachment&#39;
    element_container_name = &#39;{%s}Attachments&#39; % MNS
    streaming = True

    def call(self, items, include_mime_content):
        return self._get_elements(payload=self.get_payload(
            items=items,
            include_mime_content=include_mime_content,
        ))

    def get_payload(self, items, include_mime_content):
        payload = create_element(&#39;m:%s&#39; % self.SERVICE_NAME)
        # TODO: Support additional properties of AttachmentShape. See
        # https://docs.microsoft.com/en-us/exchange/client-developer/web-service-reference/attachmentshape
        if include_mime_content:
            attachment_shape = create_element(&#39;m:AttachmentShape&#39;)
            add_xml_child(attachment_shape, &#39;t:IncludeMimeContent&#39;, &#39;true&#39;)
            payload.append(attachment_shape)
        attachment_ids = create_attachment_ids_element(items=items, version=self.account.version)
        payload.append(attachment_ids)
        return payload

    def _update_api_version(self, version_hint, api_version, header, **parse_opts):
        if not parse_opts.get(&#39;stream_file_content&#39;, False):
            return super()._update_api_version(version_hint, api_version, header, **parse_opts)
        # TODO: We&#39;re skipping this part in streaming mode because our streaming parser cannot parse the SOAP header

    @classmethod
    def _get_soap_parts(cls, response, **parse_opts):
        if not parse_opts.get(&#39;stream_file_content&#39;, False):
            return super()._get_soap_parts(response, **parse_opts)

        # Pass the response unaltered. We want to use our custom streaming parser
        return None, response

    @classmethod
    def _get_soap_messages(cls, body, **parse_opts):
        if not parse_opts.get(&#39;stream_file_content&#39;, False):
            return super()._get_soap_messages(body, **parse_opts)

        # &#39;body&#39; is actually the raw response passed on by &#39;_get_soap_parts&#39;
        r = body
        from ..attachments import FileAttachment
        parser = StreamingBase64Parser()
        field = FileAttachment.get_field_by_fieldname(&#39;_content&#39;)
        handler = StreamingContentHandler(parser=parser, ns=field.namespace, element_name=field.field_uri)
        parser.setContentHandler(handler)
        return parser.parse(r)

    def stream_file_content(self, attachment_id):
        # The streaming XML parser can only stream content of one attachment
        payload = self.get_payload(items=[attachment_id], include_mime_content=False)
        try:
            for chunk in self._get_response_xml(payload=payload, stream_file_content=True):
                yield chunk
        except ElementNotFound as enf:
            # When the returned XML does not contain a Content element, ElementNotFound is thrown by parser.parse().
            # Let the non-streaming SOAP parser parse the response and hook into the normal exception handling.
            # Wrap in DummyResponse because _get_soap_payload() expects an iter_content() method.
            response = DummyResponse(url=None, headers=None, request_headers=None, content=enf.data)
            _, body = super()._get_soap_parts(response=response)
            res = super()._get_soap_messages(body=body)
            for e in self._get_elements_in_response(response=res):
                if isinstance(e, Exception):
                    raise e
            # The returned content did not contain any EWS exceptions. Give up and re-raise the original exception.
            raise enf</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="exchangelib.services.common.EWSAccountService" href="common.html#exchangelib.services.common.EWSAccountService">EWSAccountService</a></li>
<li><a title="exchangelib.services.common.EWSService" href="common.html#exchangelib.services.common.EWSService">EWSService</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="exchangelib.services.GetAttachment.SERVICE_NAME"><code class="name">var <span class="ident">SERVICE_NAME</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.services.GetAttachment.element_container_name"><code class="name">var <span class="ident">element_container_name</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.services.GetAttachment.streaming"><code class="name">var <span class="ident">streaming</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="exchangelib.services.GetAttachment.call"><code class="name flex">
<span>def <span class="ident">call</span></span>(<span>self, items, include_mime_content)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def call(self, items, include_mime_content):
    return self._get_elements(payload=self.get_payload(
        items=items,
        include_mime_content=include_mime_content,
    ))</code></pre>
</details>
</dd>
<dt id="exchangelib.services.GetAttachment.get_payload"><code class="name flex">
<span>def <span class="ident">get_payload</span></span>(<span>self, items, include_mime_content)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_payload(self, items, include_mime_content):
    payload = create_element(&#39;m:%s&#39; % self.SERVICE_NAME)
    # TODO: Support additional properties of AttachmentShape. See
    # https://docs.microsoft.com/en-us/exchange/client-developer/web-service-reference/attachmentshape
    if include_mime_content:
        attachment_shape = create_element(&#39;m:AttachmentShape&#39;)
        add_xml_child(attachment_shape, &#39;t:IncludeMimeContent&#39;, &#39;true&#39;)
        payload.append(attachment_shape)
    attachment_ids = create_attachment_ids_element(items=items, version=self.account.version)
    payload.append(attachment_ids)
    return payload</code></pre>
</details>
</dd>
<dt id="exchangelib.services.GetAttachment.stream_file_content"><code class="name flex">
<span>def <span class="ident">stream_file_content</span></span>(<span>self, attachment_id)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def stream_file_content(self, attachment_id):
    # The streaming XML parser can only stream content of one attachment
    payload = self.get_payload(items=[attachment_id], include_mime_content=False)
    try:
        for chunk in self._get_response_xml(payload=payload, stream_file_content=True):
            yield chunk
    except ElementNotFound as enf:
        # When the returned XML does not contain a Content element, ElementNotFound is thrown by parser.parse().
        # Let the non-streaming SOAP parser parse the response and hook into the normal exception handling.
        # Wrap in DummyResponse because _get_soap_payload() expects an iter_content() method.
        response = DummyResponse(url=None, headers=None, request_headers=None, content=enf.data)
        _, body = super()._get_soap_parts(response=response)
        res = super()._get_soap_messages(body=body)
        for e in self._get_elements_in_response(response=res):
            if isinstance(e, Exception):
                raise e
        # The returned content did not contain any EWS exceptions. Give up and re-raise the original exception.
        raise enf</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="exchangelib.services.common.EWSAccountService" href="common.html#exchangelib.services.common.EWSAccountService">EWSAccountService</a></b></code>:
<ul class="hlist">
<li><code><a title="exchangelib.services.common.EWSAccountService.WARNINGS_TO_CATCH_IN_RESPONSE" href="common.html#exchangelib.services.common.EWSService.WARNINGS_TO_CATCH_IN_RESPONSE">WARNINGS_TO_CATCH_IN_RESPONSE</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="exchangelib.services.GetDelegate"><code class="flex name class">
<span>class <span class="ident">GetDelegate</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>MSDN: <a href="https://docs.microsoft.com/en-us/exchange/client-developer/web-service-reference/getdelegate-operation">https://docs.microsoft.com/en-us/exchange/client-developer/web-service-reference/getdelegate-operation</a></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class GetDelegate(EWSAccountService, EWSPooledMixIn):
    &#34;&#34;&#34;MSDN: https://docs.microsoft.com/en-us/exchange/client-developer/web-service-reference/getdelegate-operation&#34;&#34;&#34;
    SERVICE_NAME = &#39;GetDelegate&#39;

    def call(self, user_ids, include_permissions):
        if self.protocol.version.build &lt; EXCHANGE_2007_SP1:
            raise NotImplementedError(
                &#39;%r is only supported for Exchange 2007 SP1 servers and later&#39; % self.SERVICE_NAME)
        from ..properties import DLMailbox, DelegateUser  # The service expects a Mailbox element in the MNS namespace

        if user_ids:
            # Pool requests to avoid arbitrarily large requests when user_ids is huge
            res = self._pool_requests(
                items=user_ids,
                payload_func=self.get_payload,
                **dict(
                    mailbox=DLMailbox(email_address=self.account.primary_smtp_address),
                    include_permissions=include_permissions,
                )
            )
        else:
            # Pooling expects an iterable of items but we have None. Just call _get_elements directly.
            res = self._get_elements(payload=self.get_payload(
                mailbox=DLMailbox(email_address=self.account.primary_smtp_address),
                user_ids=user_ids,
                include_permissions=include_permissions,
            ))

        for elem in res:
            if isinstance(elem, Exception):
                raise elem
            yield DelegateUser.from_xml(elem=elem, account=self.account)

    def get_payload(self, mailbox, user_ids, include_permissions):
        payload = create_element(
            &#39;m:%s&#39; % self.SERVICE_NAME,
            attrs=dict(IncludePermissions=&#39;true&#39; if include_permissions else &#39;false&#39;),
        )
        set_xml_value(payload, mailbox, version=self.protocol.version)
        if user_ids:
            set_xml_value(payload, user_ids, version=self.protocol.version)
        return payload

    def _get_elements_in_container(self, container):
        # We may have other elements in here, e.g. &#39;ResponseCode&#39;. Filter away those.
        from ..properties import DelegateUser
        return container.findall(DelegateUser.response_tag())

    def _get_element_container(self, message, response_message=None, name=None):
        # Do nothing. See self._response_message_tag.
        return message

    @classmethod
    def _response_message_tag(cls):
        # We&#39;re using this in place of self.element_container_name because self._get_soap_messages expects to find
        # elements at this level. We&#39;ll let self._get_element_container do nothing instead.
        return &#39;{%s}DelegateUserResponseMessageType&#39; % MNS</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="exchangelib.services.common.EWSAccountService" href="common.html#exchangelib.services.common.EWSAccountService">EWSAccountService</a></li>
<li><a title="exchangelib.services.common.EWSPooledMixIn" href="common.html#exchangelib.services.common.EWSPooledMixIn">EWSPooledMixIn</a></li>
<li><a title="exchangelib.services.common.EWSService" href="common.html#exchangelib.services.common.EWSService">EWSService</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="exchangelib.services.GetDelegate.SERVICE_NAME"><code class="name">var <span class="ident">SERVICE_NAME</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="exchangelib.services.GetDelegate.call"><code class="name flex">
<span>def <span class="ident">call</span></span>(<span>self, user_ids, include_permissions)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def call(self, user_ids, include_permissions):
    if self.protocol.version.build &lt; EXCHANGE_2007_SP1:
        raise NotImplementedError(
            &#39;%r is only supported for Exchange 2007 SP1 servers and later&#39; % self.SERVICE_NAME)
    from ..properties import DLMailbox, DelegateUser  # The service expects a Mailbox element in the MNS namespace

    if user_ids:
        # Pool requests to avoid arbitrarily large requests when user_ids is huge
        res = self._pool_requests(
            items=user_ids,
            payload_func=self.get_payload,
            **dict(
                mailbox=DLMailbox(email_address=self.account.primary_smtp_address),
                include_permissions=include_permissions,
            )
        )
    else:
        # Pooling expects an iterable of items but we have None. Just call _get_elements directly.
        res = self._get_elements(payload=self.get_payload(
            mailbox=DLMailbox(email_address=self.account.primary_smtp_address),
            user_ids=user_ids,
            include_permissions=include_permissions,
        ))

    for elem in res:
        if isinstance(elem, Exception):
            raise elem
        yield DelegateUser.from_xml(elem=elem, account=self.account)</code></pre>
</details>
</dd>
<dt id="exchangelib.services.GetDelegate.get_payload"><code class="name flex">
<span>def <span class="ident">get_payload</span></span>(<span>self, mailbox, user_ids, include_permissions)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_payload(self, mailbox, user_ids, include_permissions):
    payload = create_element(
        &#39;m:%s&#39; % self.SERVICE_NAME,
        attrs=dict(IncludePermissions=&#39;true&#39; if include_permissions else &#39;false&#39;),
    )
    set_xml_value(payload, mailbox, version=self.protocol.version)
    if user_ids:
        set_xml_value(payload, user_ids, version=self.protocol.version)
    return payload</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="exchangelib.services.common.EWSAccountService" href="common.html#exchangelib.services.common.EWSAccountService">EWSAccountService</a></b></code>:
<ul class="hlist">
<li><code><a title="exchangelib.services.common.EWSAccountService.WARNINGS_TO_CATCH_IN_RESPONSE" href="common.html#exchangelib.services.common.EWSService.WARNINGS_TO_CATCH_IN_RESPONSE">WARNINGS_TO_CATCH_IN_RESPONSE</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="exchangelib.services.GetFolder"><code class="flex name class">
<span>class <span class="ident">GetFolder</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>MSDN: <a href="https://docs.microsoft.com/en-us/exchange/client-developer/web-service-reference/getfolder">https://docs.microsoft.com/en-us/exchange/client-developer/web-service-reference/getfolder</a></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class GetFolder(EWSAccountService, EWSPooledMixIn):
    &#34;&#34;&#34;MSDN: https://docs.microsoft.com/en-us/exchange/client-developer/web-service-reference/getfolder&#34;&#34;&#34;
    SERVICE_NAME = &#39;GetFolder&#39;
    element_container_name = &#39;{%s}Folders&#39; % MNS
    ERRORS_TO_CATCH_IN_RESPONSE = EWSAccountService.ERRORS_TO_CATCH_IN_RESPONSE + (
        ErrorFolderNotFound, ErrorNoPublicFolderReplicaAvailable, ErrorInvalidOperation,
    )

    def call(self, folders, additional_fields, shape):
        &#34;&#34;&#34;Takes a folder ID and returns the full information for that folder.

        Args:
          folders: a list of Folder objects
          additional_fields: the extra fields that should be returned with the folder, as FieldPath objects
          shape: The set of attributes to return

        Returns:
          XML elements for the folders, in stable order

        &#34;&#34;&#34;
        # We can&#39;t easily find the correct folder class from the returned XML. Instead, return objects with the same
        # class as the folder instance it was requested with.
        folders_list = list(folders)  # Convert to a list, in case &#39;folders&#39; is a generator
        for folder, elem in zip(folders_list, self._pool_requests(
            payload_func=self.get_payload,
            items=folders,
            **dict(
                additional_fields=additional_fields,
                shape=shape,
            )
        )):
            yield parse_folder_elem(elem=elem, folder=folder, account=self.account)

    def get_payload(self, folders, additional_fields, shape):
        getfolder = create_element(&#39;m:%s&#39; % self.SERVICE_NAME)
        foldershape = create_shape_element(
            tag=&#39;m:FolderShape&#39;, shape=shape, additional_fields=additional_fields, version=self.account.version
        )
        getfolder.append(foldershape)
        folder_ids = create_folder_ids_element(tag=&#39;m:FolderIds&#39;, folders=folders, version=self.account.version)
        getfolder.append(folder_ids)
        return getfolder</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="exchangelib.services.common.EWSAccountService" href="common.html#exchangelib.services.common.EWSAccountService">EWSAccountService</a></li>
<li><a title="exchangelib.services.common.EWSPooledMixIn" href="common.html#exchangelib.services.common.EWSPooledMixIn">EWSPooledMixIn</a></li>
<li><a title="exchangelib.services.common.EWSService" href="common.html#exchangelib.services.common.EWSService">EWSService</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="exchangelib.services.GetFolder.ERRORS_TO_CATCH_IN_RESPONSE"><code class="name">var <span class="ident">ERRORS_TO_CATCH_IN_RESPONSE</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.services.GetFolder.SERVICE_NAME"><code class="name">var <span class="ident">SERVICE_NAME</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.services.GetFolder.element_container_name"><code class="name">var <span class="ident">element_container_name</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="exchangelib.services.GetFolder.call"><code class="name flex">
<span>def <span class="ident">call</span></span>(<span>self, folders, additional_fields, shape)</span>
</code></dt>
<dd>
<div class="desc"><p>Takes a folder ID and returns the full information for that folder.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>folders</code></strong></dt>
<dd>a list of Folder objects</dd>
<dt><strong><code>additional_fields</code></strong></dt>
<dd>the extra fields that should be returned with the folder, as FieldPath objects</dd>
<dt><strong><code>shape</code></strong></dt>
<dd>The set of attributes to return</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>XML elements for the folders, in stable order</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def call(self, folders, additional_fields, shape):
    &#34;&#34;&#34;Takes a folder ID and returns the full information for that folder.

    Args:
      folders: a list of Folder objects
      additional_fields: the extra fields that should be returned with the folder, as FieldPath objects
      shape: The set of attributes to return

    Returns:
      XML elements for the folders, in stable order

    &#34;&#34;&#34;
    # We can&#39;t easily find the correct folder class from the returned XML. Instead, return objects with the same
    # class as the folder instance it was requested with.
    folders_list = list(folders)  # Convert to a list, in case &#39;folders&#39; is a generator
    for folder, elem in zip(folders_list, self._pool_requests(
        payload_func=self.get_payload,
        items=folders,
        **dict(
            additional_fields=additional_fields,
            shape=shape,
        )
    )):
        yield parse_folder_elem(elem=elem, folder=folder, account=self.account)</code></pre>
</details>
</dd>
<dt id="exchangelib.services.GetFolder.get_payload"><code class="name flex">
<span>def <span class="ident">get_payload</span></span>(<span>self, folders, additional_fields, shape)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_payload(self, folders, additional_fields, shape):
    getfolder = create_element(&#39;m:%s&#39; % self.SERVICE_NAME)
    foldershape = create_shape_element(
        tag=&#39;m:FolderShape&#39;, shape=shape, additional_fields=additional_fields, version=self.account.version
    )
    getfolder.append(foldershape)
    folder_ids = create_folder_ids_element(tag=&#39;m:FolderIds&#39;, folders=folders, version=self.account.version)
    getfolder.append(folder_ids)
    return getfolder</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="exchangelib.services.common.EWSAccountService" href="common.html#exchangelib.services.common.EWSAccountService">EWSAccountService</a></b></code>:
<ul class="hlist">
<li><code><a title="exchangelib.services.common.EWSAccountService.WARNINGS_TO_CATCH_IN_RESPONSE" href="common.html#exchangelib.services.common.EWSService.WARNINGS_TO_CATCH_IN_RESPONSE">WARNINGS_TO_CATCH_IN_RESPONSE</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="exchangelib.services.GetItem"><code class="flex name class">
<span>class <span class="ident">GetItem</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>MSDN: <a href="https://docs.microsoft.com/en-us/exchange/client-developer/web-service-reference/getitem">https://docs.microsoft.com/en-us/exchange/client-developer/web-service-reference/getitem</a></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class GetItem(EWSAccountService, EWSPooledMixIn):
    &#34;&#34;&#34;MSDN: https://docs.microsoft.com/en-us/exchange/client-developer/web-service-reference/getitem&#34;&#34;&#34;
    SERVICE_NAME = &#39;GetItem&#39;
    element_container_name = &#39;{%s}Items&#39; % MNS

    def call(self, items, additional_fields, shape):
        &#34;&#34;&#34;Returns all items in an account that correspond to a list of ID&#39;s, in stable order.

        Args:
          items: a list of (id, changekey) tuples or Item objects
          additional_fields: the extra fields that should be returned with the item, as FieldPath objects
          shape: The shape of returned objects

        Returns:
          XML elements for the items, in stable order

        &#34;&#34;&#34;
        return self._pool_requests(payload_func=self.get_payload, **dict(
            items=items,
            additional_fields=additional_fields,
            shape=shape,
        ))

    def get_payload(self, items, additional_fields, shape):
        getitem = create_element(&#39;m:%s&#39; % self.SERVICE_NAME)
        itemshape = create_shape_element(
            tag=&#39;m:ItemShape&#39;, shape=shape, additional_fields=additional_fields, version=self.account.version
        )
        getitem.append(itemshape)
        item_ids = create_item_ids_element(items=items, version=self.account.version)
        getitem.append(item_ids)
        return getitem</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="exchangelib.services.common.EWSAccountService" href="common.html#exchangelib.services.common.EWSAccountService">EWSAccountService</a></li>
<li><a title="exchangelib.services.common.EWSPooledMixIn" href="common.html#exchangelib.services.common.EWSPooledMixIn">EWSPooledMixIn</a></li>
<li><a title="exchangelib.services.common.EWSService" href="common.html#exchangelib.services.common.EWSService">EWSService</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="exchangelib.services.GetItem.SERVICE_NAME"><code class="name">var <span class="ident">SERVICE_NAME</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.services.GetItem.element_container_name"><code class="name">var <span class="ident">element_container_name</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="exchangelib.services.GetItem.call"><code class="name flex">
<span>def <span class="ident">call</span></span>(<span>self, items, additional_fields, shape)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns all items in an account that correspond to a list of ID's, in stable order.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>items</code></strong></dt>
<dd>a list of (id, changekey) tuples or Item objects</dd>
<dt><strong><code>additional_fields</code></strong></dt>
<dd>the extra fields that should be returned with the item, as FieldPath objects</dd>
<dt><strong><code>shape</code></strong></dt>
<dd>The shape of returned objects</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>XML elements for the items, in stable order</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def call(self, items, additional_fields, shape):
    &#34;&#34;&#34;Returns all items in an account that correspond to a list of ID&#39;s, in stable order.

    Args:
      items: a list of (id, changekey) tuples or Item objects
      additional_fields: the extra fields that should be returned with the item, as FieldPath objects
      shape: The shape of returned objects

    Returns:
      XML elements for the items, in stable order

    &#34;&#34;&#34;
    return self._pool_requests(payload_func=self.get_payload, **dict(
        items=items,
        additional_fields=additional_fields,
        shape=shape,
    ))</code></pre>
</details>
</dd>
<dt id="exchangelib.services.GetItem.get_payload"><code class="name flex">
<span>def <span class="ident">get_payload</span></span>(<span>self, items, additional_fields, shape)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_payload(self, items, additional_fields, shape):
    getitem = create_element(&#39;m:%s&#39; % self.SERVICE_NAME)
    itemshape = create_shape_element(
        tag=&#39;m:ItemShape&#39;, shape=shape, additional_fields=additional_fields, version=self.account.version
    )
    getitem.append(itemshape)
    item_ids = create_item_ids_element(items=items, version=self.account.version)
    getitem.append(item_ids)
    return getitem</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="exchangelib.services.common.EWSAccountService" href="common.html#exchangelib.services.common.EWSAccountService">EWSAccountService</a></b></code>:
<ul class="hlist">
<li><code><a title="exchangelib.services.common.EWSAccountService.WARNINGS_TO_CATCH_IN_RESPONSE" href="common.html#exchangelib.services.common.EWSService.WARNINGS_TO_CATCH_IN_RESPONSE">WARNINGS_TO_CATCH_IN_RESPONSE</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="exchangelib.services.GetMailTips"><code class="flex name class">
<span>class <span class="ident">GetMailTips</span></span>
<span>(</span><span>protocol, chunk_size=None)</span>
</code></dt>
<dd>
<div class="desc"><p>MSDN: <a href="https://docs.microsoft.com/en-us/exchange/client-developer/web-service-reference/getmailtips-operation">https://docs.microsoft.com/en-us/exchange/client-developer/web-service-reference/getmailtips-operation</a></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class GetMailTips(EWSService):
    &#34;&#34;&#34;MSDN: https://docs.microsoft.com/en-us/exchange/client-developer/web-service-reference/getmailtips-operation&#34;&#34;&#34;
    SERVICE_NAME = &#39;GetMailTips&#39;

    def call(self, sending_as, recipients, mail_tips_requested):
        from ..properties import MailTips
        for elem in self._get_elements(payload=self.get_payload(
                sending_as=sending_as,
                recipients=recipients,
                mail_tips_requested=mail_tips_requested,
        )):
            yield MailTips.from_xml(elem=elem, account=None)

    def get_payload(self, sending_as, recipients, mail_tips_requested):
        payload = create_element(&#39;m:%s&#39; % self.SERVICE_NAME)
        set_xml_value(payload, sending_as, version=self.protocol.version)

        recipients_elem = create_element(&#39;m:Recipients&#39;)
        for recipient in recipients:
            set_xml_value(recipients_elem, recipient, version=self.protocol.version)
        if not len(recipients_elem):
            raise ValueError(&#39;&#34;recipients&#34; must not be empty&#39;)
        payload.append(recipients_elem)

        if mail_tips_requested:
            set_xml_value(payload, mail_tips_requested, version=self.protocol.version)
        return payload

    def _get_elements_in_response(self, response):
        from ..properties import MailTips
        for msg in response:
            yield self._get_element_container(message=msg, name=MailTips.response_tag())

    @classmethod
    def _response_message_tag(cls):
        return &#39;{%s}MailTipsResponseMessageType&#39; % MNS</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="exchangelib.services.common.EWSService" href="common.html#exchangelib.services.common.EWSService">EWSService</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="exchangelib.services.GetMailTips.SERVICE_NAME"><code class="name">var <span class="ident">SERVICE_NAME</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="exchangelib.services.GetMailTips.call"><code class="name flex">
<span>def <span class="ident">call</span></span>(<span>self, sending_as, recipients, mail_tips_requested)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def call(self, sending_as, recipients, mail_tips_requested):
    from ..properties import MailTips
    for elem in self._get_elements(payload=self.get_payload(
            sending_as=sending_as,
            recipients=recipients,
            mail_tips_requested=mail_tips_requested,
    )):
        yield MailTips.from_xml(elem=elem, account=None)</code></pre>
</details>
</dd>
<dt id="exchangelib.services.GetMailTips.get_payload"><code class="name flex">
<span>def <span class="ident">get_payload</span></span>(<span>self, sending_as, recipients, mail_tips_requested)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_payload(self, sending_as, recipients, mail_tips_requested):
    payload = create_element(&#39;m:%s&#39; % self.SERVICE_NAME)
    set_xml_value(payload, sending_as, version=self.protocol.version)

    recipients_elem = create_element(&#39;m:Recipients&#39;)
    for recipient in recipients:
        set_xml_value(recipients_elem, recipient, version=self.protocol.version)
    if not len(recipients_elem):
        raise ValueError(&#39;&#34;recipients&#34; must not be empty&#39;)
    payload.append(recipients_elem)

    if mail_tips_requested:
        set_xml_value(payload, mail_tips_requested, version=self.protocol.version)
    return payload</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="exchangelib.services.common.EWSService" href="common.html#exchangelib.services.common.EWSService">EWSService</a></b></code>:
<ul class="hlist">
<li><code><a title="exchangelib.services.common.EWSService.WARNINGS_TO_CATCH_IN_RESPONSE" href="common.html#exchangelib.services.common.EWSService.WARNINGS_TO_CATCH_IN_RESPONSE">WARNINGS_TO_CATCH_IN_RESPONSE</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="exchangelib.services.GetPersona"><code class="flex name class">
<span>class <span class="ident">GetPersona</span></span>
<span>(</span><span>protocol, chunk_size=None)</span>
</code></dt>
<dd>
<div class="desc"><p>MSDN: <a href="https://docs.microsoft.com/en-us/exchange/client-developer/web-service-reference/getpersona-operation">https://docs.microsoft.com/en-us/exchange/client-developer/web-service-reference/getpersona-operation</a></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class GetPersona(EWSService):
    &#34;&#34;&#34;MSDN: https://docs.microsoft.com/en-us/exchange/client-developer/web-service-reference/getpersona-operation&#34;&#34;&#34;
    SERVICE_NAME = &#39;GetPersona&#39;

    def call(self, persona):
        from ..items import Persona
        elements = list(self._get_elements(payload=self.get_payload(persona=persona)))
        if len(elements) != 1:
            raise ValueError(&#39;Expected exactly one element in response&#39;)
        elem = elements[0]
        if isinstance(elem, Exception):
            raise elem
        return Persona.from_xml(elem=elem.find(Persona.response_tag()), account=None)

    def get_payload(self, persona):
        from ..properties import PersonaId
        version = self.protocol.version
        payload = create_element(&#39;m:%s&#39; % self.SERVICE_NAME)
        set_xml_value(payload, to_item_id(persona, PersonaId, version=version), version=version)
        return payload

    @classmethod
    def _response_tag(cls):
        return &#39;{%s}%sResponseMessage&#39; % (MNS, cls.SERVICE_NAME)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="exchangelib.services.common.EWSService" href="common.html#exchangelib.services.common.EWSService">EWSService</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="exchangelib.services.GetPersona.SERVICE_NAME"><code class="name">var <span class="ident">SERVICE_NAME</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="exchangelib.services.GetPersona.call"><code class="name flex">
<span>def <span class="ident">call</span></span>(<span>self, persona)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def call(self, persona):
    from ..items import Persona
    elements = list(self._get_elements(payload=self.get_payload(persona=persona)))
    if len(elements) != 1:
        raise ValueError(&#39;Expected exactly one element in response&#39;)
    elem = elements[0]
    if isinstance(elem, Exception):
        raise elem
    return Persona.from_xml(elem=elem.find(Persona.response_tag()), account=None)</code></pre>
</details>
</dd>
<dt id="exchangelib.services.GetPersona.get_payload"><code class="name flex">
<span>def <span class="ident">get_payload</span></span>(<span>self, persona)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_payload(self, persona):
    from ..properties import PersonaId
    version = self.protocol.version
    payload = create_element(&#39;m:%s&#39; % self.SERVICE_NAME)
    set_xml_value(payload, to_item_id(persona, PersonaId, version=version), version=version)
    return payload</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="exchangelib.services.common.EWSService" href="common.html#exchangelib.services.common.EWSService">EWSService</a></b></code>:
<ul class="hlist">
<li><code><a title="exchangelib.services.common.EWSService.WARNINGS_TO_CATCH_IN_RESPONSE" href="common.html#exchangelib.services.common.EWSService.WARNINGS_TO_CATCH_IN_RESPONSE">WARNINGS_TO_CATCH_IN_RESPONSE</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="exchangelib.services.GetRoomLists"><code class="flex name class">
<span>class <span class="ident">GetRoomLists</span></span>
<span>(</span><span>protocol, chunk_size=None)</span>
</code></dt>
<dd>
<div class="desc"><p>MSDN: <a href="https://docs.microsoft.com/en-us/exchange/client-developer/web-service-reference/getroomlists">https://docs.microsoft.com/en-us/exchange/client-developer/web-service-reference/getroomlists</a></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class GetRoomLists(EWSService):
    &#34;&#34;&#34;MSDN: https://docs.microsoft.com/en-us/exchange/client-developer/web-service-reference/getroomlists&#34;&#34;&#34;
    SERVICE_NAME = &#39;GetRoomLists&#39;
    element_container_name = &#39;{%s}RoomLists&#39; % MNS

    def call(self):
        from ..properties import RoomList

        if self.protocol.version.build &lt; EXCHANGE_2010:
            raise NotImplementedError(&#39;%s is only supported for Exchange 2010 servers and later&#39; % self.SERVICE_NAME)
        for elem in self._get_elements(payload=self.get_payload()):
            yield RoomList.from_xml(elem=elem, account=None)

    def get_payload(self):
        return create_element(&#39;m:%s&#39; % self.SERVICE_NAME)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="exchangelib.services.common.EWSService" href="common.html#exchangelib.services.common.EWSService">EWSService</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="exchangelib.services.GetRoomLists.SERVICE_NAME"><code class="name">var <span class="ident">SERVICE_NAME</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.services.GetRoomLists.element_container_name"><code class="name">var <span class="ident">element_container_name</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="exchangelib.services.GetRoomLists.call"><code class="name flex">
<span>def <span class="ident">call</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def call(self):
    from ..properties import RoomList

    if self.protocol.version.build &lt; EXCHANGE_2010:
        raise NotImplementedError(&#39;%s is only supported for Exchange 2010 servers and later&#39; % self.SERVICE_NAME)
    for elem in self._get_elements(payload=self.get_payload()):
        yield RoomList.from_xml(elem=elem, account=None)</code></pre>
</details>
</dd>
<dt id="exchangelib.services.GetRoomLists.get_payload"><code class="name flex">
<span>def <span class="ident">get_payload</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_payload(self):
    return create_element(&#39;m:%s&#39; % self.SERVICE_NAME)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="exchangelib.services.common.EWSService" href="common.html#exchangelib.services.common.EWSService">EWSService</a></b></code>:
<ul class="hlist">
<li><code><a title="exchangelib.services.common.EWSService.WARNINGS_TO_CATCH_IN_RESPONSE" href="common.html#exchangelib.services.common.EWSService.WARNINGS_TO_CATCH_IN_RESPONSE">WARNINGS_TO_CATCH_IN_RESPONSE</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="exchangelib.services.GetRooms"><code class="flex name class">
<span>class <span class="ident">GetRooms</span></span>
<span>(</span><span>protocol, chunk_size=None)</span>
</code></dt>
<dd>
<div class="desc"><p>MSDN: <a href="https://docs.microsoft.com/en-us/exchange/client-developer/web-service-reference/getrooms">https://docs.microsoft.com/en-us/exchange/client-developer/web-service-reference/getrooms</a></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class GetRooms(EWSService):
    &#34;&#34;&#34;MSDN: https://docs.microsoft.com/en-us/exchange/client-developer/web-service-reference/getrooms&#34;&#34;&#34;
    SERVICE_NAME = &#39;GetRooms&#39;
    element_container_name = &#39;{%s}Rooms&#39; % MNS

    def call(self, roomlist):
        from ..properties import Room
        if self.protocol.version.build &lt; EXCHANGE_2010:
            raise NotImplementedError(&#39;%s is only supported for Exchange 2010 servers and later&#39; % self.SERVICE_NAME)

        for elem in self._get_elements(payload=self.get_payload(roomlist=roomlist)):
            yield Room.from_xml(elem=elem, account=None)

    def get_payload(self, roomlist):
        getrooms = create_element(&#39;m:%s&#39; % self.SERVICE_NAME)
        set_xml_value(getrooms, roomlist, version=self.protocol.version)
        return getrooms</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="exchangelib.services.common.EWSService" href="common.html#exchangelib.services.common.EWSService">EWSService</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="exchangelib.services.GetRooms.SERVICE_NAME"><code class="name">var <span class="ident">SERVICE_NAME</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.services.GetRooms.element_container_name"><code class="name">var <span class="ident">element_container_name</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="exchangelib.services.GetRooms.call"><code class="name flex">
<span>def <span class="ident">call</span></span>(<span>self, roomlist)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def call(self, roomlist):
    from ..properties import Room
    if self.protocol.version.build &lt; EXCHANGE_2010:
        raise NotImplementedError(&#39;%s is only supported for Exchange 2010 servers and later&#39; % self.SERVICE_NAME)

    for elem in self._get_elements(payload=self.get_payload(roomlist=roomlist)):
        yield Room.from_xml(elem=elem, account=None)</code></pre>
</details>
</dd>
<dt id="exchangelib.services.GetRooms.get_payload"><code class="name flex">
<span>def <span class="ident">get_payload</span></span>(<span>self, roomlist)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_payload(self, roomlist):
    getrooms = create_element(&#39;m:%s&#39; % self.SERVICE_NAME)
    set_xml_value(getrooms, roomlist, version=self.protocol.version)
    return getrooms</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="exchangelib.services.common.EWSService" href="common.html#exchangelib.services.common.EWSService">EWSService</a></b></code>:
<ul class="hlist">
<li><code><a title="exchangelib.services.common.EWSService.WARNINGS_TO_CATCH_IN_RESPONSE" href="common.html#exchangelib.services.common.EWSService.WARNINGS_TO_CATCH_IN_RESPONSE">WARNINGS_TO_CATCH_IN_RESPONSE</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="exchangelib.services.GetSearchableMailboxes"><code class="flex name class">
<span>class <span class="ident">GetSearchableMailboxes</span></span>
<span>(</span><span>protocol, chunk_size=None)</span>
</code></dt>
<dd>
<div class="desc"><p>MSDN:
<a href="https://docs.microsoft.com/en-us/exchange/client-developer/web-service-reference/getsearchablemailboxes-operation">https://docs.microsoft.com/en-us/exchange/client-developer/web-service-reference/getsearchablemailboxes-operation</a></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class GetSearchableMailboxes(EWSService):
    &#34;&#34;&#34;MSDN:
    https://docs.microsoft.com/en-us/exchange/client-developer/web-service-reference/getsearchablemailboxes-operation

    &#34;&#34;&#34;
    SERVICE_NAME = &#39;GetSearchableMailboxes&#39;
    element_container_name = &#39;{%s}SearchableMailboxes&#39; % MNS
    failed_mailboxes_container_name = &#39;{%s}FailedMailboxes&#39; % MNS

    def call(self, search_filter, expand_group_membership):
        if self.protocol.version.build &lt; EXCHANGE_2013:
            raise NotImplementedError(&#39;%s is only supported for Exchange 2013 servers and later&#39; % self.SERVICE_NAME)
        from ..properties import SearchableMailbox, FailedMailbox
        for elem in self._get_elements(payload=self.get_payload(
                search_filter=search_filter,
                expand_group_membership=expand_group_membership,
        )):
            if isinstance(elem, Exception):
                yield elem
                continue
            if elem.tag == SearchableMailbox.response_tag():
                yield SearchableMailbox.from_xml(elem=elem, account=None)
            elif elem.tag == FailedMailbox.response_tag():
                yield FailedMailbox.from_xml(elem=elem, account=None)
            else:
                raise ValueError(&#34;Unknown element tag &#39;%s&#39;: (%s)&#34; % (elem.tag, elem))

    def get_payload(self, search_filter, expand_group_membership):
        payload = create_element(&#39;m:%s&#39; % self.SERVICE_NAME)
        if search_filter:
            add_xml_child(payload, &#39;m:SearchFilter&#39;, search_filter)
        if expand_group_membership is not None:
            add_xml_child(payload, &#39;m:ExpandGroupMembership&#39;, &#39;true&#39; if expand_group_membership else &#39;false&#39;)
        return payload

    def _get_elements_in_response(self, response):
        for msg in response:
            for container_name in (self.element_container_name, self.failed_mailboxes_container_name):
                try:
                    container_or_exc = self._get_element_container(message=msg, name=container_name)
                except MalformedResponseError:
                    # Responses bay contain no failed mailboxes. _get_element_container() does not accept this.
                    if container_name == self.failed_mailboxes_container_name:
                        continue
                    raise
                if isinstance(container_or_exc, (bool, Exception)):
                    yield container_or_exc
                else:
                    for c in self._get_elements_in_container(container=container_or_exc):
                        yield c</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="exchangelib.services.common.EWSService" href="common.html#exchangelib.services.common.EWSService">EWSService</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="exchangelib.services.GetSearchableMailboxes.SERVICE_NAME"><code class="name">var <span class="ident">SERVICE_NAME</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.services.GetSearchableMailboxes.element_container_name"><code class="name">var <span class="ident">element_container_name</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.services.GetSearchableMailboxes.failed_mailboxes_container_name"><code class="name">var <span class="ident">failed_mailboxes_container_name</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="exchangelib.services.GetSearchableMailboxes.call"><code class="name flex">
<span>def <span class="ident">call</span></span>(<span>self, search_filter, expand_group_membership)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def call(self, search_filter, expand_group_membership):
    if self.protocol.version.build &lt; EXCHANGE_2013:
        raise NotImplementedError(&#39;%s is only supported for Exchange 2013 servers and later&#39; % self.SERVICE_NAME)
    from ..properties import SearchableMailbox, FailedMailbox
    for elem in self._get_elements(payload=self.get_payload(
            search_filter=search_filter,
            expand_group_membership=expand_group_membership,
    )):
        if isinstance(elem, Exception):
            yield elem
            continue
        if elem.tag == SearchableMailbox.response_tag():
            yield SearchableMailbox.from_xml(elem=elem, account=None)
        elif elem.tag == FailedMailbox.response_tag():
            yield FailedMailbox.from_xml(elem=elem, account=None)
        else:
            raise ValueError(&#34;Unknown element tag &#39;%s&#39;: (%s)&#34; % (elem.tag, elem))</code></pre>
</details>
</dd>
<dt id="exchangelib.services.GetSearchableMailboxes.get_payload"><code class="name flex">
<span>def <span class="ident">get_payload</span></span>(<span>self, search_filter, expand_group_membership)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_payload(self, search_filter, expand_group_membership):
    payload = create_element(&#39;m:%s&#39; % self.SERVICE_NAME)
    if search_filter:
        add_xml_child(payload, &#39;m:SearchFilter&#39;, search_filter)
    if expand_group_membership is not None:
        add_xml_child(payload, &#39;m:ExpandGroupMembership&#39;, &#39;true&#39; if expand_group_membership else &#39;false&#39;)
    return payload</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="exchangelib.services.common.EWSService" href="common.html#exchangelib.services.common.EWSService">EWSService</a></b></code>:
<ul class="hlist">
<li><code><a title="exchangelib.services.common.EWSService.WARNINGS_TO_CATCH_IN_RESPONSE" href="common.html#exchangelib.services.common.EWSService.WARNINGS_TO_CATCH_IN_RESPONSE">WARNINGS_TO_CATCH_IN_RESPONSE</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="exchangelib.services.GetServerTimeZones"><code class="flex name class">
<span>class <span class="ident">GetServerTimeZones</span></span>
<span>(</span><span>protocol, chunk_size=None)</span>
</code></dt>
<dd>
<div class="desc"><p>MSDN: <a href="https://docs.microsoft.com/en-us/exchange/client-developer/web-service-reference/getservertimezones">https://docs.microsoft.com/en-us/exchange/client-developer/web-service-reference/getservertimezones</a></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class GetServerTimeZones(EWSService):
    &#34;&#34;&#34;MSDN: https://docs.microsoft.com/en-us/exchange/client-developer/web-service-reference/getservertimezones&#34;&#34;&#34;
    SERVICE_NAME = &#39;GetServerTimeZones&#39;
    element_container_name = &#39;{%s}TimeZoneDefinitions&#39; % MNS

    def call(self, timezones=None, return_full_timezone_data=False):
        if self.protocol.version.build &lt; EXCHANGE_2010:
            raise NotImplementedError(&#39;%s is only supported for Exchange 2010 servers and later&#39; % self.SERVICE_NAME)
        return self._get_elements(payload=self.get_payload(
            timezones=timezones,
            return_full_timezone_data=return_full_timezone_data
        ))

    def get_payload(self, timezones, return_full_timezone_data):
        payload = create_element(
            &#39;m:%s&#39; % self.SERVICE_NAME,
            attrs=dict(ReturnFullTimeZoneData=&#39;true&#39; if return_full_timezone_data else &#39;false&#39;),
        )
        if timezones is not None:
            is_empty, timezones = peek(timezones)
            if not is_empty:
                tz_ids = create_element(&#39;m:Ids&#39;)
                for timezone in timezones:
                    tz_id = set_xml_value(create_element(&#39;t:Id&#39;), timezone.ms_id, version=self.protocol.version)
                    tz_ids.append(tz_id)
                payload.append(tz_ids)
        return payload

    def _get_elements_in_container(self, container):
        for timezonedef in container:
            tz_id = timezonedef.get(&#39;Id&#39;)
            tz_name = timezonedef.get(&#39;Name&#39;)
            tz_periods = self._get_periods(timezonedef)
            tz_transitions_groups = self._get_transitions_groups(timezonedef)
            tz_transitions = self._get_transitions(timezonedef)
            yield (tz_id, tz_name, tz_periods, tz_transitions, tz_transitions_groups)

    @staticmethod
    def _get_periods(timezonedef):
        tz_periods = {}
        periods = timezonedef.find(&#39;{%s}Periods&#39; % TNS)
        for period in periods.findall(&#39;{%s}Period&#39; % TNS):
            # Convert e.g. &#34;trule:Microsoft/Registry/W. Europe Standard Time/2006-Daylight&#34; to (2006, &#39;Daylight&#39;)
            p_year, p_type = period.get(&#39;Id&#39;).rsplit(&#39;/&#39;, 1)[1].split(&#39;-&#39;)
            tz_periods[(int(p_year), p_type)] = dict(
                name=period.get(&#39;Name&#39;),
                bias=xml_text_to_value(period.get(&#39;Bias&#39;), datetime.timedelta)
            )
        return tz_periods

    @staticmethod
    def _get_transitions_groups(timezonedef):
        tz_transitions_groups = {}
        transitiongroups = timezonedef.find(&#39;{%s}TransitionsGroups&#39; % TNS)
        if transitiongroups is not None:
            for transitiongroup in transitiongroups.findall(&#39;{%s}TransitionsGroup&#39; % TNS):
                tg_id = int(transitiongroup.get(&#39;Id&#39;))
                tz_transitions_groups[tg_id] = []
                for transition in transitiongroup.findall(&#39;{%s}Transition&#39; % TNS):
                    # Apply same conversion to To as for period IDs
                    to_year, to_type = transition.find(&#39;{%s}To&#39; % TNS).text.rsplit(&#39;/&#39;, 1)[1].split(&#39;-&#39;)
                    tz_transitions_groups[tg_id].append(dict(
                        to=(int(to_year), to_type),
                    ))
                for transition in transitiongroup.findall(&#39;{%s}RecurringDayTransition&#39; % TNS):
                    # Apply same conversion to To as for period IDs
                    to_year, to_type = transition.find(&#39;{%s}To&#39; % TNS).text.rsplit(&#39;/&#39;, 1)[1].split(&#39;-&#39;)
                    occurrence = xml_text_to_value(transition.find(&#39;{%s}Occurrence&#39; % TNS).text, int)
                    if occurrence == -1:
                        # See TimeZoneTransition.from_xml()
                        occurrence = 5
                    tz_transitions_groups[tg_id].append(dict(
                        to=(int(to_year), to_type),
                        offset=xml_text_to_value(transition.find(&#39;{%s}TimeOffset&#39; % TNS).text, datetime.timedelta),
                        iso_month=xml_text_to_value(transition.find(&#39;{%s}Month&#39; % TNS).text, int),
                        iso_weekday=WEEKDAY_NAMES.index(transition.find(&#39;{%s}DayOfWeek&#39; % TNS).text) + 1,
                        occurrence=occurrence,
                    ))
        return tz_transitions_groups

    @staticmethod
    def _get_transitions(timezonedef):
        tz_transitions = {}
        transitions = timezonedef.find(&#39;{%s}Transitions&#39; % TNS)
        if transitions is not None:
            for transition in transitions.findall(&#39;{%s}Transition&#39; % TNS):
                to = transition.find(&#39;{%s}To&#39; % TNS)
                if to.get(&#39;Kind&#39;) != &#39;Group&#39;:
                    raise ValueError(&#39;Unexpected &#34;Kind&#34; XML attr: %s&#39; % to.get(&#39;Kind&#39;))
                tg_id = xml_text_to_value(to.text, int)
                tz_transitions[tg_id] = None
            for transition in transitions.findall(&#39;{%s}AbsoluteDateTransition&#39; % TNS):
                to = transition.find(&#39;{%s}To&#39; % TNS)
                if to.get(&#39;Kind&#39;) != &#39;Group&#39;:
                    raise ValueError(&#39;Unexpected &#34;Kind&#34; XML attr: %s&#39; % to.get(&#39;Kind&#39;))
                tg_id = xml_text_to_value(to.text, int)
                try:
                    t_date = xml_text_to_value(transition.find(&#39;{%s}DateTime&#39; % TNS).text, EWSDateTime).date()
                except NaiveDateTimeNotAllowed as e:
                    # We encountered a naive datetime. Don&#39;t worry. we just need the date
                    t_date = e.args[0].date()
                tz_transitions[tg_id] = t_date
        return tz_transitions</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="exchangelib.services.common.EWSService" href="common.html#exchangelib.services.common.EWSService">EWSService</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="exchangelib.services.GetServerTimeZones.SERVICE_NAME"><code class="name">var <span class="ident">SERVICE_NAME</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.services.GetServerTimeZones.element_container_name"><code class="name">var <span class="ident">element_container_name</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="exchangelib.services.GetServerTimeZones.call"><code class="name flex">
<span>def <span class="ident">call</span></span>(<span>self, timezones=None, return_full_timezone_data=False)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def call(self, timezones=None, return_full_timezone_data=False):
    if self.protocol.version.build &lt; EXCHANGE_2010:
        raise NotImplementedError(&#39;%s is only supported for Exchange 2010 servers and later&#39; % self.SERVICE_NAME)
    return self._get_elements(payload=self.get_payload(
        timezones=timezones,
        return_full_timezone_data=return_full_timezone_data
    ))</code></pre>
</details>
</dd>
<dt id="exchangelib.services.GetServerTimeZones.get_payload"><code class="name flex">
<span>def <span class="ident">get_payload</span></span>(<span>self, timezones, return_full_timezone_data)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_payload(self, timezones, return_full_timezone_data):
    payload = create_element(
        &#39;m:%s&#39; % self.SERVICE_NAME,
        attrs=dict(ReturnFullTimeZoneData=&#39;true&#39; if return_full_timezone_data else &#39;false&#39;),
    )
    if timezones is not None:
        is_empty, timezones = peek(timezones)
        if not is_empty:
            tz_ids = create_element(&#39;m:Ids&#39;)
            for timezone in timezones:
                tz_id = set_xml_value(create_element(&#39;t:Id&#39;), timezone.ms_id, version=self.protocol.version)
                tz_ids.append(tz_id)
            payload.append(tz_ids)
    return payload</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="exchangelib.services.common.EWSService" href="common.html#exchangelib.services.common.EWSService">EWSService</a></b></code>:
<ul class="hlist">
<li><code><a title="exchangelib.services.common.EWSService.WARNINGS_TO_CATCH_IN_RESPONSE" href="common.html#exchangelib.services.common.EWSService.WARNINGS_TO_CATCH_IN_RESPONSE">WARNINGS_TO_CATCH_IN_RESPONSE</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="exchangelib.services.GetUserAvailability"><code class="flex name class">
<span>class <span class="ident">GetUserAvailability</span></span>
<span>(</span><span>protocol, chunk_size=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Get detailed availability information for a list of users
MSDN:
<a href="https://docs.microsoft.com/en-us/exchange/client-developer/web-service-reference/getuseravailability-operation">https://docs.microsoft.com/en-us/exchange/client-developer/web-service-reference/getuseravailability-operation</a></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class GetUserAvailability(EWSService):
    &#34;&#34;&#34;Get detailed availability information for a list of users
    MSDN:
    https://docs.microsoft.com/en-us/exchange/client-developer/web-service-reference/getuseravailability-operation

    &#34;&#34;&#34;
    SERVICE_NAME = &#39;GetUserAvailability&#39;

    def call(self, timezone, mailbox_data, free_busy_view_options):
        # TODO: Also supports SuggestionsViewOptions, see
        # https://docs.microsoft.com/en-us/exchange/client-developer/web-service-reference/suggestionsviewoptions
        from ..properties import FreeBusyView
        for elem in self._get_elements(payload=self.get_payload(
            timezone=timezone,
            mailbox_data=mailbox_data,
            free_busy_view_options=free_busy_view_options
        )):
            if isinstance(elem, Exception):
                yield elem
                continue
            yield FreeBusyView.from_xml(elem=elem, account=None)

    def get_payload(self, timezone, mailbox_data, free_busy_view_options):
        payload = create_element(&#39;m:%sRequest&#39; % self.SERVICE_NAME)
        set_xml_value(payload, timezone, version=self.protocol.version)
        mailbox_data_array = create_element(&#39;m:MailboxDataArray&#39;)
        set_xml_value(mailbox_data_array, mailbox_data, version=self.protocol.version)
        payload.append(mailbox_data_array)
        set_xml_value(payload, free_busy_view_options, version=self.protocol.version)
        return payload

    @staticmethod
    def _response_messages_tag():
        return &#39;{%s}FreeBusyResponseArray&#39; % MNS

    @classmethod
    def _response_message_tag(cls):
        return &#39;{%s}FreeBusyResponse&#39; % MNS

    def _get_elements_in_response(self, response):
        for msg in response:
            # Just check the response code and raise errors
            self._get_element_container(message=msg.find(&#39;{%s}ResponseMessage&#39; % MNS))
            for c in self._get_elements_in_container(container=msg):
                yield c

    def _get_elements_in_container(self, container):
        return [container.find(&#39;{%s}FreeBusyView&#39; % MNS)]</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="exchangelib.services.common.EWSService" href="common.html#exchangelib.services.common.EWSService">EWSService</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="exchangelib.services.GetUserAvailability.SERVICE_NAME"><code class="name">var <span class="ident">SERVICE_NAME</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="exchangelib.services.GetUserAvailability.call"><code class="name flex">
<span>def <span class="ident">call</span></span>(<span>self, timezone, mailbox_data, free_busy_view_options)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def call(self, timezone, mailbox_data, free_busy_view_options):
    # TODO: Also supports SuggestionsViewOptions, see
    # https://docs.microsoft.com/en-us/exchange/client-developer/web-service-reference/suggestionsviewoptions
    from ..properties import FreeBusyView
    for elem in self._get_elements(payload=self.get_payload(
        timezone=timezone,
        mailbox_data=mailbox_data,
        free_busy_view_options=free_busy_view_options
    )):
        if isinstance(elem, Exception):
            yield elem
            continue
        yield FreeBusyView.from_xml(elem=elem, account=None)</code></pre>
</details>
</dd>
<dt id="exchangelib.services.GetUserAvailability.get_payload"><code class="name flex">
<span>def <span class="ident">get_payload</span></span>(<span>self, timezone, mailbox_data, free_busy_view_options)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_payload(self, timezone, mailbox_data, free_busy_view_options):
    payload = create_element(&#39;m:%sRequest&#39; % self.SERVICE_NAME)
    set_xml_value(payload, timezone, version=self.protocol.version)
    mailbox_data_array = create_element(&#39;m:MailboxDataArray&#39;)
    set_xml_value(mailbox_data_array, mailbox_data, version=self.protocol.version)
    payload.append(mailbox_data_array)
    set_xml_value(payload, free_busy_view_options, version=self.protocol.version)
    return payload</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="exchangelib.services.common.EWSService" href="common.html#exchangelib.services.common.EWSService">EWSService</a></b></code>:
<ul class="hlist">
<li><code><a title="exchangelib.services.common.EWSService.WARNINGS_TO_CATCH_IN_RESPONSE" href="common.html#exchangelib.services.common.EWSService.WARNINGS_TO_CATCH_IN_RESPONSE">WARNINGS_TO_CATCH_IN_RESPONSE</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="exchangelib.services.GetUserOofSettings"><code class="flex name class">
<span>class <span class="ident">GetUserOofSettings</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Get automatic reply settings for the specified mailbox.
MSDN: <a href="https://docs.microsoft.com/en-us/exchange/client-developer/web-service-reference/getuseroofsettings-operation">https://docs.microsoft.com/en-us/exchange/client-developer/web-service-reference/getuseroofsettings-operation</a></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class GetUserOofSettings(EWSAccountService):
    &#34;&#34;&#34;Get automatic reply settings for the specified mailbox.
    MSDN: https://docs.microsoft.com/en-us/exchange/client-developer/web-service-reference/getuseroofsettings-operation

    &#34;&#34;&#34;
    SERVICE_NAME = &#39;GetUserOofSettings&#39;
    element_container_name = &#39;{%s}OofSettings&#39; % TNS

    def call(self, mailbox):
        return self._get_elements(payload=self.get_payload(mailbox=mailbox))

    def get_payload(self, mailbox):
        from ..properties import AvailabilityMailbox
        payload = create_element(&#39;m:%sRequest&#39; % self.SERVICE_NAME)
        return set_xml_value(payload, AvailabilityMailbox.from_mailbox(mailbox), version=self.account.version)

    def _get_elements_in_response(self, response):
        # This service only returns one result, but &#39;response&#39; is a list
        from ..settings import OofSettings
        if len(response) != 1:
            raise ValueError(&#34;Expected &#39;response&#39; length 1, got %s&#34; % response)
        for msg in response:
            container_or_exc = self._get_element_container(message=msg, name=self.element_container_name)
            if isinstance(container_or_exc, (bool, Exception)):
                # pylint: disable=raising-bad-type
                raise container_or_exc
            yield OofSettings.from_xml(container_or_exc, account=self.account)

    def _get_element_container(self, message, response_message=None, name=None):
        response_message = message.find(&#39;{%s}ResponseMessage&#39; % MNS)
        return super()._get_element_container(
            message=message, response_message=response_message, name=name
        )</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="exchangelib.services.common.EWSAccountService" href="common.html#exchangelib.services.common.EWSAccountService">EWSAccountService</a></li>
<li><a title="exchangelib.services.common.EWSService" href="common.html#exchangelib.services.common.EWSService">EWSService</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="exchangelib.services.GetUserOofSettings.SERVICE_NAME"><code class="name">var <span class="ident">SERVICE_NAME</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.services.GetUserOofSettings.element_container_name"><code class="name">var <span class="ident">element_container_name</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="exchangelib.services.GetUserOofSettings.call"><code class="name flex">
<span>def <span class="ident">call</span></span>(<span>self, mailbox)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def call(self, mailbox):
    return self._get_elements(payload=self.get_payload(mailbox=mailbox))</code></pre>
</details>
</dd>
<dt id="exchangelib.services.GetUserOofSettings.get_payload"><code class="name flex">
<span>def <span class="ident">get_payload</span></span>(<span>self, mailbox)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_payload(self, mailbox):
    from ..properties import AvailabilityMailbox
    payload = create_element(&#39;m:%sRequest&#39; % self.SERVICE_NAME)
    return set_xml_value(payload, AvailabilityMailbox.from_mailbox(mailbox), version=self.account.version)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="exchangelib.services.common.EWSAccountService" href="common.html#exchangelib.services.common.EWSAccountService">EWSAccountService</a></b></code>:
<ul class="hlist">
<li><code><a title="exchangelib.services.common.EWSAccountService.WARNINGS_TO_CATCH_IN_RESPONSE" href="common.html#exchangelib.services.common.EWSService.WARNINGS_TO_CATCH_IN_RESPONSE">WARNINGS_TO_CATCH_IN_RESPONSE</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="exchangelib.services.MoveItem"><code class="flex name class">
<span>class <span class="ident">MoveItem</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>MSDN: <a href="https://docs.microsoft.com/en-us/exchange/client-developer/web-service-reference/moveitem-operation">https://docs.microsoft.com/en-us/exchange/client-developer/web-service-reference/moveitem-operation</a></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class MoveItem(EWSAccountService):
    &#34;&#34;&#34;MSDN: https://docs.microsoft.com/en-us/exchange/client-developer/web-service-reference/moveitem-operation&#34;&#34;&#34;
    SERVICE_NAME = &#39;MoveItem&#39;
    element_container_name = &#39;{%s}Items&#39; % MNS

    def call(self, items, to_folder):
        from ..folders import BaseFolder, FolderId, DistinguishedFolderId
        if not isinstance(to_folder, (BaseFolder, FolderId, DistinguishedFolderId)):
            raise ValueError(&#34;&#39;to_folder&#39; %r must be a Folder or FolderId instance&#34; % to_folder)
        return self._get_elements(payload=self.get_payload(
            items=items,
            to_folder=to_folder,
        ))

    def get_payload(self, items, to_folder):
        # Takes a list of items and returns their new item IDs
        moveitem = create_element(&#39;m:%s&#39; % self.SERVICE_NAME)
        tofolderid = create_element(&#39;m:ToFolderId&#39;)
        set_xml_value(tofolderid, to_folder, version=self.account.version)
        moveitem.append(tofolderid)
        item_ids = create_item_ids_element(items=items, version=self.account.version)
        moveitem.append(item_ids)
        return moveitem</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="exchangelib.services.common.EWSAccountService" href="common.html#exchangelib.services.common.EWSAccountService">EWSAccountService</a></li>
<li><a title="exchangelib.services.common.EWSService" href="common.html#exchangelib.services.common.EWSService">EWSService</a></li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="exchangelib.services.copy_item.CopyItem" href="copy_item.html#exchangelib.services.copy_item.CopyItem">CopyItem</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="exchangelib.services.MoveItem.SERVICE_NAME"><code class="name">var <span class="ident">SERVICE_NAME</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.services.MoveItem.element_container_name"><code class="name">var <span class="ident">element_container_name</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="exchangelib.services.MoveItem.call"><code class="name flex">
<span>def <span class="ident">call</span></span>(<span>self, items, to_folder)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def call(self, items, to_folder):
    from ..folders import BaseFolder, FolderId, DistinguishedFolderId
    if not isinstance(to_folder, (BaseFolder, FolderId, DistinguishedFolderId)):
        raise ValueError(&#34;&#39;to_folder&#39; %r must be a Folder or FolderId instance&#34; % to_folder)
    return self._get_elements(payload=self.get_payload(
        items=items,
        to_folder=to_folder,
    ))</code></pre>
</details>
</dd>
<dt id="exchangelib.services.MoveItem.get_payload"><code class="name flex">
<span>def <span class="ident">get_payload</span></span>(<span>self, items, to_folder)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_payload(self, items, to_folder):
    # Takes a list of items and returns their new item IDs
    moveitem = create_element(&#39;m:%s&#39; % self.SERVICE_NAME)
    tofolderid = create_element(&#39;m:ToFolderId&#39;)
    set_xml_value(tofolderid, to_folder, version=self.account.version)
    moveitem.append(tofolderid)
    item_ids = create_item_ids_element(items=items, version=self.account.version)
    moveitem.append(item_ids)
    return moveitem</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="exchangelib.services.common.EWSAccountService" href="common.html#exchangelib.services.common.EWSAccountService">EWSAccountService</a></b></code>:
<ul class="hlist">
<li><code><a title="exchangelib.services.common.EWSAccountService.WARNINGS_TO_CATCH_IN_RESPONSE" href="common.html#exchangelib.services.common.EWSService.WARNINGS_TO_CATCH_IN_RESPONSE">WARNINGS_TO_CATCH_IN_RESPONSE</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="exchangelib.services.ResolveNames"><code class="flex name class">
<span>class <span class="ident">ResolveNames</span></span>
<span>(</span><span>protocol, chunk_size=None)</span>
</code></dt>
<dd>
<div class="desc"><p>MSDN: <a href="https://docs.microsoft.com/en-us/exchange/client-developer/web-service-reference/resolvenames">https://docs.microsoft.com/en-us/exchange/client-developer/web-service-reference/resolvenames</a></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ResolveNames(EWSService):
    &#34;&#34;&#34;MSDN: https://docs.microsoft.com/en-us/exchange/client-developer/web-service-reference/resolvenames&#34;&#34;&#34;
    # TODO: Does not support paged responses yet. See example in issue #205
    SERVICE_NAME = &#39;ResolveNames&#39;
    element_container_name = &#39;{%s}ResolutionSet&#39; % MNS
    ERRORS_TO_CATCH_IN_RESPONSE = ErrorNameResolutionNoResults
    WARNINGS_TO_IGNORE_IN_RESPONSE = ErrorNameResolutionMultipleResults

    def call(self, unresolved_entries, parent_folders=None, return_full_contact_data=False, search_scope=None,
             contact_data_shape=None):
        from ..items import Contact, SHAPE_CHOICES, SEARCH_SCOPE_CHOICES
        if search_scope:
            if search_scope not in SEARCH_SCOPE_CHOICES:
                raise ValueError(&#34;&#39;search_scope&#39; %s must be one if %s&#34; % (search_scope, SEARCH_SCOPE_CHOICES))
        if contact_data_shape:
            if contact_data_shape not in SHAPE_CHOICES:
                raise ValueError(&#34;&#39;shape&#39; %s must be one if %s&#34; % (contact_data_shape, SHAPE_CHOICES))
        from ..properties import Mailbox
        elements = self._get_elements(payload=self.get_payload(
            unresolved_entries=unresolved_entries,
            parent_folders=parent_folders,
            return_full_contact_data=return_full_contact_data,
            search_scope=search_scope,
            contact_data_shape=contact_data_shape,
        ))
        for elem in elements:
            if isinstance(elem, ErrorNameResolutionNoResults):
                continue
            if isinstance(elem, Exception):
                raise elem
            if return_full_contact_data:
                mailbox_elem = elem.find(Mailbox.response_tag())
                contact_elem = elem.find(Contact.response_tag())
                yield (
                    None if mailbox_elem is None else Mailbox.from_xml(elem=mailbox_elem, account=None),
                    None if contact_elem is None else Contact.from_xml(elem=contact_elem, account=None),
                )
            else:
                yield Mailbox.from_xml(elem=elem.find(Mailbox.response_tag()), account=None)

    def get_payload(self, unresolved_entries, parent_folders, return_full_contact_data, search_scope,
                    contact_data_shape):
        payload = create_element(
            &#39;m:%s&#39; % self.SERVICE_NAME,
            attrs=dict(ReturnFullContactData=&#39;true&#39; if return_full_contact_data else &#39;false&#39;),
        )
        if search_scope:
            payload.set(&#39;SearchScope&#39;, search_scope)
        if contact_data_shape:
            if self.protocol.version.build &lt; EXCHANGE_2010_SP2:
                raise NotImplementedError(
                    &#34;&#39;contact_data_shape&#39; is only supported for Exchange 2010 SP2 servers and later&#34;)
            payload.set(&#39;ContactDataShape&#39;, contact_data_shape)
        if parent_folders:
            parentfolderids = create_element(&#39;m:ParentFolderIds&#39;)
            set_xml_value(parentfolderids, parent_folders, version=self.protocol.version)
        for entry in unresolved_entries:
            add_xml_child(payload, &#39;m:UnresolvedEntry&#39;, entry)
        if not len(payload):
            raise ValueError(&#39;&#34;unresolved_entries&#34; must not be empty&#39;)
        return payload</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="exchangelib.services.common.EWSService" href="common.html#exchangelib.services.common.EWSService">EWSService</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="exchangelib.services.ResolveNames.ERRORS_TO_CATCH_IN_RESPONSE"><code class="name">var <span class="ident">ERRORS_TO_CATCH_IN_RESPONSE</span></code></dt>
<dd>
<div class="desc"><p>Global error type within this module.</p></div>
</dd>
<dt id="exchangelib.services.ResolveNames.SERVICE_NAME"><code class="name">var <span class="ident">SERVICE_NAME</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.services.ResolveNames.WARNINGS_TO_IGNORE_IN_RESPONSE"><code class="name">var <span class="ident">WARNINGS_TO_IGNORE_IN_RESPONSE</span></code></dt>
<dd>
<div class="desc"><p>Global error type within this module.</p></div>
</dd>
<dt id="exchangelib.services.ResolveNames.element_container_name"><code class="name">var <span class="ident">element_container_name</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="exchangelib.services.ResolveNames.call"><code class="name flex">
<span>def <span class="ident">call</span></span>(<span>self, unresolved_entries, parent_folders=None, return_full_contact_data=False, search_scope=None, contact_data_shape=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def call(self, unresolved_entries, parent_folders=None, return_full_contact_data=False, search_scope=None,
         contact_data_shape=None):
    from ..items import Contact, SHAPE_CHOICES, SEARCH_SCOPE_CHOICES
    if search_scope:
        if search_scope not in SEARCH_SCOPE_CHOICES:
            raise ValueError(&#34;&#39;search_scope&#39; %s must be one if %s&#34; % (search_scope, SEARCH_SCOPE_CHOICES))
    if contact_data_shape:
        if contact_data_shape not in SHAPE_CHOICES:
            raise ValueError(&#34;&#39;shape&#39; %s must be one if %s&#34; % (contact_data_shape, SHAPE_CHOICES))
    from ..properties import Mailbox
    elements = self._get_elements(payload=self.get_payload(
        unresolved_entries=unresolved_entries,
        parent_folders=parent_folders,
        return_full_contact_data=return_full_contact_data,
        search_scope=search_scope,
        contact_data_shape=contact_data_shape,
    ))
    for elem in elements:
        if isinstance(elem, ErrorNameResolutionNoResults):
            continue
        if isinstance(elem, Exception):
            raise elem
        if return_full_contact_data:
            mailbox_elem = elem.find(Mailbox.response_tag())
            contact_elem = elem.find(Contact.response_tag())
            yield (
                None if mailbox_elem is None else Mailbox.from_xml(elem=mailbox_elem, account=None),
                None if contact_elem is None else Contact.from_xml(elem=contact_elem, account=None),
            )
        else:
            yield Mailbox.from_xml(elem=elem.find(Mailbox.response_tag()), account=None)</code></pre>
</details>
</dd>
<dt id="exchangelib.services.ResolveNames.get_payload"><code class="name flex">
<span>def <span class="ident">get_payload</span></span>(<span>self, unresolved_entries, parent_folders, return_full_contact_data, search_scope, contact_data_shape)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_payload(self, unresolved_entries, parent_folders, return_full_contact_data, search_scope,
                contact_data_shape):
    payload = create_element(
        &#39;m:%s&#39; % self.SERVICE_NAME,
        attrs=dict(ReturnFullContactData=&#39;true&#39; if return_full_contact_data else &#39;false&#39;),
    )
    if search_scope:
        payload.set(&#39;SearchScope&#39;, search_scope)
    if contact_data_shape:
        if self.protocol.version.build &lt; EXCHANGE_2010_SP2:
            raise NotImplementedError(
                &#34;&#39;contact_data_shape&#39; is only supported for Exchange 2010 SP2 servers and later&#34;)
        payload.set(&#39;ContactDataShape&#39;, contact_data_shape)
    if parent_folders:
        parentfolderids = create_element(&#39;m:ParentFolderIds&#39;)
        set_xml_value(parentfolderids, parent_folders, version=self.protocol.version)
    for entry in unresolved_entries:
        add_xml_child(payload, &#39;m:UnresolvedEntry&#39;, entry)
    if not len(payload):
        raise ValueError(&#39;&#34;unresolved_entries&#34; must not be empty&#39;)
    return payload</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="exchangelib.services.common.EWSService" href="common.html#exchangelib.services.common.EWSService">EWSService</a></b></code>:
<ul class="hlist">
<li><code><a title="exchangelib.services.common.EWSService.WARNINGS_TO_CATCH_IN_RESPONSE" href="common.html#exchangelib.services.common.EWSService.WARNINGS_TO_CATCH_IN_RESPONSE">WARNINGS_TO_CATCH_IN_RESPONSE</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="exchangelib.services.SendItem"><code class="flex name class">
<span>class <span class="ident">SendItem</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>MSDN: <a href="https://docs.microsoft.com/en-us/exchange/client-developer/web-service-reference/senditem-operation">https://docs.microsoft.com/en-us/exchange/client-developer/web-service-reference/senditem-operation</a></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SendItem(EWSAccountService):
    &#34;&#34;&#34;MSDN: https://docs.microsoft.com/en-us/exchange/client-developer/web-service-reference/senditem-operation&#34;&#34;&#34;
    SERVICE_NAME = &#39;SendItem&#39;
    element_container_name = None  # SendItem doesn&#39;t return a response object, just status in XML attrs

    def call(self, items, saved_item_folder):
        from ..folders import BaseFolder, FolderId, DistinguishedFolderId
        if saved_item_folder and not isinstance(saved_item_folder, (BaseFolder, FolderId, DistinguishedFolderId)):
            raise ValueError(&#34;&#39;saved_item_folder&#39; %r must be a Folder or FolderId instance&#34; % saved_item_folder)
        return self._get_elements(payload=self.get_payload(items=items, saved_item_folder=saved_item_folder))

    def get_payload(self, items, saved_item_folder):
        senditem = create_element(
            &#39;m:%s&#39; % self.SERVICE_NAME,
            attrs=dict(SaveItemToFolder=&#39;true&#39; if saved_item_folder else &#39;false&#39;),
        )
        item_ids = create_item_ids_element(items=items, version=self.account.version)
        senditem.append(item_ids)
        if saved_item_folder:
            saveditemfolderid = create_element(&#39;m:SavedItemFolderId&#39;)
            set_xml_value(saveditemfolderid, saved_item_folder, version=self.account.version)
            senditem.append(saveditemfolderid)
        return senditem</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="exchangelib.services.common.EWSAccountService" href="common.html#exchangelib.services.common.EWSAccountService">EWSAccountService</a></li>
<li><a title="exchangelib.services.common.EWSService" href="common.html#exchangelib.services.common.EWSService">EWSService</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="exchangelib.services.SendItem.SERVICE_NAME"><code class="name">var <span class="ident">SERVICE_NAME</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.services.SendItem.element_container_name"><code class="name">var <span class="ident">element_container_name</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="exchangelib.services.SendItem.call"><code class="name flex">
<span>def <span class="ident">call</span></span>(<span>self, items, saved_item_folder)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def call(self, items, saved_item_folder):
    from ..folders import BaseFolder, FolderId, DistinguishedFolderId
    if saved_item_folder and not isinstance(saved_item_folder, (BaseFolder, FolderId, DistinguishedFolderId)):
        raise ValueError(&#34;&#39;saved_item_folder&#39; %r must be a Folder or FolderId instance&#34; % saved_item_folder)
    return self._get_elements(payload=self.get_payload(items=items, saved_item_folder=saved_item_folder))</code></pre>
</details>
</dd>
<dt id="exchangelib.services.SendItem.get_payload"><code class="name flex">
<span>def <span class="ident">get_payload</span></span>(<span>self, items, saved_item_folder)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_payload(self, items, saved_item_folder):
    senditem = create_element(
        &#39;m:%s&#39; % self.SERVICE_NAME,
        attrs=dict(SaveItemToFolder=&#39;true&#39; if saved_item_folder else &#39;false&#39;),
    )
    item_ids = create_item_ids_element(items=items, version=self.account.version)
    senditem.append(item_ids)
    if saved_item_folder:
        saveditemfolderid = create_element(&#39;m:SavedItemFolderId&#39;)
        set_xml_value(saveditemfolderid, saved_item_folder, version=self.account.version)
        senditem.append(saveditemfolderid)
    return senditem</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="exchangelib.services.common.EWSAccountService" href="common.html#exchangelib.services.common.EWSAccountService">EWSAccountService</a></b></code>:
<ul class="hlist">
<li><code><a title="exchangelib.services.common.EWSAccountService.WARNINGS_TO_CATCH_IN_RESPONSE" href="common.html#exchangelib.services.common.EWSService.WARNINGS_TO_CATCH_IN_RESPONSE">WARNINGS_TO_CATCH_IN_RESPONSE</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="exchangelib.services.SetUserOofSettings"><code class="flex name class">
<span>class <span class="ident">SetUserOofSettings</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Set automatic replies for the specified mailbox.
MSDN: <a href="https://docs.microsoft.com/en-us/exchange/client-developer/web-service-reference/setuseroofsettings-operation">https://docs.microsoft.com/en-us/exchange/client-developer/web-service-reference/setuseroofsettings-operation</a></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SetUserOofSettings(EWSAccountService):
    &#34;&#34;&#34;Set automatic replies for the specified mailbox.
    MSDN: https://docs.microsoft.com/en-us/exchange/client-developer/web-service-reference/setuseroofsettings-operation

    &#34;&#34;&#34;
    SERVICE_NAME = &#39;SetUserOofSettings&#39;

    def call(self, oof_settings, mailbox):
        from ..settings import OofSettings
        from ..properties import Mailbox
        if not isinstance(oof_settings, OofSettings):
            raise ValueError(&#34;&#39;oof_settings&#39; %r must be an OofSettings instance&#34; % oof_settings)
        if not isinstance(mailbox, Mailbox):
            raise ValueError(&#34;&#39;mailbox&#39; %r must be an Mailbox instance&#34; % mailbox)
        return self._get_elements(payload=self.get_payload(oof_settings=oof_settings, mailbox=mailbox))

    def get_payload(self, oof_settings, mailbox):
        from ..properties import AvailabilityMailbox
        payload = create_element(&#39;m:%sRequest&#39; % self.SERVICE_NAME)
        set_xml_value(payload, AvailabilityMailbox.from_mailbox(mailbox), version=self.account.version)
        set_xml_value(payload, oof_settings, version=self.account.version)
        return payload

    def _get_element_container(self, message, response_message=None, name=None):
        response_message = message.find(&#39;{%s}ResponseMessage&#39; % MNS)
        return super()._get_element_container(
            message=message, response_message=response_message, name=name
        )</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="exchangelib.services.common.EWSAccountService" href="common.html#exchangelib.services.common.EWSAccountService">EWSAccountService</a></li>
<li><a title="exchangelib.services.common.EWSService" href="common.html#exchangelib.services.common.EWSService">EWSService</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="exchangelib.services.SetUserOofSettings.SERVICE_NAME"><code class="name">var <span class="ident">SERVICE_NAME</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="exchangelib.services.SetUserOofSettings.call"><code class="name flex">
<span>def <span class="ident">call</span></span>(<span>self, oof_settings, mailbox)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def call(self, oof_settings, mailbox):
    from ..settings import OofSettings
    from ..properties import Mailbox
    if not isinstance(oof_settings, OofSettings):
        raise ValueError(&#34;&#39;oof_settings&#39; %r must be an OofSettings instance&#34; % oof_settings)
    if not isinstance(mailbox, Mailbox):
        raise ValueError(&#34;&#39;mailbox&#39; %r must be an Mailbox instance&#34; % mailbox)
    return self._get_elements(payload=self.get_payload(oof_settings=oof_settings, mailbox=mailbox))</code></pre>
</details>
</dd>
<dt id="exchangelib.services.SetUserOofSettings.get_payload"><code class="name flex">
<span>def <span class="ident">get_payload</span></span>(<span>self, oof_settings, mailbox)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_payload(self, oof_settings, mailbox):
    from ..properties import AvailabilityMailbox
    payload = create_element(&#39;m:%sRequest&#39; % self.SERVICE_NAME)
    set_xml_value(payload, AvailabilityMailbox.from_mailbox(mailbox), version=self.account.version)
    set_xml_value(payload, oof_settings, version=self.account.version)
    return payload</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="exchangelib.services.common.EWSAccountService" href="common.html#exchangelib.services.common.EWSAccountService">EWSAccountService</a></b></code>:
<ul class="hlist">
<li><code><a title="exchangelib.services.common.EWSAccountService.WARNINGS_TO_CATCH_IN_RESPONSE" href="common.html#exchangelib.services.common.EWSService.WARNINGS_TO_CATCH_IN_RESPONSE">WARNINGS_TO_CATCH_IN_RESPONSE</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="exchangelib.services.UpdateFolder"><code class="flex name class">
<span>class <span class="ident">UpdateFolder</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>MSDN: <a href="https://docs.microsoft.com/en-us/exchange/client-developer/web-service-reference/updatefolder-operation">https://docs.microsoft.com/en-us/exchange/client-developer/web-service-reference/updatefolder-operation</a></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class UpdateFolder(EWSAccountService):
    &#34;&#34;&#34;MSDN: https://docs.microsoft.com/en-us/exchange/client-developer/web-service-reference/updatefolder-operation&#34;&#34;&#34;
    SERVICE_NAME = &#39;UpdateFolder&#39;
    element_container_name = &#39;{%s}Folders&#39; % MNS

    def call(self, folders):
        # We can&#39;t easily find the correct folder class from the returned XML. Instead, return objects with the same
        # class as the folder instance it was requested with.
        folders_list = list(f[0] for f in folders)  # Convert to a list, in case &#39;folders&#39; is a generator
        for folder, elem in zip(folders_list, self._get_elements(payload=self.get_payload(folders=folders))):
            yield parse_folder_elem(elem=elem, folder=folder, account=self.account)

    @staticmethod
    def _sort_fieldnames(folder_model, fieldnames):
        # Take a list of fieldnames and return the fields in the order they are mentioned in folder_model.FIELDS.
        # Loop over FIELDS and not supported_fields(). Upstream should make sure not to update a non-supported field.
        for f in folder_model.FIELDS:
            if f.name in fieldnames:
                yield f.name

    def _set_folder_elem(self, folder_model, field_path, value):
        setfolderfield = create_element(&#39;t:SetFolderField&#39;)
        set_xml_value(setfolderfield, field_path, version=self.account.version)
        folder = create_element(folder_model.request_tag())
        field_elem = field_path.field.to_xml(value, version=self.account.version)
        set_xml_value(folder, field_elem, version=self.account.version)
        setfolderfield.append(folder)
        return setfolderfield

    def _delete_folder_elem(self, field_path):
        deletefolderfield = create_element(&#39;t:DeleteFolderField&#39;)
        return set_xml_value(deletefolderfield, field_path, version=self.account.version)

    def _get_folder_update_elems(self, folder, fieldnames):
        from ..fields import FieldPath
        folder_model = folder.__class__
        fieldnames_set = set(fieldnames)

        for fieldname in self._sort_fieldnames(folder_model=folder_model, fieldnames=fieldnames_set):
            field = folder_model.get_field_by_fieldname(fieldname)
            if field.is_read_only:
                raise ValueError(&#39;%s is a read-only field&#39; % field.name)
            value = field.clean(getattr(folder, field.name), version=self.account.version)  # Make sure the value is OK

            if value is None or (field.is_list and not value):
                # A value of None or [] means we want to remove this field from the item
                if field.is_required or field.is_required_after_save:
                    raise ValueError(&#39;%s is a required field and may not be deleted&#39; % field.name)
                for field_path in FieldPath(field=field).expand(version=self.account.version):
                    yield self._delete_folder_elem(field_path=field_path)
                continue

            yield self._set_folder_elem(folder_model=folder_model, field_path=FieldPath(field=field), value=value)

    def get_payload(self, folders):
        from ..folders import BaseFolder, FolderId, DistinguishedFolderId
        updatefolder = create_element(&#39;m:%s&#39; % self.SERVICE_NAME)
        folderchanges = create_element(&#39;m:FolderChanges&#39;)
        version = self.account.version
        for folder, fieldnames in folders:
            log.debug(&#39;Updating folder %s fields %s&#39;, folder, fieldnames)
            folderchange = create_element(&#39;t:FolderChange&#39;)
            if not isinstance(folder, (BaseFolder, FolderId, DistinguishedFolderId)):
                folder = to_item_id(folder, FolderId, version=version)
            set_xml_value(folderchange, folder, version=version)
            updates = create_element(&#39;t:Updates&#39;)
            for elem in self._get_folder_update_elems(folder=folder, fieldnames=fieldnames):
                updates.append(elem)
            folderchange.append(updates)
            folderchanges.append(folderchange)
        if not len(folderchanges):
            raise ValueError(&#39;&#34;folders&#34; must not be empty&#39;)
        updatefolder.append(folderchanges)
        return updatefolder</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="exchangelib.services.common.EWSAccountService" href="common.html#exchangelib.services.common.EWSAccountService">EWSAccountService</a></li>
<li><a title="exchangelib.services.common.EWSService" href="common.html#exchangelib.services.common.EWSService">EWSService</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="exchangelib.services.UpdateFolder.SERVICE_NAME"><code class="name">var <span class="ident">SERVICE_NAME</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.services.UpdateFolder.element_container_name"><code class="name">var <span class="ident">element_container_name</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="exchangelib.services.UpdateFolder.call"><code class="name flex">
<span>def <span class="ident">call</span></span>(<span>self, folders)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def call(self, folders):
    # We can&#39;t easily find the correct folder class from the returned XML. Instead, return objects with the same
    # class as the folder instance it was requested with.
    folders_list = list(f[0] for f in folders)  # Convert to a list, in case &#39;folders&#39; is a generator
    for folder, elem in zip(folders_list, self._get_elements(payload=self.get_payload(folders=folders))):
        yield parse_folder_elem(elem=elem, folder=folder, account=self.account)</code></pre>
</details>
</dd>
<dt id="exchangelib.services.UpdateFolder.get_payload"><code class="name flex">
<span>def <span class="ident">get_payload</span></span>(<span>self, folders)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_payload(self, folders):
    from ..folders import BaseFolder, FolderId, DistinguishedFolderId
    updatefolder = create_element(&#39;m:%s&#39; % self.SERVICE_NAME)
    folderchanges = create_element(&#39;m:FolderChanges&#39;)
    version = self.account.version
    for folder, fieldnames in folders:
        log.debug(&#39;Updating folder %s fields %s&#39;, folder, fieldnames)
        folderchange = create_element(&#39;t:FolderChange&#39;)
        if not isinstance(folder, (BaseFolder, FolderId, DistinguishedFolderId)):
            folder = to_item_id(folder, FolderId, version=version)
        set_xml_value(folderchange, folder, version=version)
        updates = create_element(&#39;t:Updates&#39;)
        for elem in self._get_folder_update_elems(folder=folder, fieldnames=fieldnames):
            updates.append(elem)
        folderchange.append(updates)
        folderchanges.append(folderchange)
    if not len(folderchanges):
        raise ValueError(&#39;&#34;folders&#34; must not be empty&#39;)
    updatefolder.append(folderchanges)
    return updatefolder</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="exchangelib.services.common.EWSAccountService" href="common.html#exchangelib.services.common.EWSAccountService">EWSAccountService</a></b></code>:
<ul class="hlist">
<li><code><a title="exchangelib.services.common.EWSAccountService.WARNINGS_TO_CATCH_IN_RESPONSE" href="common.html#exchangelib.services.common.EWSService.WARNINGS_TO_CATCH_IN_RESPONSE">WARNINGS_TO_CATCH_IN_RESPONSE</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="exchangelib.services.UpdateItem"><code class="flex name class">
<span>class <span class="ident">UpdateItem</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>MSDN: <a href="https://docs.microsoft.com/en-us/exchange/client-developer/web-service-reference/updateitem">https://docs.microsoft.com/en-us/exchange/client-developer/web-service-reference/updateitem</a></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class UpdateItem(EWSAccountService, EWSPooledMixIn):
    &#34;&#34;&#34;MSDN: https://docs.microsoft.com/en-us/exchange/client-developer/web-service-reference/updateitem&#34;&#34;&#34;
    SERVICE_NAME = &#39;UpdateItem&#39;
    element_container_name = &#39;{%s}Items&#39; % MNS

    def call(self, items, conflict_resolution, message_disposition, send_meeting_invitations_or_cancellations,
             suppress_read_receipts):
        from ..items import CONFLICT_RESOLUTION_CHOICES, MESSAGE_DISPOSITION_CHOICES, \
            SEND_MEETING_INVITATIONS_AND_CANCELLATIONS_CHOICES, SEND_ONLY
        if conflict_resolution not in CONFLICT_RESOLUTION_CHOICES:
            raise ValueError(&#34;&#39;conflict_resolution&#39; %s must be one of %s&#34; % (
                conflict_resolution, CONFLICT_RESOLUTION_CHOICES
            ))
        if message_disposition not in MESSAGE_DISPOSITION_CHOICES:
            raise ValueError(&#34;&#39;message_disposition&#39; %s must be one of %s&#34; % (
                message_disposition, MESSAGE_DISPOSITION_CHOICES
            ))
        if send_meeting_invitations_or_cancellations not in SEND_MEETING_INVITATIONS_AND_CANCELLATIONS_CHOICES:
            raise ValueError(&#34;&#39;send_meeting_invitations_or_cancellations&#39; %s must be one of %s&#34; % (
                send_meeting_invitations_or_cancellations, SEND_MEETING_INVITATIONS_AND_CANCELLATIONS_CHOICES
            ))
        if suppress_read_receipts not in (True, False):
            raise ValueError(&#34;&#39;suppress_read_receipts&#39; %s must be True or False&#34; % suppress_read_receipts)
        if message_disposition == SEND_ONLY:
            raise ValueError(&#39;Cannot send-only existing objects. Use SendItem service instead&#39;)
        return self._pool_requests(payload_func=self.get_payload, **dict(
            items=items,
            conflict_resolution=conflict_resolution,
            message_disposition=message_disposition,
            send_meeting_invitations_or_cancellations=send_meeting_invitations_or_cancellations,
            suppress_read_receipts=suppress_read_receipts,
        ))

    def _delete_item_elem(self, field_path):
        deleteitemfield = create_element(&#39;t:DeleteItemField&#39;)
        return set_xml_value(deleteitemfield, field_path, version=self.account.version)

    def _set_item_elem(self, item_model, field_path, value):
        setitemfield = create_element(&#39;t:SetItemField&#39;)
        set_xml_value(setitemfield, field_path, version=self.account.version)
        folderitem = create_element(item_model.request_tag())
        field_elem = field_path.field.to_xml(value, version=self.account.version)
        set_xml_value(folderitem, field_elem, version=self.account.version)
        setitemfield.append(folderitem)
        return setitemfield

    @staticmethod
    def _sorted_fields(item_model, fieldnames):
        # Take a list of fieldnames and return the (unique) fields in the order they are mentioned in item_class.FIELDS.
        # Checks that all fieldnames are valid.
        unique_fieldnames = list(OrderedDict.fromkeys(fieldnames))  # Make field names unique ,but keep ordering
        # Loop over FIELDS and not supported_fields(). Upstream should make sure not to update a non-supported field.
        for f in item_model.FIELDS:
            if f.name in unique_fieldnames:
                unique_fieldnames.remove(f.name)
                yield f
        if unique_fieldnames:
            raise ValueError(&#34;Field name(s) %s are not valid for a &#39;%s&#39; item&#34; % (
                &#39;, &#39;.join(&#34;&#39;%s&#39;&#34; % f for f in unique_fieldnames), item_model.__name__))

    def _get_item_update_elems(self, item, fieldnames):
        from ..items import CalendarItem
        fieldnames_copy = list(fieldnames)

        if item.__class__ == CalendarItem:
            # For CalendarItem items where we update &#39;start&#39; or &#39;end&#39;, we want to update internal timezone fields
            item.clean_timezone_fields(version=self.account.version)  # Possibly also sets timezone values
            for field_name in (&#39;start&#39;, &#39;end&#39;):
                if field_name in fieldnames_copy:
                    tz_field_name = item.tz_field_for_field_name(field_name).name
                    if tz_field_name not in fieldnames_copy:
                        fieldnames_copy.append(tz_field_name)

        for field in self._sorted_fields(item_model=item.__class__, fieldnames=fieldnames_copy):
            if field.is_read_only:
                raise ValueError(&#39;%s is a read-only field&#39; % field.name)
            value = self._get_item_value(item, field)
            if value is None or (field.is_list and not value):
                # A value of None or [] means we want to remove this field from the item
                for elem in self._get_delete_item_elems(field=field):
                    yield elem
            else:
                for elem in self._get_set_item_elems(item_model=item.__class__, field=field, value=value):
                    yield elem

    def _get_item_value(self, item, field):
        from ..items import CalendarItem
        value = field.clean(getattr(item, field.name), version=self.account.version)  # Make sure the value is OK
        if item.__class__ == CalendarItem:
            # For CalendarItem items where we update &#39;start&#39; or &#39;end&#39;, we want to send values in the local timezone
            if field.name in (&#39;start&#39;, &#39;end&#39;):
                if type(value) == EWSDate:
                    # EWS always expects a datetime
                    return item.date_to_datetime(field_name=field.name)
                tz_field_name = item.tz_field_for_field_name(field.name).name
                return value.astimezone(getattr(item, tz_field_name))
        return value

    def _get_delete_item_elems(self, field):
        from ..fields import FieldPath
        if field.is_required or field.is_required_after_save:
            raise ValueError(&#39;%s is a required field and may not be deleted&#39; % field.name)
        for field_path in FieldPath(field=field).expand(version=self.account.version):
            yield self._delete_item_elem(field_path=field_path)

    def _get_set_item_elems(self, item_model, field, value):
        from ..fields import FieldPath, IndexedField
        from ..indexed_properties import MultiFieldIndexedElement
        if isinstance(field, IndexedField):
            # TODO: Maybe the set/delete logic should extend into subfields, not just overwrite the whole item.
            for v in value:
                # TODO: We should also delete the labels that no longer exist in the list
                if issubclass(field.value_cls, MultiFieldIndexedElement):
                    # We have subfields. Generate SetItem XML for each subfield. SetItem only accepts items that
                    # have the one value set that we want to change. Create a new IndexedField object that has
                    # only that value set.
                    for subfield in field.value_cls.supported_fields(version=self.account.version):
                        yield self._set_item_elem(
                            item_model=item_model,
                            field_path=FieldPath(field=field, label=v.label, subfield=subfield),
                            value=field.value_cls(**{&#39;label&#39;: v.label, subfield.name: getattr(v, subfield.name)}),
                        )
                else:
                    # The simpler IndexedFields with only one subfield
                    subfield = field.value_cls.value_field(version=self.account.version)
                    yield self._set_item_elem(
                        item_model=item_model,
                        field_path=FieldPath(field=field, label=v.label, subfield=subfield),
                        value=v,
                    )
        else:
            yield self._set_item_elem(item_model=item_model, field_path=FieldPath(field=field), value=value)

    def get_payload(self, items, conflict_resolution, message_disposition, send_meeting_invitations_or_cancellations,
                    suppress_read_receipts):
        # Takes a list of (Item, fieldnames) tuples where &#39;Item&#39; is a instance of a subclass of Item and &#39;fieldnames&#39;
        # are the attribute names that were updated. Returns the XML for an UpdateItem call.
        # an UpdateItem request.
        from ..properties import ItemId
        if self.account.version.build &gt;= EXCHANGE_2013_SP1:
            updateitem = create_element(
                &#39;m:%s&#39; % self.SERVICE_NAME,
                attrs=OrderedDict([
                    (&#39;ConflictResolution&#39;, conflict_resolution),
                    (&#39;MessageDisposition&#39;, message_disposition),
                    (&#39;SendMeetingInvitationsOrCancellations&#39;, send_meeting_invitations_or_cancellations),
                    (&#39;SuppressReadReceipts&#39;, &#39;true&#39; if suppress_read_receipts else &#39;false&#39;),
                ])
            )
        else:
            updateitem = create_element(
                &#39;m:%s&#39; % self.SERVICE_NAME,
                attrs=OrderedDict([
                    (&#39;ConflictResolution&#39;, conflict_resolution),
                    (&#39;MessageDisposition&#39;, message_disposition),
                    (&#39;SendMeetingInvitationsOrCancellations&#39;, send_meeting_invitations_or_cancellations),
                ])
            )
        itemchanges = create_element(&#39;m:ItemChanges&#39;)
        version = self.account.version
        for item, fieldnames in items:
            if not fieldnames:
                raise ValueError(&#39;&#34;fieldnames&#34; must not be empty&#39;)
            itemchange = create_element(&#39;t:ItemChange&#39;)
            log.debug(&#39;Updating item %s fields %s&#39;, item, fieldnames)
            set_xml_value(itemchange, to_item_id(item, ItemId, version=version), version=version)
            updates = create_element(&#39;t:Updates&#39;)
            for elem in self._get_item_update_elems(item=item, fieldnames=fieldnames):
                updates.append(elem)
            itemchange.append(updates)
            itemchanges.append(itemchange)
        if not len(itemchanges):
            raise ValueError(&#39;&#34;items&#34; must not be empty&#39;)
        updateitem.append(itemchanges)
        return updateitem</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="exchangelib.services.common.EWSAccountService" href="common.html#exchangelib.services.common.EWSAccountService">EWSAccountService</a></li>
<li><a title="exchangelib.services.common.EWSPooledMixIn" href="common.html#exchangelib.services.common.EWSPooledMixIn">EWSPooledMixIn</a></li>
<li><a title="exchangelib.services.common.EWSService" href="common.html#exchangelib.services.common.EWSService">EWSService</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="exchangelib.services.UpdateItem.SERVICE_NAME"><code class="name">var <span class="ident">SERVICE_NAME</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.services.UpdateItem.element_container_name"><code class="name">var <span class="ident">element_container_name</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="exchangelib.services.UpdateItem.call"><code class="name flex">
<span>def <span class="ident">call</span></span>(<span>self, items, conflict_resolution, message_disposition, send_meeting_invitations_or_cancellations, suppress_read_receipts)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def call(self, items, conflict_resolution, message_disposition, send_meeting_invitations_or_cancellations,
         suppress_read_receipts):
    from ..items import CONFLICT_RESOLUTION_CHOICES, MESSAGE_DISPOSITION_CHOICES, \
        SEND_MEETING_INVITATIONS_AND_CANCELLATIONS_CHOICES, SEND_ONLY
    if conflict_resolution not in CONFLICT_RESOLUTION_CHOICES:
        raise ValueError(&#34;&#39;conflict_resolution&#39; %s must be one of %s&#34; % (
            conflict_resolution, CONFLICT_RESOLUTION_CHOICES
        ))
    if message_disposition not in MESSAGE_DISPOSITION_CHOICES:
        raise ValueError(&#34;&#39;message_disposition&#39; %s must be one of %s&#34; % (
            message_disposition, MESSAGE_DISPOSITION_CHOICES
        ))
    if send_meeting_invitations_or_cancellations not in SEND_MEETING_INVITATIONS_AND_CANCELLATIONS_CHOICES:
        raise ValueError(&#34;&#39;send_meeting_invitations_or_cancellations&#39; %s must be one of %s&#34; % (
            send_meeting_invitations_or_cancellations, SEND_MEETING_INVITATIONS_AND_CANCELLATIONS_CHOICES
        ))
    if suppress_read_receipts not in (True, False):
        raise ValueError(&#34;&#39;suppress_read_receipts&#39; %s must be True or False&#34; % suppress_read_receipts)
    if message_disposition == SEND_ONLY:
        raise ValueError(&#39;Cannot send-only existing objects. Use SendItem service instead&#39;)
    return self._pool_requests(payload_func=self.get_payload, **dict(
        items=items,
        conflict_resolution=conflict_resolution,
        message_disposition=message_disposition,
        send_meeting_invitations_or_cancellations=send_meeting_invitations_or_cancellations,
        suppress_read_receipts=suppress_read_receipts,
    ))</code></pre>
</details>
</dd>
<dt id="exchangelib.services.UpdateItem.get_payload"><code class="name flex">
<span>def <span class="ident">get_payload</span></span>(<span>self, items, conflict_resolution, message_disposition, send_meeting_invitations_or_cancellations, suppress_read_receipts)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_payload(self, items, conflict_resolution, message_disposition, send_meeting_invitations_or_cancellations,
                suppress_read_receipts):
    # Takes a list of (Item, fieldnames) tuples where &#39;Item&#39; is a instance of a subclass of Item and &#39;fieldnames&#39;
    # are the attribute names that were updated. Returns the XML for an UpdateItem call.
    # an UpdateItem request.
    from ..properties import ItemId
    if self.account.version.build &gt;= EXCHANGE_2013_SP1:
        updateitem = create_element(
            &#39;m:%s&#39; % self.SERVICE_NAME,
            attrs=OrderedDict([
                (&#39;ConflictResolution&#39;, conflict_resolution),
                (&#39;MessageDisposition&#39;, message_disposition),
                (&#39;SendMeetingInvitationsOrCancellations&#39;, send_meeting_invitations_or_cancellations),
                (&#39;SuppressReadReceipts&#39;, &#39;true&#39; if suppress_read_receipts else &#39;false&#39;),
            ])
        )
    else:
        updateitem = create_element(
            &#39;m:%s&#39; % self.SERVICE_NAME,
            attrs=OrderedDict([
                (&#39;ConflictResolution&#39;, conflict_resolution),
                (&#39;MessageDisposition&#39;, message_disposition),
                (&#39;SendMeetingInvitationsOrCancellations&#39;, send_meeting_invitations_or_cancellations),
            ])
        )
    itemchanges = create_element(&#39;m:ItemChanges&#39;)
    version = self.account.version
    for item, fieldnames in items:
        if not fieldnames:
            raise ValueError(&#39;&#34;fieldnames&#34; must not be empty&#39;)
        itemchange = create_element(&#39;t:ItemChange&#39;)
        log.debug(&#39;Updating item %s fields %s&#39;, item, fieldnames)
        set_xml_value(itemchange, to_item_id(item, ItemId, version=version), version=version)
        updates = create_element(&#39;t:Updates&#39;)
        for elem in self._get_item_update_elems(item=item, fieldnames=fieldnames):
            updates.append(elem)
        itemchange.append(updates)
        itemchanges.append(itemchange)
    if not len(itemchanges):
        raise ValueError(&#39;&#34;items&#34; must not be empty&#39;)
    updateitem.append(itemchanges)
    return updateitem</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="exchangelib.services.common.EWSAccountService" href="common.html#exchangelib.services.common.EWSAccountService">EWSAccountService</a></b></code>:
<ul class="hlist">
<li><code><a title="exchangelib.services.common.EWSAccountService.WARNINGS_TO_CATCH_IN_RESPONSE" href="common.html#exchangelib.services.common.EWSService.WARNINGS_TO_CATCH_IN_RESPONSE">WARNINGS_TO_CATCH_IN_RESPONSE</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="exchangelib.services.UploadItems"><code class="flex name class">
<span>class <span class="ident">UploadItems</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>MSDN: <a href="https://docs.microsoft.com/en-us/exchange/client-developer/web-service-reference/uploaditems-operation">https://docs.microsoft.com/en-us/exchange/client-developer/web-service-reference/uploaditems-operation</a></p>
<p>This currently has the existing limitation of only being able to upload
items that do not yet exist in the database. The full spec also allows
actions "Update" and "UpdateOrCreate".</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class UploadItems(EWSAccountService, EWSPooledMixIn):
    &#34;&#34;&#34;MSDN: https://docs.microsoft.com/en-us/exchange/client-developer/web-service-reference/uploaditems-operation

    This currently has the existing limitation of only being able to upload
    items that do not yet exist in the database. The full spec also allows
    actions &#34;Update&#34; and &#34;UpdateOrCreate&#34;.

    &#34;&#34;&#34;
    SERVICE_NAME = &#39;UploadItems&#39;
    element_container_name = &#39;{%s}ItemId&#39; % MNS

    def call(self, items):
        # _pool_requests expects &#39;items&#39;, not &#39;data&#39;
        return self._pool_requests(payload_func=self.get_payload, **dict(items=items))

    def get_payload(self, items):
        &#34;&#34;&#34;Upload given items to given account

        data is an iterable of tuples where the first element is a Folder
        instance representing the ParentFolder that the item will be placed in
        and the second element is a Data string returned from an ExportItems
        call.

        Args:
          items:

        &#34;&#34;&#34;
        from ..properties import ParentFolderId
        uploaditems = create_element(&#39;m:%s&#39; % self.SERVICE_NAME)
        itemselement = create_element(&#39;m:Items&#39;)
        uploaditems.append(itemselement)
        for parent_folder, data_str in items:
            item = create_element(&#39;t:Item&#39;, attrs=dict(CreateAction=&#39;CreateNew&#39;))
            parentfolderid = ParentFolderId(parent_folder.id, parent_folder.changekey)
            set_xml_value(item, parentfolderid, version=self.account.version)
            add_xml_child(item, &#39;t:Data&#39;, data_str)
            itemselement.append(item)
        return uploaditems

    def _get_elements_in_container(self, container):
        from ..properties import ItemId
        return [(container.get(ItemId.ID_ATTR), container.get(ItemId.CHANGEKEY_ATTR))]</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="exchangelib.services.common.EWSAccountService" href="common.html#exchangelib.services.common.EWSAccountService">EWSAccountService</a></li>
<li><a title="exchangelib.services.common.EWSPooledMixIn" href="common.html#exchangelib.services.common.EWSPooledMixIn">EWSPooledMixIn</a></li>
<li><a title="exchangelib.services.common.EWSService" href="common.html#exchangelib.services.common.EWSService">EWSService</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="exchangelib.services.UploadItems.SERVICE_NAME"><code class="name">var <span class="ident">SERVICE_NAME</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.services.UploadItems.element_container_name"><code class="name">var <span class="ident">element_container_name</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="exchangelib.services.UploadItems.call"><code class="name flex">
<span>def <span class="ident">call</span></span>(<span>self, items)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def call(self, items):
    # _pool_requests expects &#39;items&#39;, not &#39;data&#39;
    return self._pool_requests(payload_func=self.get_payload, **dict(items=items))</code></pre>
</details>
</dd>
<dt id="exchangelib.services.UploadItems.get_payload"><code class="name flex">
<span>def <span class="ident">get_payload</span></span>(<span>self, items)</span>
</code></dt>
<dd>
<div class="desc"><p>Upload given items to given account</p>
<p>data is an iterable of tuples where the first element is a Folder
instance representing the ParentFolder that the item will be placed in
and the second element is a Data string returned from an ExportItems
call.</p>
<h2 id="args">Args</h2>
<p>items:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_payload(self, items):
    &#34;&#34;&#34;Upload given items to given account

    data is an iterable of tuples where the first element is a Folder
    instance representing the ParentFolder that the item will be placed in
    and the second element is a Data string returned from an ExportItems
    call.

    Args:
      items:

    &#34;&#34;&#34;
    from ..properties import ParentFolderId
    uploaditems = create_element(&#39;m:%s&#39; % self.SERVICE_NAME)
    itemselement = create_element(&#39;m:Items&#39;)
    uploaditems.append(itemselement)
    for parent_folder, data_str in items:
        item = create_element(&#39;t:Item&#39;, attrs=dict(CreateAction=&#39;CreateNew&#39;))
        parentfolderid = ParentFolderId(parent_folder.id, parent_folder.changekey)
        set_xml_value(item, parentfolderid, version=self.account.version)
        add_xml_child(item, &#39;t:Data&#39;, data_str)
        itemselement.append(item)
    return uploaditems</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="exchangelib.services.common.EWSAccountService" href="common.html#exchangelib.services.common.EWSAccountService">EWSAccountService</a></b></code>:
<ul class="hlist">
<li><code><a title="exchangelib.services.common.EWSAccountService.WARNINGS_TO_CATCH_IN_RESPONSE" href="common.html#exchangelib.services.common.EWSService.WARNINGS_TO_CATCH_IN_RESPONSE">WARNINGS_TO_CATCH_IN_RESPONSE</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="exchangelib" href="../index.html">exchangelib</a></code></li>
</ul>
</li>
<li><h3><a href="#header-submodules">Sub-modules</a></h3>
<ul>
<li><code><a title="exchangelib.services.archive_item" href="archive_item.html">exchangelib.services.archive_item</a></code></li>
<li><code><a title="exchangelib.services.common" href="common.html">exchangelib.services.common</a></code></li>
<li><code><a title="exchangelib.services.convert_id" href="convert_id.html">exchangelib.services.convert_id</a></code></li>
<li><code><a title="exchangelib.services.copy_item" href="copy_item.html">exchangelib.services.copy_item</a></code></li>
<li><code><a title="exchangelib.services.create_attachment" href="create_attachment.html">exchangelib.services.create_attachment</a></code></li>
<li><code><a title="exchangelib.services.create_folder" href="create_folder.html">exchangelib.services.create_folder</a></code></li>
<li><code><a title="exchangelib.services.create_item" href="create_item.html">exchangelib.services.create_item</a></code></li>
<li><code><a title="exchangelib.services.delete_attachment" href="delete_attachment.html">exchangelib.services.delete_attachment</a></code></li>
<li><code><a title="exchangelib.services.delete_folder" href="delete_folder.html">exchangelib.services.delete_folder</a></code></li>
<li><code><a title="exchangelib.services.delete_item" href="delete_item.html">exchangelib.services.delete_item</a></code></li>
<li><code><a title="exchangelib.services.empty_folder" href="empty_folder.html">exchangelib.services.empty_folder</a></code></li>
<li><code><a title="exchangelib.services.expand_dl" href="expand_dl.html">exchangelib.services.expand_dl</a></code></li>
<li><code><a title="exchangelib.services.export_items" href="export_items.html">exchangelib.services.export_items</a></code></li>
<li><code><a title="exchangelib.services.find_folder" href="find_folder.html">exchangelib.services.find_folder</a></code></li>
<li><code><a title="exchangelib.services.find_item" href="find_item.html">exchangelib.services.find_item</a></code></li>
<li><code><a title="exchangelib.services.find_people" href="find_people.html">exchangelib.services.find_people</a></code></li>
<li><code><a title="exchangelib.services.get_attachment" href="get_attachment.html">exchangelib.services.get_attachment</a></code></li>
<li><code><a title="exchangelib.services.get_delegate" href="get_delegate.html">exchangelib.services.get_delegate</a></code></li>
<li><code><a title="exchangelib.services.get_folder" href="get_folder.html">exchangelib.services.get_folder</a></code></li>
<li><code><a title="exchangelib.services.get_item" href="get_item.html">exchangelib.services.get_item</a></code></li>
<li><code><a title="exchangelib.services.get_mail_tips" href="get_mail_tips.html">exchangelib.services.get_mail_tips</a></code></li>
<li><code><a title="exchangelib.services.get_persona" href="get_persona.html">exchangelib.services.get_persona</a></code></li>
<li><code><a title="exchangelib.services.get_room_lists" href="get_room_lists.html">exchangelib.services.get_room_lists</a></code></li>
<li><code><a title="exchangelib.services.get_rooms" href="get_rooms.html">exchangelib.services.get_rooms</a></code></li>
<li><code><a title="exchangelib.services.get_searchable_mailboxes" href="get_searchable_mailboxes.html">exchangelib.services.get_searchable_mailboxes</a></code></li>
<li><code><a title="exchangelib.services.get_server_time_zones" href="get_server_time_zones.html">exchangelib.services.get_server_time_zones</a></code></li>
<li><code><a title="exchangelib.services.get_user_availability" href="get_user_availability.html">exchangelib.services.get_user_availability</a></code></li>
<li><code><a title="exchangelib.services.get_user_oof_settings" href="get_user_oof_settings.html">exchangelib.services.get_user_oof_settings</a></code></li>
<li><code><a title="exchangelib.services.move_item" href="move_item.html">exchangelib.services.move_item</a></code></li>
<li><code><a title="exchangelib.services.resolve_names" href="resolve_names.html">exchangelib.services.resolve_names</a></code></li>
<li><code><a title="exchangelib.services.send_item" href="send_item.html">exchangelib.services.send_item</a></code></li>
<li><code><a title="exchangelib.services.set_user_oof_settings" href="set_user_oof_settings.html">exchangelib.services.set_user_oof_settings</a></code></li>
<li><code><a title="exchangelib.services.update_folder" href="update_folder.html">exchangelib.services.update_folder</a></code></li>
<li><code><a title="exchangelib.services.update_item" href="update_item.html">exchangelib.services.update_item</a></code></li>
<li><code><a title="exchangelib.services.upload_items" href="upload_items.html">exchangelib.services.upload_items</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="exchangelib.services.ArchiveItem" href="#exchangelib.services.ArchiveItem">ArchiveItem</a></code></h4>
<ul class="">
<li><code><a title="exchangelib.services.ArchiveItem.SERVICE_NAME" href="#exchangelib.services.ArchiveItem.SERVICE_NAME">SERVICE_NAME</a></code></li>
<li><code><a title="exchangelib.services.ArchiveItem.call" href="#exchangelib.services.ArchiveItem.call">call</a></code></li>
<li><code><a title="exchangelib.services.ArchiveItem.element_container_name" href="#exchangelib.services.ArchiveItem.element_container_name">element_container_name</a></code></li>
<li><code><a title="exchangelib.services.ArchiveItem.get_payload" href="#exchangelib.services.ArchiveItem.get_payload">get_payload</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="exchangelib.services.ConvertId" href="#exchangelib.services.ConvertId">ConvertId</a></code></h4>
<ul class="">
<li><code><a title="exchangelib.services.ConvertId.SERVICE_NAME" href="#exchangelib.services.ConvertId.SERVICE_NAME">SERVICE_NAME</a></code></li>
<li><code><a title="exchangelib.services.ConvertId.call" href="#exchangelib.services.ConvertId.call">call</a></code></li>
<li><code><a title="exchangelib.services.ConvertId.get_payload" href="#exchangelib.services.ConvertId.get_payload">get_payload</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="exchangelib.services.CopyItem" href="#exchangelib.services.CopyItem">CopyItem</a></code></h4>
<ul class="">
<li><code><a title="exchangelib.services.CopyItem.SERVICE_NAME" href="#exchangelib.services.CopyItem.SERVICE_NAME">SERVICE_NAME</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="exchangelib.services.CreateAttachment" href="#exchangelib.services.CreateAttachment">CreateAttachment</a></code></h4>
<ul class="">
<li><code><a title="exchangelib.services.CreateAttachment.SERVICE_NAME" href="#exchangelib.services.CreateAttachment.SERVICE_NAME">SERVICE_NAME</a></code></li>
<li><code><a title="exchangelib.services.CreateAttachment.call" href="#exchangelib.services.CreateAttachment.call">call</a></code></li>
<li><code><a title="exchangelib.services.CreateAttachment.element_container_name" href="#exchangelib.services.CreateAttachment.element_container_name">element_container_name</a></code></li>
<li><code><a title="exchangelib.services.CreateAttachment.get_payload" href="#exchangelib.services.CreateAttachment.get_payload">get_payload</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="exchangelib.services.CreateFolder" href="#exchangelib.services.CreateFolder">CreateFolder</a></code></h4>
<ul class="">
<li><code><a title="exchangelib.services.CreateFolder.SERVICE_NAME" href="#exchangelib.services.CreateFolder.SERVICE_NAME">SERVICE_NAME</a></code></li>
<li><code><a title="exchangelib.services.CreateFolder.call" href="#exchangelib.services.CreateFolder.call">call</a></code></li>
<li><code><a title="exchangelib.services.CreateFolder.element_container_name" href="#exchangelib.services.CreateFolder.element_container_name">element_container_name</a></code></li>
<li><code><a title="exchangelib.services.CreateFolder.get_payload" href="#exchangelib.services.CreateFolder.get_payload">get_payload</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="exchangelib.services.CreateItem" href="#exchangelib.services.CreateItem">CreateItem</a></code></h4>
<ul class="">
<li><code><a title="exchangelib.services.CreateItem.SERVICE_NAME" href="#exchangelib.services.CreateItem.SERVICE_NAME">SERVICE_NAME</a></code></li>
<li><code><a title="exchangelib.services.CreateItem.call" href="#exchangelib.services.CreateItem.call">call</a></code></li>
<li><code><a title="exchangelib.services.CreateItem.element_container_name" href="#exchangelib.services.CreateItem.element_container_name">element_container_name</a></code></li>
<li><code><a title="exchangelib.services.CreateItem.get_payload" href="#exchangelib.services.CreateItem.get_payload">get_payload</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="exchangelib.services.DeleteAttachment" href="#exchangelib.services.DeleteAttachment">DeleteAttachment</a></code></h4>
<ul class="">
<li><code><a title="exchangelib.services.DeleteAttachment.SERVICE_NAME" href="#exchangelib.services.DeleteAttachment.SERVICE_NAME">SERVICE_NAME</a></code></li>
<li><code><a title="exchangelib.services.DeleteAttachment.call" href="#exchangelib.services.DeleteAttachment.call">call</a></code></li>
<li><code><a title="exchangelib.services.DeleteAttachment.get_payload" href="#exchangelib.services.DeleteAttachment.get_payload">get_payload</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="exchangelib.services.DeleteFolder" href="#exchangelib.services.DeleteFolder">DeleteFolder</a></code></h4>
<ul class="">
<li><code><a title="exchangelib.services.DeleteFolder.SERVICE_NAME" href="#exchangelib.services.DeleteFolder.SERVICE_NAME">SERVICE_NAME</a></code></li>
<li><code><a title="exchangelib.services.DeleteFolder.call" href="#exchangelib.services.DeleteFolder.call">call</a></code></li>
<li><code><a title="exchangelib.services.DeleteFolder.element_container_name" href="#exchangelib.services.DeleteFolder.element_container_name">element_container_name</a></code></li>
<li><code><a title="exchangelib.services.DeleteFolder.get_payload" href="#exchangelib.services.DeleteFolder.get_payload">get_payload</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="exchangelib.services.DeleteItem" href="#exchangelib.services.DeleteItem">DeleteItem</a></code></h4>
<ul class="">
<li><code><a title="exchangelib.services.DeleteItem.SERVICE_NAME" href="#exchangelib.services.DeleteItem.SERVICE_NAME">SERVICE_NAME</a></code></li>
<li><code><a title="exchangelib.services.DeleteItem.call" href="#exchangelib.services.DeleteItem.call">call</a></code></li>
<li><code><a title="exchangelib.services.DeleteItem.element_container_name" href="#exchangelib.services.DeleteItem.element_container_name">element_container_name</a></code></li>
<li><code><a title="exchangelib.services.DeleteItem.get_payload" href="#exchangelib.services.DeleteItem.get_payload">get_payload</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="exchangelib.services.EmptyFolder" href="#exchangelib.services.EmptyFolder">EmptyFolder</a></code></h4>
<ul class="">
<li><code><a title="exchangelib.services.EmptyFolder.SERVICE_NAME" href="#exchangelib.services.EmptyFolder.SERVICE_NAME">SERVICE_NAME</a></code></li>
<li><code><a title="exchangelib.services.EmptyFolder.call" href="#exchangelib.services.EmptyFolder.call">call</a></code></li>
<li><code><a title="exchangelib.services.EmptyFolder.element_container_name" href="#exchangelib.services.EmptyFolder.element_container_name">element_container_name</a></code></li>
<li><code><a title="exchangelib.services.EmptyFolder.get_payload" href="#exchangelib.services.EmptyFolder.get_payload">get_payload</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="exchangelib.services.ExpandDL" href="#exchangelib.services.ExpandDL">ExpandDL</a></code></h4>
<ul class="">
<li><code><a title="exchangelib.services.ExpandDL.ERRORS_TO_CATCH_IN_RESPONSE" href="#exchangelib.services.ExpandDL.ERRORS_TO_CATCH_IN_RESPONSE">ERRORS_TO_CATCH_IN_RESPONSE</a></code></li>
<li><code><a title="exchangelib.services.ExpandDL.SERVICE_NAME" href="#exchangelib.services.ExpandDL.SERVICE_NAME">SERVICE_NAME</a></code></li>
<li><code><a title="exchangelib.services.ExpandDL.WARNINGS_TO_IGNORE_IN_RESPONSE" href="#exchangelib.services.ExpandDL.WARNINGS_TO_IGNORE_IN_RESPONSE">WARNINGS_TO_IGNORE_IN_RESPONSE</a></code></li>
<li><code><a title="exchangelib.services.ExpandDL.call" href="#exchangelib.services.ExpandDL.call">call</a></code></li>
<li><code><a title="exchangelib.services.ExpandDL.element_container_name" href="#exchangelib.services.ExpandDL.element_container_name">element_container_name</a></code></li>
<li><code><a title="exchangelib.services.ExpandDL.get_payload" href="#exchangelib.services.ExpandDL.get_payload">get_payload</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="exchangelib.services.ExportItems" href="#exchangelib.services.ExportItems">ExportItems</a></code></h4>
<ul class="">
<li><code><a title="exchangelib.services.ExportItems.ERRORS_TO_CATCH_IN_RESPONSE" href="#exchangelib.services.ExportItems.ERRORS_TO_CATCH_IN_RESPONSE">ERRORS_TO_CATCH_IN_RESPONSE</a></code></li>
<li><code><a title="exchangelib.services.ExportItems.SERVICE_NAME" href="#exchangelib.services.ExportItems.SERVICE_NAME">SERVICE_NAME</a></code></li>
<li><code><a title="exchangelib.services.ExportItems.call" href="#exchangelib.services.ExportItems.call">call</a></code></li>
<li><code><a title="exchangelib.services.ExportItems.element_container_name" href="#exchangelib.services.ExportItems.element_container_name">element_container_name</a></code></li>
<li><code><a title="exchangelib.services.ExportItems.get_payload" href="#exchangelib.services.ExportItems.get_payload">get_payload</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="exchangelib.services.FindFolder" href="#exchangelib.services.FindFolder">FindFolder</a></code></h4>
<ul class="">
<li><code><a title="exchangelib.services.FindFolder.SERVICE_NAME" href="#exchangelib.services.FindFolder.SERVICE_NAME">SERVICE_NAME</a></code></li>
<li><code><a title="exchangelib.services.FindFolder.call" href="#exchangelib.services.FindFolder.call">call</a></code></li>
<li><code><a title="exchangelib.services.FindFolder.element_container_name" href="#exchangelib.services.FindFolder.element_container_name">element_container_name</a></code></li>
<li><code><a title="exchangelib.services.FindFolder.get_payload" href="#exchangelib.services.FindFolder.get_payload">get_payload</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="exchangelib.services.FindItem" href="#exchangelib.services.FindItem">FindItem</a></code></h4>
<ul class="">
<li><code><a title="exchangelib.services.FindItem.SERVICE_NAME" href="#exchangelib.services.FindItem.SERVICE_NAME">SERVICE_NAME</a></code></li>
<li><code><a title="exchangelib.services.FindItem.call" href="#exchangelib.services.FindItem.call">call</a></code></li>
<li><code><a title="exchangelib.services.FindItem.element_container_name" href="#exchangelib.services.FindItem.element_container_name">element_container_name</a></code></li>
<li><code><a title="exchangelib.services.FindItem.get_payload" href="#exchangelib.services.FindItem.get_payload">get_payload</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="exchangelib.services.FindPeople" href="#exchangelib.services.FindPeople">FindPeople</a></code></h4>
<ul class="">
<li><code><a title="exchangelib.services.FindPeople.SERVICE_NAME" href="#exchangelib.services.FindPeople.SERVICE_NAME">SERVICE_NAME</a></code></li>
<li><code><a title="exchangelib.services.FindPeople.call" href="#exchangelib.services.FindPeople.call">call</a></code></li>
<li><code><a title="exchangelib.services.FindPeople.element_container_name" href="#exchangelib.services.FindPeople.element_container_name">element_container_name</a></code></li>
<li><code><a title="exchangelib.services.FindPeople.get_payload" href="#exchangelib.services.FindPeople.get_payload">get_payload</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="exchangelib.services.GetAttachment" href="#exchangelib.services.GetAttachment">GetAttachment</a></code></h4>
<ul class="">
<li><code><a title="exchangelib.services.GetAttachment.SERVICE_NAME" href="#exchangelib.services.GetAttachment.SERVICE_NAME">SERVICE_NAME</a></code></li>
<li><code><a title="exchangelib.services.GetAttachment.call" href="#exchangelib.services.GetAttachment.call">call</a></code></li>
<li><code><a title="exchangelib.services.GetAttachment.element_container_name" href="#exchangelib.services.GetAttachment.element_container_name">element_container_name</a></code></li>
<li><code><a title="exchangelib.services.GetAttachment.get_payload" href="#exchangelib.services.GetAttachment.get_payload">get_payload</a></code></li>
<li><code><a title="exchangelib.services.GetAttachment.stream_file_content" href="#exchangelib.services.GetAttachment.stream_file_content">stream_file_content</a></code></li>
<li><code><a title="exchangelib.services.GetAttachment.streaming" href="#exchangelib.services.GetAttachment.streaming">streaming</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="exchangelib.services.GetDelegate" href="#exchangelib.services.GetDelegate">GetDelegate</a></code></h4>
<ul class="">
<li><code><a title="exchangelib.services.GetDelegate.SERVICE_NAME" href="#exchangelib.services.GetDelegate.SERVICE_NAME">SERVICE_NAME</a></code></li>
<li><code><a title="exchangelib.services.GetDelegate.call" href="#exchangelib.services.GetDelegate.call">call</a></code></li>
<li><code><a title="exchangelib.services.GetDelegate.get_payload" href="#exchangelib.services.GetDelegate.get_payload">get_payload</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="exchangelib.services.GetFolder" href="#exchangelib.services.GetFolder">GetFolder</a></code></h4>
<ul class="">
<li><code><a title="exchangelib.services.GetFolder.ERRORS_TO_CATCH_IN_RESPONSE" href="#exchangelib.services.GetFolder.ERRORS_TO_CATCH_IN_RESPONSE">ERRORS_TO_CATCH_IN_RESPONSE</a></code></li>
<li><code><a title="exchangelib.services.GetFolder.SERVICE_NAME" href="#exchangelib.services.GetFolder.SERVICE_NAME">SERVICE_NAME</a></code></li>
<li><code><a title="exchangelib.services.GetFolder.call" href="#exchangelib.services.GetFolder.call">call</a></code></li>
<li><code><a title="exchangelib.services.GetFolder.element_container_name" href="#exchangelib.services.GetFolder.element_container_name">element_container_name</a></code></li>
<li><code><a title="exchangelib.services.GetFolder.get_payload" href="#exchangelib.services.GetFolder.get_payload">get_payload</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="exchangelib.services.GetItem" href="#exchangelib.services.GetItem">GetItem</a></code></h4>
<ul class="">
<li><code><a title="exchangelib.services.GetItem.SERVICE_NAME" href="#exchangelib.services.GetItem.SERVICE_NAME">SERVICE_NAME</a></code></li>
<li><code><a title="exchangelib.services.GetItem.call" href="#exchangelib.services.GetItem.call">call</a></code></li>
<li><code><a title="exchangelib.services.GetItem.element_container_name" href="#exchangelib.services.GetItem.element_container_name">element_container_name</a></code></li>
<li><code><a title="exchangelib.services.GetItem.get_payload" href="#exchangelib.services.GetItem.get_payload">get_payload</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="exchangelib.services.GetMailTips" href="#exchangelib.services.GetMailTips">GetMailTips</a></code></h4>
<ul class="">
<li><code><a title="exchangelib.services.GetMailTips.SERVICE_NAME" href="#exchangelib.services.GetMailTips.SERVICE_NAME">SERVICE_NAME</a></code></li>
<li><code><a title="exchangelib.services.GetMailTips.call" href="#exchangelib.services.GetMailTips.call">call</a></code></li>
<li><code><a title="exchangelib.services.GetMailTips.get_payload" href="#exchangelib.services.GetMailTips.get_payload">get_payload</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="exchangelib.services.GetPersona" href="#exchangelib.services.GetPersona">GetPersona</a></code></h4>
<ul class="">
<li><code><a title="exchangelib.services.GetPersona.SERVICE_NAME" href="#exchangelib.services.GetPersona.SERVICE_NAME">SERVICE_NAME</a></code></li>
<li><code><a title="exchangelib.services.GetPersona.call" href="#exchangelib.services.GetPersona.call">call</a></code></li>
<li><code><a title="exchangelib.services.GetPersona.get_payload" href="#exchangelib.services.GetPersona.get_payload">get_payload</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="exchangelib.services.GetRoomLists" href="#exchangelib.services.GetRoomLists">GetRoomLists</a></code></h4>
<ul class="">
<li><code><a title="exchangelib.services.GetRoomLists.SERVICE_NAME" href="#exchangelib.services.GetRoomLists.SERVICE_NAME">SERVICE_NAME</a></code></li>
<li><code><a title="exchangelib.services.GetRoomLists.call" href="#exchangelib.services.GetRoomLists.call">call</a></code></li>
<li><code><a title="exchangelib.services.GetRoomLists.element_container_name" href="#exchangelib.services.GetRoomLists.element_container_name">element_container_name</a></code></li>
<li><code><a title="exchangelib.services.GetRoomLists.get_payload" href="#exchangelib.services.GetRoomLists.get_payload">get_payload</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="exchangelib.services.GetRooms" href="#exchangelib.services.GetRooms">GetRooms</a></code></h4>
<ul class="">
<li><code><a title="exchangelib.services.GetRooms.SERVICE_NAME" href="#exchangelib.services.GetRooms.SERVICE_NAME">SERVICE_NAME</a></code></li>
<li><code><a title="exchangelib.services.GetRooms.call" href="#exchangelib.services.GetRooms.call">call</a></code></li>
<li><code><a title="exchangelib.services.GetRooms.element_container_name" href="#exchangelib.services.GetRooms.element_container_name">element_container_name</a></code></li>
<li><code><a title="exchangelib.services.GetRooms.get_payload" href="#exchangelib.services.GetRooms.get_payload">get_payload</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="exchangelib.services.GetSearchableMailboxes" href="#exchangelib.services.GetSearchableMailboxes">GetSearchableMailboxes</a></code></h4>
<ul class="">
<li><code><a title="exchangelib.services.GetSearchableMailboxes.SERVICE_NAME" href="#exchangelib.services.GetSearchableMailboxes.SERVICE_NAME">SERVICE_NAME</a></code></li>
<li><code><a title="exchangelib.services.GetSearchableMailboxes.call" href="#exchangelib.services.GetSearchableMailboxes.call">call</a></code></li>
<li><code><a title="exchangelib.services.GetSearchableMailboxes.element_container_name" href="#exchangelib.services.GetSearchableMailboxes.element_container_name">element_container_name</a></code></li>
<li><code><a title="exchangelib.services.GetSearchableMailboxes.failed_mailboxes_container_name" href="#exchangelib.services.GetSearchableMailboxes.failed_mailboxes_container_name">failed_mailboxes_container_name</a></code></li>
<li><code><a title="exchangelib.services.GetSearchableMailboxes.get_payload" href="#exchangelib.services.GetSearchableMailboxes.get_payload">get_payload</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="exchangelib.services.GetServerTimeZones" href="#exchangelib.services.GetServerTimeZones">GetServerTimeZones</a></code></h4>
<ul class="">
<li><code><a title="exchangelib.services.GetServerTimeZones.SERVICE_NAME" href="#exchangelib.services.GetServerTimeZones.SERVICE_NAME">SERVICE_NAME</a></code></li>
<li><code><a title="exchangelib.services.GetServerTimeZones.call" href="#exchangelib.services.GetServerTimeZones.call">call</a></code></li>
<li><code><a title="exchangelib.services.GetServerTimeZones.element_container_name" href="#exchangelib.services.GetServerTimeZones.element_container_name">element_container_name</a></code></li>
<li><code><a title="exchangelib.services.GetServerTimeZones.get_payload" href="#exchangelib.services.GetServerTimeZones.get_payload">get_payload</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="exchangelib.services.GetUserAvailability" href="#exchangelib.services.GetUserAvailability">GetUserAvailability</a></code></h4>
<ul class="">
<li><code><a title="exchangelib.services.GetUserAvailability.SERVICE_NAME" href="#exchangelib.services.GetUserAvailability.SERVICE_NAME">SERVICE_NAME</a></code></li>
<li><code><a title="exchangelib.services.GetUserAvailability.call" href="#exchangelib.services.GetUserAvailability.call">call</a></code></li>
<li><code><a title="exchangelib.services.GetUserAvailability.get_payload" href="#exchangelib.services.GetUserAvailability.get_payload">get_payload</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="exchangelib.services.GetUserOofSettings" href="#exchangelib.services.GetUserOofSettings">GetUserOofSettings</a></code></h4>
<ul class="">
<li><code><a title="exchangelib.services.GetUserOofSettings.SERVICE_NAME" href="#exchangelib.services.GetUserOofSettings.SERVICE_NAME">SERVICE_NAME</a></code></li>
<li><code><a title="exchangelib.services.GetUserOofSettings.call" href="#exchangelib.services.GetUserOofSettings.call">call</a></code></li>
<li><code><a title="exchangelib.services.GetUserOofSettings.element_container_name" href="#exchangelib.services.GetUserOofSettings.element_container_name">element_container_name</a></code></li>
<li><code><a title="exchangelib.services.GetUserOofSettings.get_payload" href="#exchangelib.services.GetUserOofSettings.get_payload">get_payload</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="exchangelib.services.MoveItem" href="#exchangelib.services.MoveItem">MoveItem</a></code></h4>
<ul class="">
<li><code><a title="exchangelib.services.MoveItem.SERVICE_NAME" href="#exchangelib.services.MoveItem.SERVICE_NAME">SERVICE_NAME</a></code></li>
<li><code><a title="exchangelib.services.MoveItem.call" href="#exchangelib.services.MoveItem.call">call</a></code></li>
<li><code><a title="exchangelib.services.MoveItem.element_container_name" href="#exchangelib.services.MoveItem.element_container_name">element_container_name</a></code></li>
<li><code><a title="exchangelib.services.MoveItem.get_payload" href="#exchangelib.services.MoveItem.get_payload">get_payload</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="exchangelib.services.ResolveNames" href="#exchangelib.services.ResolveNames">ResolveNames</a></code></h4>
<ul class="">
<li><code><a title="exchangelib.services.ResolveNames.ERRORS_TO_CATCH_IN_RESPONSE" href="#exchangelib.services.ResolveNames.ERRORS_TO_CATCH_IN_RESPONSE">ERRORS_TO_CATCH_IN_RESPONSE</a></code></li>
<li><code><a title="exchangelib.services.ResolveNames.SERVICE_NAME" href="#exchangelib.services.ResolveNames.SERVICE_NAME">SERVICE_NAME</a></code></li>
<li><code><a title="exchangelib.services.ResolveNames.WARNINGS_TO_IGNORE_IN_RESPONSE" href="#exchangelib.services.ResolveNames.WARNINGS_TO_IGNORE_IN_RESPONSE">WARNINGS_TO_IGNORE_IN_RESPONSE</a></code></li>
<li><code><a title="exchangelib.services.ResolveNames.call" href="#exchangelib.services.ResolveNames.call">call</a></code></li>
<li><code><a title="exchangelib.services.ResolveNames.element_container_name" href="#exchangelib.services.ResolveNames.element_container_name">element_container_name</a></code></li>
<li><code><a title="exchangelib.services.ResolveNames.get_payload" href="#exchangelib.services.ResolveNames.get_payload">get_payload</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="exchangelib.services.SendItem" href="#exchangelib.services.SendItem">SendItem</a></code></h4>
<ul class="">
<li><code><a title="exchangelib.services.SendItem.SERVICE_NAME" href="#exchangelib.services.SendItem.SERVICE_NAME">SERVICE_NAME</a></code></li>
<li><code><a title="exchangelib.services.SendItem.call" href="#exchangelib.services.SendItem.call">call</a></code></li>
<li><code><a title="exchangelib.services.SendItem.element_container_name" href="#exchangelib.services.SendItem.element_container_name">element_container_name</a></code></li>
<li><code><a title="exchangelib.services.SendItem.get_payload" href="#exchangelib.services.SendItem.get_payload">get_payload</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="exchangelib.services.SetUserOofSettings" href="#exchangelib.services.SetUserOofSettings">SetUserOofSettings</a></code></h4>
<ul class="">
<li><code><a title="exchangelib.services.SetUserOofSettings.SERVICE_NAME" href="#exchangelib.services.SetUserOofSettings.SERVICE_NAME">SERVICE_NAME</a></code></li>
<li><code><a title="exchangelib.services.SetUserOofSettings.call" href="#exchangelib.services.SetUserOofSettings.call">call</a></code></li>
<li><code><a title="exchangelib.services.SetUserOofSettings.get_payload" href="#exchangelib.services.SetUserOofSettings.get_payload">get_payload</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="exchangelib.services.UpdateFolder" href="#exchangelib.services.UpdateFolder">UpdateFolder</a></code></h4>
<ul class="">
<li><code><a title="exchangelib.services.UpdateFolder.SERVICE_NAME" href="#exchangelib.services.UpdateFolder.SERVICE_NAME">SERVICE_NAME</a></code></li>
<li><code><a title="exchangelib.services.UpdateFolder.call" href="#exchangelib.services.UpdateFolder.call">call</a></code></li>
<li><code><a title="exchangelib.services.UpdateFolder.element_container_name" href="#exchangelib.services.UpdateFolder.element_container_name">element_container_name</a></code></li>
<li><code><a title="exchangelib.services.UpdateFolder.get_payload" href="#exchangelib.services.UpdateFolder.get_payload">get_payload</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="exchangelib.services.UpdateItem" href="#exchangelib.services.UpdateItem">UpdateItem</a></code></h4>
<ul class="">
<li><code><a title="exchangelib.services.UpdateItem.SERVICE_NAME" href="#exchangelib.services.UpdateItem.SERVICE_NAME">SERVICE_NAME</a></code></li>
<li><code><a title="exchangelib.services.UpdateItem.call" href="#exchangelib.services.UpdateItem.call">call</a></code></li>
<li><code><a title="exchangelib.services.UpdateItem.element_container_name" href="#exchangelib.services.UpdateItem.element_container_name">element_container_name</a></code></li>
<li><code><a title="exchangelib.services.UpdateItem.get_payload" href="#exchangelib.services.UpdateItem.get_payload">get_payload</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="exchangelib.services.UploadItems" href="#exchangelib.services.UploadItems">UploadItems</a></code></h4>
<ul class="">
<li><code><a title="exchangelib.services.UploadItems.SERVICE_NAME" href="#exchangelib.services.UploadItems.SERVICE_NAME">SERVICE_NAME</a></code></li>
<li><code><a title="exchangelib.services.UploadItems.call" href="#exchangelib.services.UploadItems.call">call</a></code></li>
<li><code><a title="exchangelib.services.UploadItems.element_container_name" href="#exchangelib.services.UploadItems.element_container_name">element_container_name</a></code></li>
<li><code><a title="exchangelib.services.UploadItems.get_payload" href="#exchangelib.services.UploadItems.get_payload">get_payload</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.1</a>.</p>
</footer>
</body>
</html>